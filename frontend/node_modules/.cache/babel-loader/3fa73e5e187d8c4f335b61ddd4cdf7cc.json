{"ast":null,"code":"import{Log,DModel,DValue,DObject,DEnumerator,DEnumLiteral,DAttribute,DReference,DClass,DParameter,DOperation,DPackage,DAnnotation,AttribETypes,U,Selectors,PointedBy,LPointerTargetable,windoww,SetRootFieldAction,Constructors,store,SetFieldAction,DPointerTargetable,ShortAttribETypes,toLongEType}from\"../joiner\";import{ShortDefaultEClasses,toLongEClass}from\"../common/U\";class SavePack{constructor(){let model=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';let vertexpos=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';let view=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';this.model=void 0;this.vertexpos=void 0;this.view=void 0;this.model=model;this.vertexpos=vertexpos;this.view=view;}}export class IStorage{static get(){return Log.exx(\"IStorage.get (static) should be overridden\");}constructor(prefix,autosave){this.prefix=void 0;this.autosave=void 0;this.prefix=prefix;this.autosave=autosave;}del(key){let isOverwrite=this.get(key)!==null;this.set(key,'');return isOverwrite;}get(key){let parse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return Log.exx(\"IStorage.get should be overridden\");}serialize(val){// serialize\ntry{return JSON.stringify(val);}catch(e){return\"\"+val;}}deserialize(val){// de-serialize\ntry{return JSON.parse(val);}catch(e){return val;}}set0(val){return this.serialize(val);}get0(val){return this.deserialize(val);}parse(val){return this.deserialize(val);}}export class LocalStorage extends IStorage{static get(){return new LocalStorage(\"_j\",true);}constructor(prefix,autosave){super(prefix,autosave);}get(key){let parse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let val=localStorage.getItem(this.prefix+key);return parse?this.parse(val):val;}set(key,val){val=this.serialize(val);// let isOverwrite = localStorage.getItem(this.prefix+key);\nlocalStorage.set(this.prefix+key,val);return true;}getLastOpened(modelNumber){let modelname=\"m\"+modelNumber+\"_\";const ret=new SavePack();ret.model=this.get(modelname+LocalStorage.KeyList.lastOpenedModel,false)||'';ret.view=this.get(modelNumber+LocalStorage.KeyList.lastOpenedView,false)||'';ret.vertexpos=this.get(modelNumber+LocalStorage.KeyList.lastOpenedPosition,false)||'';return ret;}deleteLastOpened(modelNumber){this.setLastOpened(modelNumber,'','','');}setLastOpened(modelNumber){let model=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';let view=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';let vertex=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'';let modelname=\"m\"+modelNumber+\"_\";if(model)this.set(modelname+LocalStorage.KeyList.lastOpenedModel,model);else this.del(modelname+LocalStorage.KeyList.lastOpenedModel);if(view)this.set(modelname+LocalStorage.KeyList.lastOpenedView,view);else this.del(modelname+LocalStorage.KeyList.lastOpenedView);if(vertex)this.set(modelname+LocalStorage.KeyList.lastOpenedPosition,vertex);else this.del(modelname+LocalStorage.KeyList.lastOpenedPosition);}}LocalStorage.KeyList={lastOpenedModel:\"lastOpenedModel\",lastOpenedView:\"lastOpenedView\",lastOpenedPosition:\"lastOpenedPosition\"};export class EcoreParser{static parse(ecorejson,isMetamodel,filename){let persist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!ecorejson)return[];let parsedjson;if(typeof ecorejson===\"string\")try{parsedjson=JSON.parse(ecorejson);}catch(e){windoww.temp=ecorejson;Log.exx(\"error while parsing json:\",e,ecorejson.substring(0,1000));throw e;}else parsedjson=ecorejson;console.log(\"root parse\",{ecorejson,parsedjson});// isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\nConstructors.paused=true;let parsedElements=isMetamodel?EcoreParser.parseM2Model(parsedjson,filename):EcoreParser.parseM1Model(parsedjson,undefined,filename);console.warn(\"parse.result D\",parsedElements);this.LinkAllNamesToIDs(parsedElements);this.fixNamingConflicts(parsedElements);Constructors.paused=false;// if (persist) CreateElementAction.newBatch(parsedElements);\n// update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\nthis.fixObjectPointers(parsedElements);// updates dvalue.values from ecore reference to pointers.\nConstructors.persist(parsedElements);windoww.tmpparse=()=>LPointerTargetable.wrapAll(parsedElements);this.tempfix_untilopennewtabisdone(parsedElements,isMetamodel);console.log('parsedElem',parsedElements);return parsedElements;}static fixObjectPointers(parsedElements){let dobjects=parsedElements.filter(e=>e.className===DObject.cname);let values=parsedElements.filter(e=>e.className===DValue.cname);let lobjects=LPointerTargetable.fromArr(dobjects);let m1pointermap={};//    \"//@rootrefname.index@/refname.index/@....etc\"\nfor(let o of lobjects){m1pointermap[o.ecorePointer()]=o;}for(let v of values){if(v.isMirage)continue;let modified=false;let newvalues=v.values.map(e=>{if(!m1pointermap[e])return e;modified=true;console.log(\"m1 pointer resolved:\",{from:e,to:m1pointermap[e].id});return m1pointermap[e].id;});if(!modified)continue;//let lv: LValue = LPointerTargetable.from(v);\nv.values=newvalues;}}static tempfix_untilopennewtabisdone(parsedElements,isMetamodel){// replaces current model with parsed model. this needs to be removed to open a new tab later on.\nlet model=null;for(let elem of parsedElements){if(elem.className===DModel.cname){model=elem;break;}}SetRootFieldAction.new(isMetamodel?\"m2models\":\"m1models\",model.id,'+=',false);// it is pointer but no need to update pointedby's this time\n}// resolve eCore pointers to Jodel pointers and set the PointedBy\nstatic LinkAllNamesToIDs(parsedElements){// todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\n// update mref, attribute, parameter type\n// update operation exception\n// replace those names with id's\nlet idMap={};let nameMap={};let replacePrimitiveMap={};let d_Estring=Selectors.getAllPrimitiveTypes()[1];replacePrimitiveMap[AttribETypes.EString]=d_Estring;// todo: do the same for all other primitives\nlet state=store.getState();// let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\nconst typeprefix=\"#//\";for(let shortkey in ShortAttribETypes){if(shortkey===ShortAttribETypes.EVoid)continue;let shortetype=ShortAttribETypes[shortkey];let longetype=toLongEType(shortetype);let dClassType=Selectors.getPrimitiveType(shortetype,state);Log.exDev(!dClassType,\"missing primitive type: \"+shortkey,{shortkey,shortetype,longetype,dClassType,state});// the correct one\nreplacePrimitiveMap[typeprefix+shortkey]=dClassType;// like \"#//EChar\"\n// fallbacks for missing type instead of crash\nif(!replacePrimitiveMap[shortkey])replacePrimitiveMap[shortkey]=dClassType;if(!replacePrimitiveMap[shortetype])replacePrimitiveMap[shortetype]=dClassType;if(!replacePrimitiveMap[longetype])replacePrimitiveMap[longetype]=dClassType;}for(let shortkey in ShortDefaultEClasses){let shortetype=ShortDefaultEClasses[shortkey];let longetype=toLongEClass(shortetype);let dClassType=Selectors.getDefaultEcoreClass(shortetype,state);Log.exDev(!dClassType,\"missing ecore native class: \"+shortkey,{shortkey,shortetype,longetype,dClassType,state});// the correct one\nreplacePrimitiveMap[longetype]=dClassType;// fallbacks for missing type instead of crash\nif(!replacePrimitiveMap[shortkey])replacePrimitiveMap[shortkey]=dClassType;if(!replacePrimitiveMap[shortetype])replacePrimitiveMap[shortetype]=dClassType;if(!replacePrimitiveMap[longetype])replacePrimitiveMap[typeprefix+shortkey]=dClassType;// like \"#//EObject\"\n}for(let ecorename in replacePrimitiveMap){// duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\nif(idMap[replacePrimitiveMap[ecorename].id])continue;idMap[replacePrimitiveMap[ecorename].id]=replacePrimitiveMap[ecorename];}// let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\nlet replaceRules=[\"extends\",/*\"extendedBy\",*/\"exceptions\",\"type\",\"values\"];let dobj;for(dobj of parsedElements){idMap[dobj.id]=dobj;if(!dobj.name||dobj.className===DModel.cname)continue;// Model name can be reused internally\nlet name=dobj.__fullname;delete dobj.__fullname;if(dobj.className===DOperation.cname||dobj.className===DParameter.cname){// operation overload, in this case i create N separate operations, but all references will point to the last operation.\n// empty on purpose, just avoid naming check\n}// todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\n// else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\nelse Log.w(!!nameMap[typeprefix+name],\"found 2 elements with same name\",{nameMap,new:dobj,old:nameMap[typeprefix+name],name,shortname:dobj.name,typeprefix});nameMap[typeprefix+name]=dobj;// nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\n}for(let replacekey of replaceRules){for(dobj of parsedElements){let valtmp=dobj[replacekey];if(valtmp===undefined)continue;// for missing properties in a d-object like looking for extends on a dmodel.\nlet values;let isArray=Array.isArray(valtmp);if(isArray){values=valtmp;dobj[replacekey]=[];}else{values=[valtmp];}for(let value of values){if(!value)continue;// console.log(\"fixalltypes\", {replacekey, dobj, value, values});\nlet target=replacePrimitiveMap[value];if(!target)target=nameMap[value];if(!target&&value.indexOf(\"ecore:EDataType\")===0){Log.ww('found unknown EDataType \"'+value+'\", remapping it to string');target=replacePrimitiveMap[AttribETypes.EString];}/*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/ // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\n// (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\nif(replacekey===\"extends\"){if(!target)continue;Log.ex(target.className!==DClass.cname,\"found a class attempting to extend an object that is not a class\",{target,dobj,replacePrimitiveMap,nameMap,idMap});target.extendedBy.push(dobj.id);}Log.ex(!target,\"LinkAllNames() can't find type target:\",{value,nameMap,replacePrimitiveMap,dobj,replacekey});if(isArray)dobj[replacekey].push(target.id);else dobj[replacekey]=target.id;}}}// fix from ordinals to Pointer<DEnumLiteral>\nfunction DfromPtr(id){return!id?undefined:DPointerTargetable.fromPointer(id,state);}function getLiteral(id,ordinal){var _LPointerTargetable$f,_LPointerTargetable$f2;return(_LPointerTargetable$f=LPointerTargetable.fromD(DfromPtr(id)))===null||_LPointerTargetable$f===void 0?void 0:(_LPointerTargetable$f2=_LPointerTargetable$f.ordinals[ordinal])===null||_LPointerTargetable$f2===void 0?void 0:_LPointerTargetable$f2.__raw;}for(let elem of parsedElements){if(elem.className!==DValue.cname)continue;let dval=elem;let meta=DfromPtr(dval.instanceof);if(!meta)continue;let type=DfromPtr(meta.type);if(!type||type.className!==DEnumLiteral.cname)continue;let mapper=v=>{if(typeof v!==\"number\"){Log.ee(\"found non-numeric value in a literal value.\",v,dval);return v;}let l=getLiteral(type.id,v);return l?l.id:v;};dval.values=dval.values.map(mapper);}// finally: set all pointedby\nfor(let ptrkey of PointedBy.list)for(dobj of parsedElements){let valtmp=dobj[ptrkey];let values;if(Array.isArray(valtmp)){values=valtmp;}else{if(valtmp===undefined)values=[];// if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\nelse values=[valtmp];}for(let value of values){if(!value)continue;// errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\nlet target=idMap[value];if(target){target.pointedBy.push(PointedBy.new(\"idlookup.\"+dobj.id+\".\"+ptrkey));}else{target=DfromPtr(value);console.log(\"fixalltypes\",{ptrkey,valtmp,dobj,value,values,target,idMap});if(!target)throw new Error(\"target undefined\");SetFieldAction.new(target,\"pointedBy\",PointedBy.new(\"idlookup.\"+dobj.id+\".\"+ptrkey),'+=',false);}}}// update superclasses\nthis.updateSuperClasses(parsedElements);}static todoGetPrimitiveTypenope(type){// akready fixed in LinkAllNamesToID\nreturn'todoGetPrimitiveType from parser';}static updateSuperClasses(parsedElements){// todo:3\n}static fixNamingConflicts(parsedElements){// todo:4 final\n}static parseM2Model(json,filename){let generated=[];if(!json){json={};}let modelname=json[ECoreNamed.namee];if(!modelname&&filename){let pos=filename.indexOf(\".\");modelname=pos===-1?filename:filename.substring(0,pos);}let dObject=DModel.new(modelname||\"imported_metamodel_1\",undefined,true,true);console.log(\"made model\",json);generated.push(dObject);// dObject.father = 'modeltmp' as any;\n// const annotations: Json[] = this.getAnnotations(json); i set them on root package\n// for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\n/// *** specific  *** ///\n// let defPackage: DPackage = DPackage.new(json)\nEcoreParser.parseRootPackage(dObject,json,generated);return generated;}static parseM2Model_old(json,filename){let generated=[];if(!json){json={};}let modelname=json[ECoreNamed.namee];if(!modelname&&filename){let pos=filename.indexOf(\".\");modelname=pos===-1?filename:filename.substring(0,pos);}let dObject=DModel.new(modelname||\"imported_metamodel_1\",undefined,true,true);console.log(\"made model\",json);generated.push(dObject);// dObject.father = 'modeltmp' as any;\n/// *** specific  *** ///\nconst children=EcoreParser.getChildren(json);const annotations=EcoreParser.getAnnotations(json);// dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\nconsole.log(\"made model 2\",children,annotations);for(let child of annotations){EcoreParser.parseDAnnotation(dObject,child,generated,'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');}console.log(\"made annotations\");for(let child of children){EcoreParser.parseRootPackage(dObject,child,generated);}console.log(\"made packages\");return generated;}static parseM1Model(json,meta,filename){var _meta;let generated=[];if(!json){json={};}/// *** specific  *** ///\n// this.parseDObject(json, dObject, DModel,undefined, generated);\nlet allmodels;if(!meta&&filename){allmodels=Selectors.getAll(DModel);allmodels=allmodels.filter(m=>m.name===filename);meta=LPointerTargetable.fromD(allmodels[0]);}else allmodels=[];let xmlns=EcoreParser.XMLinlineMarker+\"xmlns:\";let ns=undefined;function findns(key){let pos=key.indexOf(\":\");if(pos<=0)return false;return ns=key.substring(0,pos);// through namespace before the name of the root objects;\n// additional method: through xmlns key\n// if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n// ns = key.substring(xmlns.length); break;\n}outerloop:for(let key0 in json){// ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\nif(findns(key0))break;let val0=json[key0];if(typeof val0===\"object\")for(let key1 in val0){if(findns(key0))break outerloop;}}if(ns&&!meta){var _matchpkg$;let allpkgs=Selectors.getAll(DPackage,undefined,undefined,true,true);let matchpkg=allpkgs.filter(d=>d.uri===ns);meta=(_matchpkg$=matchpkg[0])===null||_matchpkg$===void 0?void 0:_matchpkg$.model;// Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\n}let modelname='';if(!modelname&&filename){let pos=filename.indexOf(\".\");modelname=pos===-1?filename:filename.substring(0,pos);}let dObject=DModel.new(modelname||\"imported_model_1\",(_meta=meta)===null||_meta===void 0?void 0:_meta.id,false,true);console.log(\"made model\",json);generated.push(dObject);for(let key in json){switch(key){case ECoreObject.xmi_version:// this is only on roots\nLog.ex(json[key]!==\"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key]+\"\\\"\");break;// case ECoreObject.xmlnsecore:\ncase ECoreObject.xmlns_xmi:let expected=\"http://www.omg.org/XMI\";Log.ex(json[key]!==expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key]+\"\\\"\");break;default:// a feature name\nlet val=json[key];if(!val)continue;if(key.indexOf(xmlns)===0)continue;// \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\nif(key[0]===EcoreParser.XMLinlineMarker)key=key.substring(EcoreParser.XMLinlineMarker.length);const namespacedclass=key;const mmclass=meta&&meta.getClassByNameSpace(namespacedclass);if(!mmclass)console.log(\"failed to get mmclass\",{meta,key,mmclass});const roots_for_this_metaclass=Array.isArray(val)?val:[val];// there might be N roots of class A, M of type B...\nfor(let rootjson of roots_for_this_metaclass){// DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\nEcoreParser.parseDObject(rootjson,dObject,DModel,mmclass,generated);}}}return generated;}/*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */ /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\n/// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\nstatic getobjectmetaclass(json,metaSuperClass){return metaSuperClass;// todo: comment this and execute below\nlet subclasses=!metaSuperClass?[]:[metaSuperClass];let subclasseshapes={};for(let sc of subclasses){subclasseshapes[sc.id]={l:sc};let row=subclasseshapes[sc.id];for(let feat of sc.children){let lfeat=feat;let dfeat=lfeat.__raw;if(!dfeat.name||!dfeat.type)continue;row[dfeat.name]=lfeat.type;}}return this.findBestMatch(subclasseshapes,json);}static findBestMatch(m2classes,json){throw new Error(\"todo\");return null;}static parseDObject(json,parent,parentType,meta,generated){var _meta2,_meta3;if(!json){json={};}meta=meta&&this.getobjectmetaclass(json,meta);// let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\n// let data: Partial<DObject> = {};\nlet dObject=DObject.new((_meta2=meta)===null||_meta2===void 0?void 0:_meta2.id,parent.id,parentType,json[\"name\"]||\"obj_1\");generated.push(dObject);dObject.father=parent.id;if(parent){if(parentType===DModel)parent.objects.push(dObject.id);else parent.values.push(dObject.id);}console.log(\"made dobject\",{json,dObject,meta,metaname:(_meta3=meta)===null||_meta3===void 0?void 0:_meta3.name});/// *** specific  *** ///\nfor(let key in json){switch(key){case ECoreObject.xmi_version:// this is only on roots\nLog.ex(json[key]!==\"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key]+\"\\\"\");break;// case ECoreObject.xmlnsecore:\ncase ECoreObject.xmlns_xmi:let expected=\"http://www.omg.org/XMI\";Log.ex(json[key]!==expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key]+\"\\\"\");break;default:// a feature name\nlet val=json[key];if(!val)continue;if(key[0]===EcoreParser.XMLinlineMarker)key=key.substring(1);if(key.indexOf(\"xmlns:\")===0)continue;// \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\nlet metafeature=meta&&meta[\"@\"+key];console.log(\"feature meta\",{json,dObject,key,val,metafeature,classmeta:meta});let values;if(Array.isArray(val))values=val;else if(val===undefined)values=[];else values=[val];EcoreParser.parseDValue(key,values,dObject/*father*/,metafeature/*meta*/,generated);// DValue.new(key, metafeature?.id, values, dObject, true, false);\n}}return generated;}static parseDValue(name,jsonvalues,parent,meta,generated){if(!jsonvalues){jsonvalues=[];}// let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\nconsole.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\");console.log(\"DValue.new(\",meta?undefined:name,\",\",meta===null||meta===void 0?void 0:meta.id,\",\",jsonvalues,\",\",parent.id);let dValue=DValue.new(meta?undefined:name,meta===null||meta===void 0?void 0:meta.id,[],parent.id,true,false);generated.push(dValue);dValue.father=parent.id;parent.features.push(dValue.id);console.log(\"made dValue\",{jsonvalues,dValue,meta,metaname:meta===null||meta===void 0?void 0:meta.name});if(meta&&meta.className===DAttribute.cname){dValue.values=jsonvalues;return generated;}for(let v of jsonvalues){if(typeof v!==\"object\"){dValue.values.push(v);continue;}// let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\n// generated.push(subdObject);\nEcoreParser.parseDObject(v,dValue,DValue,meta===null||meta===void 0?void 0:meta.type,generated);}return generated;}static parseDAnnotation(parent,json,generated,fullnamePrefix){return[];// todo\nif(!generated)generated=[];if(!json){json={};}let dObject=DAnnotation.new();generated.push(dObject);dObject.father=parent.id;dObject.name=this.read(json,ECoreNamed.namee,undefined);dObject.father=parent.id;if(parent)parent.annotations.push(dObject.id);const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");dObject.__fullname=undefined;// fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\n/// *** specific  *** ///\nlet key;for(key in json){const value=json[key];switch(key){//todo\ndefault:Log.exx('unexpected field in EAnnotation:  '+key+' => |'+value+'|',{key,value,json});break;// case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\ncase ECoreAnnotation.details:break;case ECoreAnnotation.references:break;case ECoreAnnotation.source:break;}}// annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\n// annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\n// const details: Json[] = this.getDetails(json);\n// for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\nreturn generated;}static parseRootPackage(parent,json,generated){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DPackage.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.packages.push(dObject.id);let version=json[EcoreParser.prefix+\"xmlns:ecore\"]||'';// model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\n// model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\nLog.ex(!EcoreParser.supportedEcoreVersions.includes(version),\"unsupported ecore version, must be one of:\"+EcoreParser.supportedEcoreVersions+\" found instead: \"+version);dObject.name=this.read(json,ECoreNamed.namee,'default');// root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\ndObject.__fullname='';// fullnamePrefix + \"/\" + dObject.name;\nconst annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\nconst subPackages=this.getSubPackages(json);dObject.uri=this.read(json,ECorePackage.nsURI,null);dObject.prefix=this.read(json,ECorePackage.nsPrefix,null);console.warn(\"parseRootPackage.children\",{childs,annotations,subPackages,dObject,generated});// if (!parent.uri) parent.uri = dObject.uri;\n// if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\nfor(let child of childs){switch(child[ECoreClass.xsitype]){default:Log.exx('unexpected xsitype:',child[ECoreClass.xsitype],' found in jsonfragment:',child,', in json:',json,' package:',dObject);break;case'ecore:EClass':this.parseDClass(dObject,child,generated,'');break;case'ecore:EEnum':this.parseDEnum(dObject,child,generated,'');break;}}for(let child of subPackages)EcoreParser.parseSubPackage(dObject,child,generated,'');/// *** specific end *** ///\nreturn generated;}static parseSubPackage(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DPackage.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.subpackages.push(dObject.id);dObject.name=this.read(json,ECoreNamed.namee,'subPackage_1');dObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.uri=this.read(json,ECoreSubPackage.nsURI,null);dObject.prefix=this.read(json,ECoreSubPackage.nsPrefix,null);const subPackages=this.getSubPackages(json);console.warn(\"parseSubPackage.children\",{childs,annotations,subPackages,dObject,generated});// if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\n// if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\nfor(let child of childs){switch(child[ECoreClass.xsitype]){default:Log.exx('unexpected xsitype:',child[ECoreClass.xsitype],' found in jsonfragment:',child,', in json:',json,' package:',dObject);break;case'ecore:EClass':this.parseDClass(dObject,child,generated,dObject.__fullname+\"/\");break;case'ecore:EEnum':this.parseDEnum(dObject,child,generated,dObject.__fullname+\"/\");break;}}for(let child of subPackages)EcoreParser.parseSubPackage(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific end *** ///\nreturn generated;}static parseDClass(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}let dObject=DClass.new(this.read(json,ECoreNamed.namee,'Concept 1'),undefined,undefined,undefined,undefined,undefined,parent.id);generated.push(dObject);// dObject.father = parent.id;\n//if (parent) parent.classifiers.push(dObject.id);\n//dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\ndObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\nfor(let key in json){switch(key){default:Log.exx('unexpected field in parseDClass() |'+key+'|',json);break;case ECoreClass.eAnnotations:case ECoreClass.instanceTypeName:case ECoreClass.eSuperTypes:case ECoreClass.xsitype:case ECoreClass.eOperations:case ECoreClass.eStructuralFeatures:case ECoreClass.abstract:case ECoreClass.interface:case ECoreClass.namee:break;}}dObject.instanceClassName=this.read(json,ECoreClass.instanceTypeName,'');dObject.interface=this.read(json,ECoreClass.interface,'false')==='true';dObject.abstract=this.read(json,ECoreClass.abstract,'false')==='true';let tmps=this.read(json,ECoreClass.eSuperTypes,'');dObject.extends=tmps.split(' ');const features=this.getChildren(json);const functions=this.getChildren(json,false,true);for(let child of functions)this.parseDOperation(dObject,child,generated,dObject.__fullname+\"/\");for(let child of features){const xsiType=this.read(child,ECoreAttribute.xsitype);switch(xsiType){default:Log.exx('unexpected xsi:type: ',xsiType,' in feature:',child);break;case'ecore:EAttribute':this.parseDAttribute(dObject,child,generated,dObject.__fullname+\"/\");break;case'ecore:EReference':this.parseDReference(dObject,child,generated,dObject.__fullname+\"/\");break;}}/// *** specific end *** ///\nreturn generated;}static parseDEnum(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DEnumerator.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.classifiers.push(dObject.id);dObject.name=this.read(json,ECoreNamed.namee,'Enum_1');dObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\nfor(let key in json){const value=json[key];switch(key){default:Log.exx('Enum.parse() unexpected key:',key,'in json:',json);break;case ECoreEnum.eAnnotations:case ECoreEnum.xsitype:case ECoreNamed.namee:break;case ECoreEnum.eLiterals:break;case ECoreEnum.serializable:dObject.serializable=value==='true';break;case ECoreEnum.instanceTypeName:dObject.instanceClassName=value+'';break;}}for(let child of childs){this.parseDEnumLiteral(dObject,child,generated,dObject.__fullname+\"/\");}/// *** specific end *** ///\nreturn generated;}static parseDEnumLiteral(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DEnumLiteral.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.literals.push(dObject.id);const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.value=+this.read(json,EcoreLiteral.value,Number.NEGATIVE_INFINITY);//vv4\ndObject.literal=this.read(json,EcoreLiteral.literal,'');dObject.name=this.read(json,ECoreNamed.namee,dObject.literal||'literal_1');dObject.__fullname=fullnamePrefix+dObject.name;/// *** specific end *** ///\nreturn generated;}static parseDAttribute(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);// done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\nlet dObject=DAttribute.new(this.read(json,ECoreNamed.namee,'attr_1'),this.read(json,ECoreAttribute.eType,AttribETypes.EString),parent.id);generated.push(dObject);// dObject.father = parent.id;\n// if (parent) parent.attributes.push(dObject.id);\n//dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\ndObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.lowerBound=+this.read(json,ECoreAttribute.lowerbound,0);dObject.upperBound=+this.read(json,ECoreAttribute.upperbound,1);//dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n/// *** specific end *** ///\nreturn generated;}static parseDReference(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DReference.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.references.push(dObject.id);dObject.name=this.read(json,ECorePackage.namee,'Ref_1');dObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.composition=U.fromBoolString(this.read(json,ECoreReference.containment,false),false);dObject.container=U.fromBoolString(this.read(json,ECoreReference.container,false),false);dObject.lowerBound=+this.read(json,ECoreAttribute.lowerbound,0);dObject.upperBound=+this.read(json,ECoreAttribute.upperbound,1);dObject.type=this.read(json,ECoreReference.eType,this.getEcoreTypeName(parent));/// *** specific end *** ///\nreturn generated;}static parseDParameter(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DParameter.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.parameters.push(dObject.id);dObject.name=this.read(json,ECoreNamed.namee,'arg1');dObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.lowerBound=+this.read(json,ECoreAttribute.lowerbound,0);dObject.upperBound=+this.read(json,ECoreAttribute.upperbound,1);dObject.type=this.read(json,ECoreAttribute.eType,AttribETypes.EString);dObject.ordered=U.fromBoolString(this.read(json,ECoreOperation.ordered,'false'),false);dObject.unique=U.fromBoolString(this.read(json,ECoreOperation.unique,'false'),false);/// *** specific end *** ///\nreturn generated;}static parseDOperation(parent,json,generated,fullnamePrefix){if(!generated)generated=[];if(!json){json={};}const childs=this.getChildren(json);let dObject=DOperation.new();generated.push(dObject);dObject.father=parent.id;if(parent)parent.operations.push(dObject.id);dObject.name=this.read(json,ECoreNamed.namee,'operation_1');dObject.__fullname=fullnamePrefix+dObject.name;const annotations=this.getAnnotations(json);for(let child of annotations)EcoreParser.parseDAnnotation(dObject,child,generated,dObject.__fullname+\"/\");/// *** specific start *** ///\ndObject.lowerBound=+this.read(json,ECoreAttribute.lowerbound,1);dObject.upperBound=+this.read(json,ECoreAttribute.upperbound,1);dObject.type=this.read(json,ECoreAttribute.eType,AttribETypes.EString);dObject.exceptions=[this.read(json,ECoreOperation.eexceptions,'')];dObject.ordered=U.fromBoolString(this.read(json,ECoreOperation.ordered,'false'));dObject.unique=U.fromBoolString(this.read(json,ECoreOperation.unique,'false'));dObject.visibility=AccessModifier.package;for(let child of childs){this.parseDParameter(dObject,child,generated,dObject.__fullname+\"/\");}/// *** specific end *** ///\nreturn generated;}/*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/ /////////////////////////////////// generic\nstatic getSubPackages(thiss){const ret=thiss[ECoreSubPackage.eSubpackages];if(!ret||U.isEmptyObject(ret)){return[];}if(Array.isArray(ret)){return ret;}else{return[ret];}}static getAnnotations(thiss){const ret=thiss[ECorePackage.eAnnotations];if(!ret||U.isEmptyObject(ret)){return[];}if(Array.isArray(ret)){return ret;}else{return[ret];}}static getDetails(thiss){const ret=thiss[ECoreAnnotation.details];if(!ret||U.isEmptyObject(ret)){return[];}if(Array.isArray(ret)){return ret;}else{return[ret];}}static getChildren(thiss){let throwError=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let functions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!thiss&&!throwError){return[];}const mod=thiss[ECoreRoot.ecoreEPackage];const pkg=thiss[ECorePackage.eClassifiers];const cla=thiss[functions?ECoreClass.eOperations:ECoreClass.eStructuralFeatures];const fun=thiss[ECoreOperation.eParameters];const lit=thiss[ECoreEnum.eLiterals];const ret=mod||pkg||cla||fun||lit;/*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/Log.ex(throwError&&!ret,'getChildren() Failed: ',thiss,ret);// console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\nif(!ret||U.isEmptyObject(ret)){return[];}if(Array.isArray(ret)){return ret;}else{return[ret];}}static read(json,field){let valueIfNotFound=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'read<T>()CanThrowError';let ret=json?json[field]:null;if(ret!==null&&ret!==undefined&&field.indexOf(this.XMLinlineMarker)!==-1){Log.ex(U.isObject(ret,false,false,true),'inline value |'+field+'| must be primitive.',ret);ret=U.multiReplaceAll(''+ret,['&amp;','&#38;','&quot;'],['&','\\'','\"']);}if(ret===null||ret===undefined){Log.ex(valueIfNotFound==='read<T>()CanThrowError','this.read<','> failed: field['+field+'], json: ',json);return valueIfNotFound;}return ret;}static write(json,field,val){if(val!==null&&field.indexOf(EcoreParser.XMLinlineMarker)!==-1){Log.ex(val!==''+val,'inline value |'+field+'| must be a string.',val);val=U.multiReplaceAll(val,['&','\\'','\"'],['&amp;','&#38;','&quot;']);}else Log.ex(val!==''+val||!U.isObject(val,true),'primitive values should be inserted only inline in the xml:',field,val);json[field]=val;return val;}static getEcoreTypeName(parent){if(parent.className===DEnumerator.cname||parent.className===DClass.cname)return this.classTypePrefix+this.name;// return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\nreturn Log.exx(\"getEcoreTypeName failed\",parent);}}EcoreParser.supportedEcoreVersions=[\"http://www.eclipse.org/emf/2002/Ecore\"];EcoreParser.prefix='@';EcoreParser.XMLinlineMarker='@';EcoreParser.classTypePrefix='#//';export let AccessModifier;(function(AccessModifier){AccessModifier[\"public\"]=\"public\";AccessModifier[\"private\"]=\"private\";AccessModifier[\"protected\"]=\"protected\";AccessModifier[\"internal\"]=\"internal\";AccessModifier[\"package\"]=\"package\";AccessModifier[\"protectedinternal\"]=\"protected internal\";AccessModifier[\"protectedprivate\"]=\"protected private\";})(AccessModifier||(AccessModifier={}));export class ECoreRoot{}ECoreRoot.ecoreEPackage=void 0;export class ECoreAnnotation{}ECoreAnnotation.source=void 0;ECoreAnnotation.references=void 0;ECoreAnnotation.details=void 0;export class ECoreNamed{}ECoreNamed.namee=void 0;export class ECoreDetail{}ECoreDetail.key=void 0;ECoreDetail.value=void 0;export class ECoreSubPackage{}ECoreSubPackage.eSubpackages=void 0;ECoreSubPackage.eAnnotations=void 0;ECoreSubPackage.eClassifiers=void 0;ECoreSubPackage.nsURI=void 0;ECoreSubPackage.nsPrefix=void 0;ECoreSubPackage.namee=void 0;export class ECorePackage extends ECoreSubPackage{}ECorePackage.eAnnotations=void 0;ECorePackage.eSubpackages=void 0;ECorePackage.eClassifiers=void 0;ECorePackage.xmlnsxmi=void 0;ECorePackage.xmlnsxsi=void 0;ECorePackage.xmiversion=void 0;ECorePackage.xmlnsecore=void 0;ECorePackage.nsURI=void 0;ECorePackage.nsPrefix=void 0;ECorePackage.namee=void 0;export class ECoreClass{}ECoreClass.eAnnotations=void 0;ECoreClass.eStructuralFeatures=void 0;ECoreClass.xsitype=void 0;ECoreClass.namee=void 0;ECoreClass.eOperations=void 0;ECoreClass.instanceTypeName=void 0;ECoreClass.eSuperTypes=void 0;ECoreClass.abstract=void 0;ECoreClass.interface=void 0;export class ECoreEnum{}ECoreEnum.eAnnotations=void 0;ECoreEnum.xsitype=void 0;ECoreEnum.namee=void 0;ECoreEnum.instanceTypeName=void 0;ECoreEnum.serializable=void 0;ECoreEnum.eLiterals=void 0;export class EcoreLiteral{}EcoreLiteral.eAnnotations=void 0;EcoreLiteral.namee=void 0;EcoreLiteral.value=void 0;EcoreLiteral.literal=void 0;export class ECoreReference{}ECoreReference.eAnnotations=void 0;ECoreReference.xsitype=void 0;ECoreReference.eType=void 0;ECoreReference.containment=void 0;ECoreReference.container=void 0;ECoreReference.upperbound=void 0;ECoreReference.lowerbound=void 0;ECoreReference.namee=void 0;export class ECoreAttribute{}ECoreAttribute.eAnnotations=void 0;ECoreAttribute.xsitype=void 0;ECoreAttribute.eType=void 0;ECoreAttribute.namee=void 0;ECoreAttribute.lowerbound=void 0;ECoreAttribute.upperbound=void 0;export class ECoreOperation{}ECoreOperation.eAnnotations=void 0;ECoreOperation.eType=void 0;ECoreOperation.eexceptions=void 0;ECoreOperation.upperBound=void 0;ECoreOperation.lowerBound=void 0;ECoreOperation.unique=void 0;ECoreOperation.ordered=void 0;ECoreOperation.namee=void 0;ECoreOperation.eParameters=void 0;export class ECoreParameter{}ECoreParameter.eAnnotations=void 0;ECoreParameter.namee=void 0;ECoreParameter.ordered=void 0;ECoreParameter.unique=void 0;ECoreParameter.lowerBound=void 0;ECoreParameter.upperBound=void 0;ECoreParameter.eType=void 0;export class ECoreObject{}ECoreObject.xmlns_xmi=void 0;ECoreObject.xmlns_uri=void 0;ECoreObject.xmi_version=void 0;export class XMIModel{}///////////////\nXMIModel.type=void 0;XMIModel.namee=void 0;ECoreRoot.ecoreEPackage='ecore:EPackage';// this is root tag but not in xml->json, just his attributes/childrens\nECoreNamed.namee=EcoreParser.XMLinlineMarker+'name';ECorePackage.eAnnotations=ECoreSubPackage.eAnnotations=ECoreClass.eAnnotations=ECoreEnum.eAnnotations=EcoreLiteral.eAnnotations=ECoreReference.eAnnotations=ECoreAttribute.eAnnotations=ECoreOperation.eAnnotations=ECoreParameter.eAnnotations='eAnnotations';ECoreAnnotation.source=EcoreParser.XMLinlineMarker+'source';ECoreAnnotation.references=EcoreParser.XMLinlineMarker+'references';// \"#/\" for target = package.\nECoreAnnotation.details='details';// arr\nECoreDetail.key=EcoreParser.XMLinlineMarker+'key';// can have spaces\nECoreDetail.value=EcoreParser.XMLinlineMarker+'value';ECorePackage.eSubpackages='eSubpackages';ECorePackage.eClassifiers='eClassifiers';ECorePackage.xmlnsxmi=EcoreParser.XMLinlineMarker+'xmlns:xmi';// typical value: http://www.omg.org/XMI\nECorePackage.xmlnsxsi=EcoreParser.XMLinlineMarker+'xmlns:xsi';// typical value: http://www.w3.org/2001/XMLSchema-instance\nECorePackage.xmiversion=EcoreParser.XMLinlineMarker+'xmi:version';// typical value: \"2.0\"\nECorePackage.xmlnsecore=EcoreParser.XMLinlineMarker+'xmlns:ecore';ECorePackage.nsURI=EcoreParser.XMLinlineMarker+'nsURI';// typical value: \"http://org/eclipse/example/modelname\"\nECorePackage.nsPrefix=EcoreParser.XMLinlineMarker+'nsPrefix';// typical value: org.eclipse.example.modelname\nECorePackage.namee=EcoreParser.XMLinlineMarker+'name';ECoreSubPackage.eSubpackages='eSubpackages';ECoreSubPackage.eClassifiers='eClassifiers';ECoreSubPackage.nsURI=EcoreParser.XMLinlineMarker+'nsURI';// typical value: \"http://org/eclipse/example/modelname\"\nECoreSubPackage.nsPrefix=EcoreParser.XMLinlineMarker+'nsPrefix';// typical value: org.eclipse.example.modelname\nECoreSubPackage.namee=EcoreParser.XMLinlineMarker+'name';ECoreClass.eStructuralFeatures='eStructuralFeatures';ECoreClass.eOperations='eOperations';ECoreClass.xsitype=EcoreParser.XMLinlineMarker+'xsi:type';// \"ecore:EClass\"\nECoreClass.namee=ECorePackage.namee;ECoreClass.eSuperTypes=EcoreParser.XMLinlineMarker+'eSuperTypes';// space separated: \"#name1 #name2\"...\nECoreClass.instanceTypeName=EcoreParser.XMLinlineMarker+'instanceTypeName';// raw str\nECoreClass.instanceTypeName=EcoreParser.XMLinlineMarker+'instanceTypeName';ECoreClass.abstract=EcoreParser.XMLinlineMarker+'abstract';// bool\nECoreClass.interface=EcoreParser.XMLinlineMarker+'interface';// bool\nECoreEnum.instanceTypeName=ECoreClass.instanceTypeName;ECoreEnum.serializable='serializable';// \"false\", \"true\"\nECoreEnum.xsitype=ECoreClass.xsitype;// \"ecore:EEnum\"\nECoreEnum.eLiterals='eLiterals';ECoreEnum.namee=ECorePackage.namee;EcoreLiteral.literal='literal';EcoreLiteral.namee=ECorePackage.namee;EcoreLiteral.value='value';// any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\nECoreReference.xsitype=EcoreParser.XMLinlineMarker+'xsi:type';// \"ecore:EReference\"\nECoreReference.eType=EcoreParser.XMLinlineMarker+'eType';// \"#//Player\"\nECoreReference.containment=EcoreParser.XMLinlineMarker+'containment';// \"true\"\nECoreReference.upperbound=EcoreParser.XMLinlineMarker+'upperBound';// \"@1\"\nECoreReference.lowerbound=EcoreParser.XMLinlineMarker+'lowerBound';// does even exists?\nECoreReference.namee=EcoreParser.XMLinlineMarker+'name';ECoreAttribute.xsitype=EcoreParser.XMLinlineMarker+'xsi:type';// \"ecore:EAttribute\",\nECoreAttribute.eType=EcoreParser.XMLinlineMarker+'eType';// \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\nECoreAttribute.namee=EcoreParser.XMLinlineMarker+'name';ECoreAttribute.lowerbound=EcoreParser.XMLinlineMarker+'lowerBound';ECoreAttribute.upperbound=EcoreParser.XMLinlineMarker+'upperBound';ECoreOperation.eParameters='eParameters';ECoreOperation.namee=EcoreParser.XMLinlineMarker+'name';// \"EExceptionNameCustom\",\nECoreOperation.ordered=EcoreParser.XMLinlineMarker+'ordered';// \"false\",\nECoreOperation.unique=EcoreParser.XMLinlineMarker+'unique';// \"false\",\nECoreOperation.lowerBound=EcoreParser.XMLinlineMarker+'lowerBound';// \"5\", ma che senso ha su una funzione?? è il return?\nECoreOperation.upperBound=EcoreParser.XMLinlineMarker+'upperBound';ECoreOperation.eType=EcoreParser.XMLinlineMarker+'eType';// \"#//Classname\",\nECoreOperation.eexceptions=EcoreParser.XMLinlineMarker+'eExceptions';// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\nECoreParameter.namee=EcoreParser.XMLinlineMarker+'name';ECoreParameter.ordered=EcoreParser.XMLinlineMarker+'ordered';// \"false\";\nECoreParameter.unique=EcoreParser.XMLinlineMarker+'unique';// \"false\"\nECoreParameter.lowerBound=EcoreParser.XMLinlineMarker+'lowerBound';// \"1\"\nECoreParameter.upperBound=EcoreParser.XMLinlineMarker+'upperBound';// \"2\"\nECoreParameter.eType=EcoreParser.XMLinlineMarker+'eType';// \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\nECoreObject.xmlns_xmi=EcoreParser.XMLinlineMarker+'xmlns:xmi';// \"http://www.omg.org/XMI\"\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\nECoreObject.xmi_version=EcoreParser.XMLinlineMarker+'xmi:version';// \"2.0\"\nXMIModel.type=EcoreParser.XMLinlineMarker+'type';XMIModel.namee=EcoreParser.XMLinlineMarker+'name';","map":{"version":3,"names":["Log","DModel","DValue","DObject","DEnumerator","DEnumLiteral","DAttribute","DReference","DClass","DParameter","DOperation","DPackage","DAnnotation","AttribETypes","U","Selectors","PointedBy","LPointerTargetable","windoww","SetRootFieldAction","Constructors","store","SetFieldAction","DPointerTargetable","ShortAttribETypes","toLongEType","ShortDefaultEClasses","toLongEClass","SavePack","constructor","model","arguments","length","undefined","vertexpos","view","IStorage","get","exx","prefix","autosave","del","key","isOverwrite","set","parse","serialize","val","JSON","stringify","e","deserialize","set0","get0","LocalStorage","localStorage","getItem","getLastOpened","modelNumber","modelname","ret","KeyList","lastOpenedModel","lastOpenedView","lastOpenedPosition","deleteLastOpened","setLastOpened","vertex","EcoreParser","ecorejson","isMetamodel","filename","persist","parsedjson","temp","substring","console","log","paused","parsedElements","parseM2Model","parseM1Model","warn","LinkAllNamesToIDs","fixNamingConflicts","fixObjectPointers","tmpparse","wrapAll","tempfix_untilopennewtabisdone","dobjects","filter","className","cname","values","lobjects","fromArr","m1pointermap","o","ecorePointer","v","isMirage","modified","newvalues","map","from","to","id","elem","new","idMap","nameMap","replacePrimitiveMap","d_Estring","getAllPrimitiveTypes","EString","state","getState","typeprefix","shortkey","EVoid","shortetype","longetype","dClassType","getPrimitiveType","exDev","getDefaultEcoreClass","ecorename","replaceRules","dobj","name","__fullname","w","old","shortname","replacekey","valtmp","isArray","Array","value","target","indexOf","ww","ex","extendedBy","push","DfromPtr","fromPointer","getLiteral","ordinal","_LPointerTargetable$f","_LPointerTargetable$f2","fromD","ordinals","__raw","dval","meta","instanceof","type","mapper","ee","l","ptrkey","list","pointedBy","Error","updateSuperClasses","todoGetPrimitiveTypenope","json","generated","ECoreNamed","namee","pos","dObject","parseRootPackage","parseM2Model_old","children","getChildren","annotations","getAnnotations","child","parseDAnnotation","_meta","allmodels","getAll","m","xmlns","XMLinlineMarker","ns","findns","outerloop","key0","val0","key1","_matchpkg$","allpkgs","matchpkg","d","uri","ECoreObject","xmi_version","xmlns_xmi","expected","namespacedclass","mmclass","getClassByNameSpace","roots_for_this_metaclass","rootjson","parseDObject","getobjectmetaclass","metaSuperClass","subclasses","subclasseshapes","sc","row","feat","lfeat","dfeat","findBestMatch","m2classes","parent","parentType","_meta2","_meta3","father","objects","metaname","metafeature","classmeta","parseDValue","jsonvalues","dValue","features","fullnamePrefix","read","ECoreAnnotation","details","references","source","childs","packages","version","supportedEcoreVersions","includes","subPackages","getSubPackages","ECorePackage","nsURI","nsPrefix","ECoreClass","xsitype","parseDClass","parseDEnum","parseSubPackage","subpackages","ECoreSubPackage","eAnnotations","instanceTypeName","eSuperTypes","eOperations","eStructuralFeatures","abstract","interface","instanceClassName","tmps","extends","split","functions","parseDOperation","xsiType","ECoreAttribute","parseDAttribute","parseDReference","classifiers","ECoreEnum","eLiterals","serializable","parseDEnumLiteral","literals","EcoreLiteral","Number","NEGATIVE_INFINITY","literal","eType","lowerBound","lowerbound","upperBound","upperbound","composition","fromBoolString","ECoreReference","containment","container","getEcoreTypeName","parseDParameter","parameters","ordered","ECoreOperation","unique","operations","exceptions","eexceptions","visibility","AccessModifier","package","thiss","eSubpackages","isEmptyObject","getDetails","throwError","mod","ECoreRoot","ecoreEPackage","pkg","eClassifiers","cla","fun","eParameters","lit","field","valueIfNotFound","isObject","multiReplaceAll","write","classTypePrefix","ECoreDetail","xmlnsxmi","xmlnsxsi","xmiversion","xmlnsecore","ECoreParameter","xmlns_uri","XMIModel"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/api/data.ts"],"sourcesContent":["import type {\r\n    Json,\r\n    Pointer,\r\n    GObject,\r\n    Dictionary,\r\n    DocString} from \"../joiner\";\r\nimport {\r\n    Log,\r\n    DModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DClassifier,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    DOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    AttribETypes,\r\n    U,\r\n    CreateElementAction,\r\n    Selectors,\r\n    PointedBy,\r\n    LPointerTargetable,\r\n    windoww,\r\n    SetRootFieldAction,\r\n    Constructors,\r\n    store,\r\n    SetFieldAction,\r\n    DPointerTargetable, ShortAttribETypes, toLongEType, DState, Debug\r\n} from \"../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toLongEClass} from \"../common/U\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n        console.log(\"root parse\", {ecorejson, parsedjson});\r\n        // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.paused = true;\r\n        let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n        console.warn(\"parse.result D\", parsedElements);\r\n        this.LinkAllNamesToIDs(parsedElements);\r\n        this.fixNamingConflicts(parsedElements);\r\n        Constructors.paused = false;\r\n        // if (persist) CreateElementAction.newBatch(parsedElements);\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\r\n        Constructors.persist(parsedElements);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.cname) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.cname) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.values.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            //let lv: LValue = LPointerTargetable.from(v);\r\n            v.values = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.cname) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[1];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n        let state: DState = store.getState();\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in ShortAttribETypes) {\r\n            if (shortkey === ShortAttribETypes.EVoid) continue;\r\n            let shortetype: ShortAttribETypes = (ShortAttribETypes as GObject)[shortkey];\r\n            let longetype: AttribETypes = toLongEType(shortetype);\r\n            let dClassType: DClassifier = Selectors.getPrimitiveType(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n            // the correct one\r\n            replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\r\n        }\r\n        for (let shortkey in ShortDefaultEClasses) {\r\n            let shortetype: ShortDefaultEClasses = (ShortDefaultEClasses as GObject)[shortkey];\r\n            let longetype: DefaultEClasses = toLongEClass(shortetype);\r\n            let dClassType: DClassifier = Selectors.getDefaultEcoreClass(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n\r\n            // the correct one\r\n            replacePrimitiveMap[longetype] = dClassType;\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\r\n            if (idMap[replacePrimitiveMap[ecorename].id]) continue;\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\", \"values\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            idMap[dobj.id] = dobj;\r\n            if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\r\n            let name = (dobj as GObject).__fullname;\r\n            delete (dobj as GObject).__fullname;\r\n            if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\r\n                // operation overload, in this case i create N separate operations, but all references will point to the last operation.\r\n                // empty on purpose, just avoid naming check\r\n            }\r\n                // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\r\n            // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\r\n            else Log.w(!!nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, new:dobj, old:nameMap[typeprefix + name], name, shortname: dobj.name, typeprefix});\r\n            nameMap[typeprefix + name] = dobj;\r\n            // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\r\n                        Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }\r\n                    /*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n                    // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fix from ordinals to Pointer<DEnumLiteral>\r\n        function DfromPtr<T extends DPointerTargetable>(id: Pointer<T>|null|undefined): T{ return !id ? undefined as any : (DPointerTargetable.fromPointer(id, state)); }\r\n        function getLiteral(id: Pointer<DEnumerator>, ordinal: number): DEnumLiteral { return LPointerTargetable.fromD(DfromPtr(id))?.ordinals[ordinal]?.__raw; }\r\n        for (let elem of parsedElements) {\r\n            if (elem.className !== DValue.cname) continue;\r\n            let dval: DValue = elem as DValue;\r\n            let meta: DAttribute | DReference = DfromPtr(dval.instanceof as Pointer<DAttribute|DReference>);\r\n            if (!meta) continue;\r\n            let type: DEnumerator = DfromPtr(meta.type) as DEnumerator;\r\n            if (!type || type.className !== DEnumLiteral.cname) continue;\r\n            let mapper = (v: unknown): Pointer<DEnumLiteral> => {\r\n                if (typeof v !== \"number\") { Log.ee(\"found non-numeric value in a literal value.\", v, dval); return v as any; }\r\n                let l = getLiteral(type.id, v);\r\n                return l ? l.id : v as any;\r\n            }\r\n            dval.values = dval.values.map( mapper );\r\n        }\r\n\r\n        // finally: set all pointedby\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[];\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = DfromPtr(value);\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        // const annotations: Json[] = this.getAnnotations(json); i set them on root package\r\n        // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific  *** ///\r\n        // let defPackage: DPackage = DPackage.new(json)\r\n        EcoreParser.parseRootPackage(dObject, json, generated);\r\n        return generated;\r\n    }\r\n\r\n    static parseM2Model_old(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const children = EcoreParser.getChildren(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", children, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of children) {\r\n            EcoreParser.parseRootPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : [metaSuperClass];\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.children) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).values.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    let values: any[];\r\n                    if (Array.isArray(val)) values = val;\r\n                    else if (val as unknown === undefined) values = [];\r\n                    else values = [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.cname) { dValue.values = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.values.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        return []; // todo\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        (dObject as any).name = this.read(json, ECoreNamed.namee, undefined);\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        (dObject as GObject).__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) { //todo\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {key, value, json}); break;\r\n                // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseRootPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'default');\r\n        // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\r\n        (dObject as GObject).__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        console.warn(\"parseRootPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, ''); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, ''); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseSubPackage(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.subpackages.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        console.warn(\"parseSubPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\r\n        // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new(\r\n            this.read(json, ECoreNamed.namee, 'Concept 1'),\r\n            undefined as any, undefined as any, undefined as any, undefined as any, undefined, parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        //if (parent) parent.classifiers.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.eAnnotations:\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildren(json);\r\n        const functions: Json[] = this.getChildren(json, false, true);\r\n\r\n        for (let child of functions) this.parseDOperation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.eAnnotations:\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);//vv4\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\r\n        let dObject: DAttribute = DAttribute.new(\r\n            this.read(json, ECoreNamed.namee, 'attr_1'),\r\n            this.read(json, ECoreAttribute.eType, AttribETypes.EString),\r\n            parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        // if (parent) parent.attributes.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.composition = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.container = U.fromBoolString(this.read(json, ECoreReference.container, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getSubPackages(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreSubPackage.eSubpackages];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildren(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildren() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.exx(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\n\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECoreSubPackage { // <eSubpackages\r\n    static eSubpackages: string;\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECorePackage extends ECoreSubPackage {\r\n    static eAnnotations: string;\r\n    static eSubpackages: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static container: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations =\r\n    ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =  ECoreReference.eAnnotations =\r\n        ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eSubpackages = 'eSubpackages';\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreSubPackage.eSubpackages = 'eSubpackages';\r\nECoreSubPackage.eClassifiers = 'eClassifiers';\r\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}