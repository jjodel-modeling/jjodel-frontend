{"ast":null,"code":"var _dec, _class, _dec2, _class3, _class4, _dec3, _class5, _dec4, _class6, _class7;\n// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\n// import {Mixin} from \"ts-mixer\";\n\nimport { JsType, LModelElement, LNamedElement, MyError, RuntimeAccessible, store, windoww } from \"../joiner\";\nimport Swal from \"sweetalert2\";\nimport Storage from '../data/storage';\nimport { compressToUTF16, decompressFromUTF16 } from \"async-lz-string\";\nimport util from \"util\";\nimport Convert from \"ansi-to-html\";\n// var Convert = require('ansi-to-html');\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\n\nconsole.warn('loading ts U log');\nexport let Color = (_dec = RuntimeAccessible('Color'), _dec(_class = class Color {\n  constructor(r, g, b) {\n    this.r = void 0;\n    this.g = void 0;\n    this.b = void 0;\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  static fromHex(hex) {\n    return undefined;\n  }\n  static fromHLS(_ref) {\n    let {\n      h,\n      l,\n      s\n    } = _ref;\n    return undefined;\n  }\n  getHex() {\n    return undefined;\n  }\n  mixWith(c) {}\n  getHLS() {\n    return undefined;\n  }\n  duplicate() {\n    return undefined;\n  }\n}) || _class);\nexport let U = (_dec2 = RuntimeAccessible('U'), _dec2(_class3 = (_class4 = class U {\n  static async decompressState(state) {\n    return await decompressFromUTF16(state);\n  }\n  static async compressedState() {\n    return await compressToUTF16(JSON.stringify(store.getState()));\n  }\n  static isOffline() {\n    return Storage.read('offline') === 'true';\n  }\n  static refresh() {\n    window.location.reload();\n  }\n  static inspect(object, showHidden, depth, color) {\n    var _object;\n    object = ((_object = object) === null || _object === void 0 ? void 0 : _object.__raw) || object;\n    if (Array.isArray(object)) object = object.map(o => (o === null || o === void 0 ? void 0 : o.__raw) || o);\n    return util.inspect(object, showHidden, depth, color);\n  }\n  static objectInspect(val) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let showHidden = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let ansiConvert = window.ansiConvert;\n    if (!ansiConvert) window.ansiconvert = ansiConvert = new Convert();\n    return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\n  }\n  static cropStr(msg) {\n    let atStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    let atEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let arr = msg.split('\\n');\n    if (atEnd + atStart < arr.length) {\n      //arr = arr.slice(0, 10) + arr.slice(10, 0);\n      arr.splice(atStart, arr.length - atStart - atEnd, '...');\n    }\n    return arr.join('\\n');\n  }\n  static extractByKey(dict, path) {\n    const keys = path.split('.');\n    const topic = keys[0];\n    const data = dict[topic];\n    const values = [];\n    if (!Array.isArray(data)) return undefined;\n    for (const d of data) {\n      let value = d;\n      for (const k of keys) if (value.hasOwnProperty(k)) value = value[k];\n      values.push(value);\n    }\n    return values;\n  }\n  static extractKeys(dict) {\n    const keys = [];\n    function traverse(obj, path) {\n      for (const key in obj) {\n        if (typeof obj[key] === 'object') traverse(obj[key], path ? `${path}.${key}` : key);else keys.push(path ? `${path}.${key}` : key);\n      }\n    }\n    for (const key in dict) {\n      traverse(dict[key][0], key);\n    }\n    return keys;\n  }\n\n  // damiano: eseguire una funzione costa in performance, anche se è brutto fare questi cast\n  static wrapper(obj) {\n    return obj;\n  }\n  // damiano: mi sa che c'era un metodo l.__serialize or something\n  static json(dElement) {\n    return JSON.parse(JSON.stringify(dElement.__raw));\n  }\n  static hexToPalette() {\n    for (var _len = arguments.length, hexs = new Array(_len), _key = 0; _key < _len; _key++) {\n      hexs[_key] = arguments[_key];\n    }\n    return {\n      type: \"color\",\n      value: hexs.map(hex => {\n        if (hex[0] === '#') hex = hex.substring(1);\n        let r,\n          g,\n          b,\n          a = 1;\n        if (hex.length === 4) {\n          a = Number.parseInt('0x' + hex[3] + hex[3]) / 255;\n          hex = hex.substring(0, 3);\n        }\n        if (hex.length === 7) {\n          a = Number.parseInt('0x' + hex[5] + hex[6]) / 255;\n          hex = hex.substring(0, 6);\n        }\n        Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {\n          hex,\n          a\n        });\n        let i = 0;\n        if (hex.length === 3) {\n          r = Number.parseInt('0x' + hex[i] + hex[i++]);\n          g = Number.parseInt('0x' + hex[i] + hex[i++]);\n          b = Number.parseInt('0x' + hex[i] + hex[i]);\n        } else {\n          r = Number.parseInt('0x' + hex[i++] + hex[i++]);\n          g = Number.parseInt('0x' + hex[i++] + hex[i++]);\n          b = Number.parseInt('0x' + hex[i++] + hex[i]);\n        }\n        return {\n          r,\n          g,\n          b,\n          a\n        };\n      })\n    };\n  }\n  static fatherChain(me) {\n    if (!me) return []; // without this line go through delete error\n    const fathers = [me.id];\n    const toCheck = [me];\n    while (toCheck.length > 0) {\n      const element = toCheck.pop();\n      if (element && element.father) {\n        fathers.push(element.father.id);\n        toCheck.push(element.father);\n      }\n    }\n    return fathers;\n  }\n\n  /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\n  static isShallowEqualWithProxies(obj1, obj2) {\n    let skipKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let out = arguments.length > 3 ? arguments[3] : undefined;\n    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n    let returnIfMaxDepth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let tobj1 = obj1 === null ? 'null' : typeof obj1;\n    let tobj2 = obj2 === null ? 'null' : typeof obj2;\n    if (obj1 === obj2) {\n      // if (out) { out.reason = \"identical objects\"; }\n      return true;\n    }\n    if (tobj1 !== tobj2) {\n      if (out) {\n        out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2;\n      }\n      return false;\n    }\n\n    // at this point: same type, but different values\n    switch (tobj1) {\n      default:\n        // primitive with different values\n        console.error(\"unexpected case in isshallowequal:\", {\n          tobj1,\n          obj1,\n          obj2\n        });\n        if (out) {\n          if (undefined === tobj1) out.reason = 'primitive value newly introduced';else if (undefined === tobj2) out.reason = 'primitive value got deleted';else out.reason = 'primitive value changedd';\n        }\n        return false;\n      case 'string':\n      case 'boolean':\n        // primitive with different values\n        if (out) {\n          if (undefined === tobj1) out.reason = 'primitive value newly introduced';else if (undefined === tobj2) out.reason = 'primitive value got deleted';else out.reason = 'primitive value changedd';\n        }\n        return false;\n      case \"number\":\n        // if both re nan it fails\n        // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\n        if (isNaN(obj1) && isNaN(obj2)) return true;\n        if (out) out.reason = 'number changed';\n        return false;\n      case \"function\":\n        if (obj1.toString() === obj2.toString()) break;\n        if (out) out.reason = 'function body changed';\n        return false;\n      case \"object\":\n        let o1Raw = obj1.__raw;\n        let o2Raw = obj2.__raw;\n        if (o1Raw) {\n          if (!o2Raw) {\n            if (out) out.reason = o1Raw.className + 'replaced by another object type:' + (o2Raw === null || o2Raw === void 0 ? void 0 : o2Raw.className);\n            return false;\n          }\n          obj1 = o1Raw;\n          obj2 = o2Raw;\n        }\n        // for proxies and DObjects\n        if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\n          if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter + ' != ' + obj2.clonedCounter;\n          return false;\n        } /*\r\n          if (obj1.className !== obj2.className) {\r\n          removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n          nd it's checked anyway in for(let key in obj1)\r\n             if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n             return false;\r\n          }*/\n        if (Array.isArray(obj1)) {\n          if (obj1.length !== obj2.length) {\n            if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\n            return false;\n          }\n          if (!Array.isArray(obj2)) {\n            if (out) out.reason = 'array became an object';\n            return false;\n          }\n        }\n        if (depth > maxDepth) {\n          // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\n          if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\n          return returnIfMaxDepth;\n        }\n        for (let key in obj1) {\n          if (key in skipKeys) continue;\n          let oldp = obj2[key];\n          let newp = obj1[key];\n          if (oldp === newp) continue;\n          if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth + 1, maxDepth, returnIfMaxDepth)) {\n            if (out) out.reason = '[' + key + ']' + out.reason;\n            return false;\n          }\n        }\n        // just check for keys that were in props and are not in nextProps\n        for (let key in obj2) {\n          if (key in skipKeys || key in obj1) continue;\n          if (out) out.reason = \"deleted subobject property: \" + key;\n          return false;\n        }\n      // else retIfMaxDepthReached; split the above if\n    }\n\n    return true;\n  }\n  static deepEqual(x, y) {\n    const tx = typeof x,\n      ty = typeof y;\n    return x && y && tx === 'object' && tx === ty ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key])) : x === y;\n  }\n  static sleep(s) {\n    return new Promise(resolve => setTimeout(resolve, s * 1000));\n  }\n  static getRandomString(length) {\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let randomString = '';\n    let index = 0;\n    while (index < length) {\n      const randomNumber = Math.floor(Math.random() * characters.length);\n      randomString += characters.charAt(randomNumber);\n      index += 1;\n    }\n    return randomString;\n  }\n  static alert(title, text) {\n    let color = 'text-';\n    switch (title.toLowerCase()) {\n      case 'error':\n        color += 'danger';\n        break;\n      default:\n        color += 'primary';\n    }\n    let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>';\n    html += `<div><b><label class='fs-5 mb-2 text-uppercase ${color}'>${title}</label></b><hr/>`;\n    html += `<label class='fs-6 mt-3'>${text}</label><br/>`;\n    const result = Swal.fire({\n      html: html,\n      backdrop: false,\n      showCloseButton: true,\n      showConfirmButton: false\n      //confirmButtonText: 'GOT IT'\n    });\n  }\n\n  static popup(element) {\n    let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>' + element;\n    const result = Swal.fire({\n      html: html,\n      backdrop: false,\n      showCloseButton: true,\n      showConfirmButton: false\n      //confirmButtonText: 'GOT IT'\n    });\n  }\n\n  static filteredPointedBy(data, label) {\n    const models = [];\n    for (let dict of data.pointedBy) {\n      const pointedBy = dict.source.split('.');\n      if (pointedBy.length === 3 && pointedBy[2] === label) {\n        models.push(LModelElement.fromPointer(pointedBy[1]));\n      }\n    }\n    return models;\n  }\n  static getFatherFieldToDelete(data) {\n    const father = data.father;\n    let field = '';\n    switch (father.className + '|' + data.className) {\n      // DPackage\n      case 'DModel|DPackage':\n        field = 'packages';\n        break;\n      case 'DPackage|DPackage':\n        field = 'subpackages';\n        break;\n      // DEnumerator and DClass\n      case 'DPackage|DEnumerator':\n      case 'DPackage|DClass':\n        field = 'classifiers';\n        break;\n      // DAttribute\n      case 'DClass|DAttribute':\n        field = 'attributes';\n        break;\n      // DReference\n      case 'DClass|DReference':\n        field = 'references';\n        break;\n      // DOperation\n      case 'DClass|DOperation':\n        field = 'operations';\n        break;\n      // DEnumLiteral\n      case 'DEnumerator|DEnumLiteral':\n        field = 'literals';\n        break;\n      // DObject\n      case 'DModel|DObject':\n        field = 'objects';\n        break;\n      // DParameter\n      case 'DOperation|DParameter':\n        field = 'parameters';\n        break;\n      // DValue\n      case 'DObject|DValue':\n        field = 'features';\n        break;\n      // Error\n      default:\n        return null;\n    }\n    return field;\n  }\n  static initializeValue(typeclassifier) {\n    // if(!classifier) return 'null';\n    const pointer = typeof typeclassifier === 'string' ? typeclassifier : typeclassifier === null || typeclassifier === void 0 ? void 0 : typeclassifier.id;\n    const me = LNamedElement.fromPointer(pointer);\n    switch (me === null || me === void 0 ? void 0 : me.name) {\n      default:\n      case 'EString':\n        return '';\n      case 'EChar':\n        return 'a';\n      case 'EInt':\n        return '0';\n      case 'ELong':\n        return '0';\n      case 'EShort':\n        return '0';\n      case 'Byte':\n        return '0';\n      case 'EFloat':\n        return '0';\n      case 'EDouble':\n        return '0';\n      case 'EBoolean':\n        return 'false';\n      case 'EDate':\n        return new Date().toJSON().slice(0, 10);\n    }\n    return 'null';\n  }\n  static orderChildrenByTimestamp(context) {\n    const children = context.proxyObject.children;\n    if (children && children.length > 0) {\n      let orderedChildren = new Map();\n      for (let child of children) {\n        let timestamp = child.id.slice(-13);\n        orderedChildren.set(+timestamp, child);\n      }\n      orderedChildren = new Map([...orderedChildren.entries()].sort());\n      return [...orderedChildren.values()];\n    } else return [];\n  }\n  static followPath(base, path) {\n    let patharr = path.split('.');\n    let base0 = base;\n    let ret = {};\n    ret.keys = patharr;\n    ret.chain = [base];\n    let lastObject = base;\n    for (let i = 0; i < patharr.length; i++) {\n      let path = ret.lastkey = patharr[i];\n      lastObject = base;\n      base = base[path];\n      ret.chain.push(base);\n      if (typeof base !== \"object\" || i + 1 === patharr.length) {\n        ret.failedRemainingPath = patharr.slice(i);\n        ret.lastval = base;\n        ret.lastObject = lastObject;\n        return ret;\n      }\n    }\n    throw new Error(\"followPath should never reach here\");\n    return ret;\n  }\n  static multiReplaceAllKV(a) {\n    let kv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const keys = [];\n    const vals = [];\n    let i;\n    for (i = 0; i < kv.length; i++) {\n      keys.push(kv[i][0]);\n      vals.push(kv[i][0]);\n    }\n    return U.multiReplaceAll(a, keys, vals);\n  }\n\n  // if replacement is empty, it will be filled with '';\n  // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\n  static multiReplaceAll(a) {\n    let searchText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\n    let i = -1;\n    while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\n    i = -1;\n    while (++i < searchText.length) {\n      a = U.replaceAll(a, searchText[i], replacement[i]);\n    }\n    return a;\n  }\n  static replaceAll(str, searchText, replacement) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let warn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    if (!str) {\n      return str;\n    }\n    return str.split(searchText).join(replacement || '');\n  }\n  static toFileName() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'nameless.txt';\n    if (!a) {\n      a = 'nameless.txt';\n    }\n    a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'], ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\n    return a;\n  }\n\n  // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\n  // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\n  // @ts-ignore\n  // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\n  static objectMergeInPlace(output) {\n    const out = output;\n    for (var _len2 = arguments.length, objarr = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      objarr[_key2 - 1] = arguments[_key2];\n    }\n    if (objarr) for (let o of objarr) {\n      if (o && typeof o === \"object\") for (let key in o) {\n        var _out$key;\n        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\n        (_out$key = out[key]) !== null && _out$key !== void 0 ? _out$key : out[key] = o[key];\n      }\n    }\n  }\n  static log(obj) {\n    let label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '###';\n    console.clear();\n    console.log(label, obj);\n  }\n  static removeEmptyObjectKeys(obj) {\n    for (let key of Object.keys(obj)) {\n      if (obj[key] === null || obj[key] === undefined) delete obj[key];\n    }\n  }\n\n  // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\n  // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\n  static objectMergeInPlace_conditional(output, condition) {\n    const out = output;\n    let i = 0;\n    for (var _len3 = arguments.length, objarr = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      objarr[_key3 - 2] = arguments[_key3];\n    }\n    for (let o of objarr) for (let key in o) {\n      if (condition(out, key, o, objarr, i++)) out[key] = o[key];\n    }\n    return out;\n  }\n  static buildFunctionDocumentation(f) {\n    Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\n    // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\n    let ret = {\n      parameters: [],\n      returns: undefined,\n      f: f,\n      fname: undefined,\n      isLambda: null,\n      signature: ''\n    };\n    let str = f.toString();\n    let starti = str.indexOf('(');\n    let endi;\n    let parcounter = 1;\n    for (endi = starti + 1; endi < str.length; endi++) {\n      if (str[endi] === ')' && --parcounter === 0) break;\n      if (str[endi] === '(') parcounter++;\n    }\n    let parameterStr = str.substring(starti + 1, endi);\n    // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\n    ret.fname = str.substr(0, starti).trim();\n    ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\n    // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\n    if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\n\n    let returnstarti = str.indexOf('/*', endi + 1);\n    let returnendi = -1;\n    let bodystarti = str.indexOf('{', endi + 1);\n    if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\n      // no return type or comment is past body\n      ret.returns = undefined;\n    } else {\n      returnendi = str.indexOf('*/', returnstarti + 2);\n      ret.returns = str.substring(returnstarti + 2, returnendi).trim();\n      bodystarti = str.indexOf('{', returnendi);\n    }\n    if (ret.returns === '') ret.returns = undefined;\n\n    // is lambda if do not have curly body or contains => between return comment and body\n    // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\n    ret.isLambda = bodystarti === -1 || str.substring(window.Math.max(endi, returnendi) + 1, bodystarti).trim() === '=>';\n    let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\n    let match;\n    while (match = regexp.exec(parameterStr + ',')) {\n      // match[0] is always the full match (not a capture group)\n      // match[2] can only be \"=\" or empty string\n      // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\n      let par = {\n        name: match[1],\n        defaultVal: match[3],\n        typedesc: match[4] && match[4].length > 1 ? match[4] : null\n      };\n      par.name = par.name.trim();\n      par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\n      par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\n      ret.parameters.push(par);\n    }\n    // set signature\n\n    ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\n    let i;\n    for (i = 0; i < ret.parameters.length; i++) {\n      let par = ret.parameters[i];\n      ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\n    }\n    ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\n    return ret;\n  }\n\n  // NB: need to use result.apply(context) to have a usable \"this\"\n  // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\n  //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\n  // rest values are declared with ellipsis in codestrParamNames\n  // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\n  // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\n  // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\n  static parseFunctionWithContextAndScope(codeStr0, context0, scope0, codestrParamNames) {\n    let protectShallowValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let doIdentifierValidation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    if (!codestrParamNames) codestrParamNames = [];\n    let codeStr = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\n    let scopeParams = '';\n    let scope;\n    let context;\n    if (protectShallowValues) {\n      if (scope0) {\n        //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\n        scope = {};\n        for (let k in scope0) scope[k] = scope0[k];\n      } else scope = undefined;\n      if (context0) {\n        // context = {...context0}; context.__proto__ = context0.__proto__;\n        context = {};\n        for (let k in context0) context[k] = context0[k];\n      } else context = undefined;\n    } else {\n      scope = scope0;\n      context = context0;\n    }\n    if (scope) {\n      let scopekeys = Object.keys(scope);\n      if (doIdentifierValidation) scopekeys.map(key => {\n        var _key4;\n        key = ((_key4 = key) === null || _key4 === void 0 ? void 0 : _key4.trim()) || '';\n        if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\n        return key;\n      }).filter(k => !!k);\n      scopeParams = '{' + scopekeys.join(',') + '}';\n    }\n    let innerFuncParams = codestrParamNames.join(',');\n    let _jevalfunc = undefined; // is set by eval\n    const evalmode = false;\n    console.log('parseFunctionWithContextAndScope', {\n      codeStr,\n      scope,\n      context,\n      params: {\n        scopeParams,\n        innerFuncParams\n      }\n    });\n    scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\n    if (evalmode) {\n      codeStr = \"_jevalfunc = function (\" + scopeParams + \") { return (\" + codeStr + \")(\" + innerFuncParams + \") }\";\n      eval(codeStr);\n    } else {\n      _jevalfunc = new Function(scopeParams, \" return (\" + codeStr + \")(\" + innerFuncParams + \")\");\n    }\n    console.log('parseFunctionWithContextAndScope', {\n      _jevalfunc,\n      params: {\n        scopeParams\n      }\n    });\n    if (context) return _jevalfunc.bind(context);else return _jevalfunc;\n  } /*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\n  static evalInContextAndScopeNew(codeStr, context0, injectScopeToo, protectShallowValues, doIdentifierValidation) {\n    return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\n  }\n\n  // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\n\n  // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\n  // can modify scope AND context\n  // warn: can access global scope (window)\n  // if the context (this) is missing it will take the scope as context.\n  // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\n  // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\n  // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\n  static evalInContextAndScope(codeStr, scope0, context0, protectShallowValues, doIdentifierValidation) {\n    // console.log('evalInContextAndScope', {codeStr, scope, context});\n    // scope per accedere a variabili direttamente \"x + y\"\n    // context per accedervi tramite this, possono essere impostati come diversi.\n    if (!scope0 && !context0) {\n      Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {\n        codeStr,\n        scope0,\n        context0\n      });\n    }\n\n    // scope.this = scope.this || context || scope; non funziona\n    // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\n    // eslint-disable-next-line no-restricted-syntax,no-with\n    // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\n    // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\n    let _ret = null;\n    let scope;\n    let context;\n    if (protectShallowValues) {\n      if (scope0) {\n        scope = {\n          ...scope0,\n          __proto__: scope0.__proto__\n        };\n        scope.__proto__ = scope0.__proto__;\n      } else scope = undefined;\n      if (context0) {\n        context = {\n          ...context0,\n          __proto__: context0.__proto__\n        };\n        context.__proto__ = context0.__proto__;\n      } else context = undefined;\n    } else {\n      scope = scope0;\n      context = context0;\n    }\n    Log.w(!!(!context && scope), \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" + \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" + \"Autofixed by assigning context = scope;\");\n    Log.eDev(!!(context && scope && context !== scope), \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" + \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\n    if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\n\n    /*\r\n    if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n    if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n    if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\n    //      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\n    let prefixDeclarations = \"\",\n      postfixDeclarations = '';\n    if (scope) {\n      if (U.isStrict) {\n        for (let key in scope) {\n          if (doIdentifierValidation) {\n            key = key.trim();\n            if (!key || !U.validIdentfierRegexp.test(key)) continue;\n          }\n          // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\n          prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\n          postfixDeclarations = \"\";\n        }\n      } else {\n        prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\n        postfixDeclarations = \" }\";\n      }\n    }\n    if (scope && context) {\n      if (typeof codeStr === \"function\") {\n        codeStr = codeStr.toString();\n      } // functions cannot change scope (with statement is deprecated)\n      context._eval = {\n        __codeStr: codeStr\n      }; // necessary to reach this._eval.codeStr inside the eval()\n      // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\n      _ret = new Function(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\n      delete context._eval;\n    } else if (!scope && context) {\n      if (typeof codeStr === \"function\") {\n        _ret = function () {\n          for (var _len4 = arguments.length, a = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n            a[_key5] = arguments[_key5];\n          }\n          return codeStr.call(context, ...a);\n        };\n        // _ret = (...a: any)=>codeStr.call(context, ...a);\n      } else {\n        // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\n        context._eval = {\n          __codeStr: codeStr\n        }; // necessary to reach this._eval.codeStr inside the eval()\n        _ret = new Function(\"return eval( this._eval.__codeStr );\").call(context);\n        delete context._eval;\n        // this below  is not good, as i need to quote the expanded result of codeStr,\n        // but since it might contain quotes as well i would need to escape them too.\n        // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\n      }\n    } else if (scope && !context) {\n      // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\n      // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\n      if (typeof codeStr === \"function\") {\n        codeStr = codeStr.toString();\n      } // functions cannot change scope (with statement is deprecated)\n      _ret = eval(prefixDeclarations + codeStr + postfixDeclarations);\n    }\n    return _ret;\n  }\n\n  //T extends ( ((...args: any[]) => any) | (() => any)\n  static execInContextAndScope(func, parameters, scope, context) {\n    Log.l(false, 'execInCtxScope', {\n      func,\n      parameters,\n      scope,\n      context\n    });\n    let ret;\n    const _eval = {\n      context,\n      scope,\n      func,\n      parameters: parameters || []\n    };\n    let prefixDeclarations = \"\",\n      postfixDeclarations = '';\n    if (scope) {\n      if (U.isStrict) {\n        for (let key in scope) {\n          // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\n          prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\n          postfixDeclarations = \"\";\n        }\n      } else {\n        prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\n        postfixDeclarations = \" }\";\n      }\n    }\n    if (!scope && !context) {\n      Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {\n        func,\n        scope,\n        context\n      });\n    }\n    if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\n    if (scope && context) {\n      context._eval = _eval;\n      // will the scope work with \"with\" outside the function body?\n      ret = new Function(prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\n      delete context._eval;\n    }\n    if (!scope && context) {\n      return _eval.func.apply(_eval.context, _eval.parameters);\n    }\n    if (scope && !context) {\n      // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\n      return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations);\n    }\n    return ret;\n  }\n\n  // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\n  // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\n  // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\n  // warn4: richiede un return per leggere il valore\n  // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\n  static execInScope_DO_NOT_USE(codeStr, scope) {\n    return new Function(...Object.keys(scope), codeStr)(...Object.values(scope));\n  }\n\n  // can modify context in-place, requires \"this\" before variable\n  static evalInContext(js, context) {\n    //# Return the results of the in-line anonymous function we .call with the passed context\n    return function () {\n      return eval(js);\n    }.call(context);\n  } /*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n       return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n     // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n    */\n  static highOrderFunctionExampleTyped(func) {\n    const funcName = func.cname || func.name;\n\n    // Return a new function that tracks how long the original took\n    return function () {\n      console.time(funcName);\n      const results = func(...arguments);\n      console.timeEnd(funcName);\n      return results;\n    };\n  }\n  static asClass(obj, classe) {\n    let elseReturn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return obj instanceof classe ? obj : elseReturn;\n  }\n  static asString(propKey) {\n    let elseReturn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return typeof propKey === 'string' ? propKey : elseReturn;\n  }\n  static isString(propKey) {\n    return typeof propKey === 'string';\n  }\n  static loadScript(path) {\n    let useEval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const script = document.createElement('script');\n    script.src = path;\n    script.type = 'text/javascript';\n    Log.eDev(useEval, 'loadScript', 'useEval', 'useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\n    document.body.append(script);\n  }\n  static ancestorArray(domelem, stopNode) {\n    let includeSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // [0]=element, [1]=father, [2]=grandfather... [n]=document\n    if (domelem === null || domelem === undefined) {\n      return [];\n    }\n    const arr = includeSelf ? [domelem] : [];\n    let tmp = domelem.parentNode;\n    while (tmp !== null && tmp !== stopNode) {\n      arr.push(tmp);\n      tmp = tmp.parentNode;\n    }\n    return arr;\n  }\n  static toHtml(html, container) {\n    let containerTag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'div';\n    if (!container) {\n      container = document.createElement(containerTag);\n    }\n    Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\n    container.innerHTML = html;\n    const ret = container.firstChild;\n    if (ret) container.removeChild(ret);\n    return ret;\n  }\n  static levenshtein(a, b) {\n    if (!a.length) return b.length;\n    if (!b.length) return a.length;\n    let cost = a.charAt(a.length - 1) === b.charAt(b.length - 1) ? 0 : 1;\n    return window.Math.min(U.levenshtein(a.substring(0, a.length - 1), b) + 1, U.levenshtein(a, b.substring(0, b.length - 1)) + 1, U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost);\n  }\n  static getClosestPropertyName(names, name) {\n    let lowest = Infinity;\n    return names.reduce(function (previous, current) {\n      let distance = U.levenshtein(current, name);\n      if (distance < lowest) {\n        lowest = distance;\n        return current;\n      }\n      return previous;\n    }, '');\n  }\n  static getClosestPropertyNames(names, name) {\n    let distances = names.map(value => {\n      return {\n        distance: U.levenshtein(value, name),\n        value\n      };\n    });\n    return distances.sort((a, b) => a.distance - b.distance).map(e => e.value);\n  }\n\n  //todo for console\n  static autoCorrectProxy(target, recursive, logger) {\n    return new Proxy(target, {\n      get: function (target, name) {\n        let namestr = U.asString(name, null);\n        if (!namestr) return undefined;\n        if (name in target) return target[namestr];\n        const suggestions = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\n        logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\n        return namestr && target[suggestions[0]];\n      }\n    });\n  }\n  static arrayRemoveAll(arr, elem) {\n    let debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let index;\n    if (!arr) return;\n    while (true) {\n      index = arr.indexOf(elem);\n      Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\n      if (index === -1) {\n        return;\n      }\n      arr.splice(index, 1);\n      Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\n    }\n  }\n  static arrayUnique(arr) {\n    return [...new Set(arr)];\n  }\n  static fileReadContent(file, callback) {\n    const textType = /text.*/;\n    try {\n      if (!file.type || file.type.match(textType)) {\n        let reader = new FileReader();\n        reader.onload = function (e) {\n          callback('' + reader.result);\n        };\n        reader.readAsText(file);\n        return;\n      }\n    } catch (e) {\n      Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file);\n    }\n    Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file);\n  }\n  static fileRead(onChange, extensions, readContent) {\n    // $(document).on('change', (e) => console.log(e));\n    console.log(\"importEcore: pre file reader\");\n    myFileReader.show(onChange, extensions, readContent);\n  }\n  static clear(htmlNode) {\n    if (htmlNode) while (htmlNode.firstChild) {\n      htmlNode.removeChild(htmlNode.firstChild);\n    }\n  }\n  static clearAllTimeouts() {\n    const highestTimeoutId = setTimeout(() => {}, 1);\n    for (let i = 0; i < highestTimeoutId; i++) {\n      clearTimeout(i);\n    }\n  }\n  static getStackTrace() {\n    let sliceCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    const ret = Error().stack;\n    // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\n    // if (Array.isArray(ret)) return ret;\n    if (!ret) return ['UnknownStackTrace'];\n    const arr = ret.split('\\n');\n    // first 2 entries are \"Erorr\" and \"getStackTrace()\"\n    return sliceCalls > 0 ? arr.slice(sliceCalls) : arr;\n  }\n\n  // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\n  static getCaller() {\n    let stacksToSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const stack = this.getStackTrace(4);\n    // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\n    return stack[stacksToSkip];\n  }\n  // todo: use in Log.once\n  // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\n  static isFirstTimeCalledByThisLine() {\n    let stacksToSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const caller = this.getCaller(stacksToSkip);\n    if (U.gotcalledby[caller]) return false;\n    return U.gotcalledby[caller] = true;\n  }\n  static lineKey() {\n    return this.getCaller(0);\n  }\n\n  // Prevent the backspace key from navigating back.\n  static preventBackSlashHistoryNavigation(event) {\n    if (!event || !event.key || event.key.toLowerCase() !== 'backspace') {\n      return true;\n    }\n    const types = ['text', 'password', 'file', 'search', 'email', 'number', 'date', 'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\n    const srcElement = $(event['srcElement'] || event.target);\n    const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\n    if (!disabled) {\n      if (srcElement[0].isContentEditable || srcElement.is('textarea')) {\n        return true;\n      }\n      if (srcElement.is('input')) {\n        const type = srcElement.attr('type');\n        if (!type || types.indexOf(type.toLowerCase()) > -1) {\n          return true;\n        }\n      }\n    }\n    event.preventDefault();\n    return false;\n  }\n  static SetMerge() {\n    let modifyFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    for (var _len5 = arguments.length, iterables = new Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {\n      iterables[_key6 - 1] = arguments[_key6];\n    }\n    const set = modifyFirst ? iterables[0] : new Set();\n    Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\n    for (let iterable of iterables) {\n      for (let item of iterable) {\n        set.add(item);\n      }\n    }\n    return set;\n  }\n\n  // merge with unique elements\n  static ArrayMergeU(arr1) {\n    for (var _len6 = arguments.length, arr2 = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {\n      arr2[_key7 - 1] = arguments[_key7];\n    }\n    U.ArrayMerge0(true, arr1, arr2);\n  }\n  // merge without unique check\n  static ArrayMerge(arr1) {\n    for (var _len7 = arguments.length, arr2 = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {\n      arr2[_key8 - 1] = arguments[_key8];\n    }\n    U.ArrayMerge0(false, arr1, arr2);\n  }\n  // implementation\n  static ArrayMerge0(unique, arrtarget) {\n    for (var _len8 = arguments.length, arrays = new Array(_len8 > 2 ? _len8 - 2 : 0), _key9 = 2; _key9 < _len8; _key9++) {\n      arrays[_key9 - 2] = arguments[_key9];\n    }\n    if (!arrtarget || !arrays) return;\n    if (unique) {\n      for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e);\n    } else {\n      for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri);\n    }\n  }\n  static ArrayAdd(arr, elem) {\n    let unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let throwIfContained = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\n    if (!unique) {\n      arr.push(elem);\n      return true;\n    }\n    if (arr.indexOf(elem) === -1) {\n      arr.push(elem);\n      return true;\n    }\n    Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\n    return false;\n  }\n\n  // static getID(): string { return U.idPrefix + U.maxID++; }\n\n  static getType(param) {\n    var _param$constructor;\n    switch (typeof param) {\n      default:\n        return typeof param;\n      case 'object':\n        return (param === null || param === void 0 ? void 0 : (_param$constructor = param.constructor) === null || _param$constructor === void 0 ? void 0 : _param$constructor.cname) || (param === null || param === void 0 ? void 0 : param.className) || \"{_rawobject_}\";\n      case 'function':\n        // and others\n        return \"geType for function todo: distinguish betweeen arrow and classic\";\n    }\n  }\n  static stringCompare(s1, s2) {\n    return s1 < s2 ? -1 : s1 > s2 ? 1 : 0;\n  }\n  static endsWith(str, suffix) {\n    if (Array.isArray(suffix)) {\n      for (let suf of suffix) {\n        if (U.endsWith(str, suf)) return true;\n      }\n      return false;\n    }\n    return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\n  }\n  static arrayMergeInPlace(arr1) {\n    for (var _len9 = arguments.length, otherArrs = new Array(_len9 > 1 ? _len9 - 1 : 0), _key10 = 1; _key10 < _len9; _key10++) {\n      otherArrs[_key10 - 1] = arguments[_key10];\n    }\n    for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\n    return arr1;\n  }\n  static getEndingNumber(s) {\n    let ignoreNonNumbers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowDecimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let i = s.length;\n    let numberEnd = -1;\n    while (--i > 0) {\n      if (!isNaN(+s[i])) {\n        if (numberEnd === -1) {\n          numberEnd = i;\n        }\n        continue;\n      }\n      if (s[i] === '.' && !allowDecimal) {\n        break;\n      }\n      if (s[i] === '.') {\n        allowDecimal = false;\n        continue;\n      }\n      if (!ignoreNonNumbers) {\n        break;\n      }\n      if (numberEnd !== -1) {\n        ignoreNonNumbers = false;\n      }\n    }\n    s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\n    return +parseFloat(s);\n  }\n  static increaseEndingNumber(s) {\n    let allowLastNonNumberChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowDecimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let increaseWhile = arguments.length > 3 ? arguments[3] : undefined;\n    let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\n    const matches = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\n    // S flag removed for browser support (firefox), should work anyway.\n    let prefix;\n    let num;\n    if (!matches) {\n      prefix = s;\n      num = 2;\n    } else {\n      Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\n      let i = s.length - matches[0].length;\n      prefix = s.substring(0, i);\n      num = 1 + +matches[1];\n    }\n    if (increaseWhile) while (increaseWhile(prefix + num)) {\n      num++;\n    }\n    return prefix + num;\n  }\n  static shallowEqual(objA, objB) {\n    if (objA === objB) {\n      return true;\n    }\n    if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') {\n      return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n\n    // if (keysA.length !== keysB.length) { return false; }\n    // Test for A's keys different from B.\n    // var bHasOwnProperty = hasOwnProperty.bind(objB);\n    for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\n\n    // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\n    return true;\n  }\n\n  // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\n  static isNumber(o) {\n    return typeof o === \"number\" && !isNaN(o);\n  }\n  static getAllPrototypes(constructor) {\n    var _constructor$prototyp, _constructor$__proto_;\n    let chainoutoutrecursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let currentRecursion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let maxRecursion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n    let cache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\n    if (cache && constructor.__allprototypes) return constructor.__allprototypes;\n    let prototype = ((_constructor$prototyp = constructor.prototype) === null || _constructor$prototyp === void 0 ? void 0 : _constructor$prototyp.name) && constructor.prototype;\n    let __proto__ = ((_constructor$__proto_ = constructor.__proto__) === null || _constructor$__proto_ === void 0 ? void 0 : _constructor$__proto_.name) && constructor.__proto__;\n    if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\n    if (prototype) chainoutoutrecursive.push(prototype);\n    if (__proto__) chainoutoutrecursive.push(__proto__);\n    if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\n    if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\n    if (cache) constructor.__allprototypes = chainoutoutrecursive;\n    return chainoutoutrecursive;\n  }\n  static classIsExtending(subconstructor, superconstructor) {\n    var _extends;\n    return (superconstructor === null || superconstructor === void 0 ? void 0 : (_extends = superconstructor._extends) === null || _extends === void 0 ? void 0 : _extends.includes(subconstructor)) || false;\n    // return U.getAllPrototypes(subconstructor).includes(superconstructor);\n  }\n\n  static isObject(v) {\n    let returnIfNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let returnIfUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let retIfArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (v === null) {\n      return returnIfNull;\n    }\n    if (v === undefined) {\n      return returnIfUndefined;\n    }\n    if (Array.isArray(v)) {\n      return retIfArray;\n    }\n    // nb: mind that typeof [] === 'object'\n    return typeof v === 'object';\n  }\n  static objectFromArray(arr, getKey) {\n    // @ts-ignore\n    return arr.reduce((acc, val) => {\n      acc[getKey(val)] = val;\n      return acc;\n    }, {});\n  }\n  static objectFromArrayValues(arr) {\n    let val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // @ts-ignore\n    return arr.reduce((acc, val) => {\n      acc[val] = val;\n      return acc;\n    }, {});\n    /*let ret: Dictionary = {};\r\n    for (let val of arr) { ret[val] = true; }\r\n    return ret;*/\n  }\n\n  static toBoolString(bool) {\n    let ifNotBoolean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return bool === true ? 'true' : bool === false ? 'false' : '' + ifNotBoolean;\n  }\n  static fromBoolString(str) {\n    let defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let allowUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    str = ('' + str).toLowerCase();\n    if (allowNull && str === 'null') return null;\n    if (allowUndefined && str === 'undefined') return undefined;\n    if (str === \"true\" || str === 't' || str === '1') return true;\n    // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\n    if (str === \"false\" || str === 'f' || str === '0') return false;\n    return defaultVal;\n  }\n  static arrayDifference(starting, final) {\n    let ret = {};\n    ret.starting = starting;\n    ret.final = final;\n    if (!starting) starting = [];\n    if (!final) final = [];\n    ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\n    ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\n    return ret;\n  }\n\n  // returns <\"what changed from old to neww\"> and in nested objects recursively\n  // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\n  // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\n  static objectDelta(old, neww) {\n    let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let newwobj = neww;\n    let oldobj = old;\n    if (old === neww) return {};\n    let diff = U.objdiff(old, neww); // todo: optimize this, remove the 3 loops below and add those directly in U.objdiff(old, neww, ret); writing inside the obj in third parameter\n\n    let ret = {}; // {__isAdelta:true};\n    for (let key in diff.added) {\n      ret[key] = newwobj[key];\n    }\n    for (let key in diff.changed) {\n      let subold = oldobj[key];\n      let subnew = newwobj[key];\n      if (typeof subold === typeof subnew && typeof subold === \"object\") {\n        ret[key] = deep ? U.objectDelta(subold, subnew, true) : subnew;\n      } else ret[key] = subnew;\n    }\n    // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\n    let removedprefix = \"\"; // \"_-\";\n    for (let key in diff.removed) {\n      ret[removedprefix + key] = undefined;\n    } //newwobj[key]; }\n    // console.log(\"objdiff\", {old, neww, diff, ret});\n    return ret;\n  }\n\n  // difference react-style. lazy check by === equality field by field. parameters are readonly\n  static objdiff(old, neww) {\n    // let ret: GObject = {removed:{}, added:{}, changed:{}};\n    let ret = {\n      removed: {},\n      added: {},\n      changed: {},\n      unchanged: {}\n    };\n    if (!neww && !old) {\n      return ret;\n    }\n    if (!neww) {\n      ret.removed = old;\n      return ret;\n    }\n    if (!old) {\n      ret.added = neww;\n      return ret;\n    }\n    // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\n\n    let key;\n    for (key in old) {\n      // if (neww[key] === undefined){\n      // if neww have a key with undefined value, it counts (and should) as having that property key defined\n      if (!(key in neww)) {\n        ret.removed[key] = old[key];\n      } else if (neww[key] === old[key]) {\n        ret.unchanged[key] = old[key];\n      } else ret.changed[key] = old[key];\n    }\n    for (let key in neww) {\n      if (!(key in old)) {\n        ret.added[key] = neww[key];\n      }\n    }\n    return ret;\n  }\n  /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\n  static flattenObjectToRoot(obj) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let pathseparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    return Object.keys(obj).reduce((acc, k) => {\n      const pre = prefix.length ? prefix + pathseparator : '';\n      if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));else acc[pre + k] = obj[k];\n      return acc;\n    }, {});\n  }\n\n  // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\n  // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\n  // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\n  static ObjectToAssignementStrings(obj) {\n    let maxkeylength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    let maxsubpaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;\n    let maxvallength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n    let toolongreplacer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"…\";\n    let out = arguments.length > 5 ? arguments[5] : undefined;\n    let quotestrings = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n    const pathseparator = \".\";\n    const valueseparator = \" = \";\n    const filterrow = rowpaths => {\n      return !rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\");\n    };\n    let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\n    let i = -1;\n    let tmp;\n    let ret = [];\n    tmp = (maxkeylength - toolongreplacer.length) / 2;\n    let halfpath = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    tmp = (maxvallength - toolongreplacer.length) / 2;\n    let halfval = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    tmp = (maxsubpaths - toolongreplacer.length) / 2;\n    let halfsubpaths = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    let bestpathsize = 0;\n    let best = null;\n    let countsize = (total, arrelem) => total + arrelem.length;\n    const filterbest = row => {\n      row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\n      if (!best || bestpathsize < row.pathlength && filterrow(row.fullpath)) {\n        best = row;\n        bestpathsize = row.pathlength;\n        if (out) out.best = best;\n        ret.best = best.str;\n      }\n    };\n    console.log(\"u get assignements\", {\n      flatten,\n      obj\n    });\n    for (let key in flatten) {\n      let row = {\n        fullpath: key.split(pathseparator),\n        fullstr: key\n      };\n      // if (!filterrow(row.fullpath)) continue;\n      // stringify(undefined) = undefined, so i add + \"\"\n      try {\n        if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\n      } catch (e) {\n        row.fullvalue = \"⁜not serializable⁜\";\n      }\n      // console.log(\"U get assignements loop\", {row, key, flatten, obj});\n      row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\n      if (row.fullpath.length > maxsubpaths) {\n        row.path = [...row.fullpath];\n        row.path.splice(halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\n      } else row.path = row.fullpath;\n\n      // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\n      row.path = row.path.map(p => p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end));\n      if (out) {\n        out.push(row);\n      }\n      row.str = row.path.join(pathseparator) + valueseparator + row.val;\n      ret.push(row.str);\n      filterbest(row);\n    }\n    return ret;\n  }\n  static download() {\n    let filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'nameless.txt';\n    let text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!text) {\n      return;\n    }\n    filename = U.toFileName(filename);\n    const htmla = document.createElement('a');\n    const blob = new Blob([text], {\n      type: 'text/plain',\n      endings: 'native'\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    Log.l(debug, text + '|\\r\\n| <-- rn, |\\n| <--n.');\n    htmla.style.display = 'none';\n    htmla.href = blobUrl;\n    htmla.download = filename;\n    document.body.appendChild(htmla);\n    htmla.click();\n    window.URL.revokeObjectURL(blobUrl);\n    document.body.removeChild(htmla);\n  }\n  static formatXml(xml) {\n    const reg = /(>)\\s*(<)(\\/*)/g;\n    const wsexp = / *(.*) +\\n/g;\n    const contexp = /(<.+>)(.+\\n)/g;\n    xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\n    const pad = '' || '\\t';\n    let formatted = '';\n    const lines = xml.split('\\n');\n    let indent = 0;\n    let lastType = 'other';\n    // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\n    const transitions = {\n      'single->single': 0,\n      'single->closing': -1,\n      'single->opening': 0,\n      'single->other': 0,\n      'closing->single': 0,\n      'closing->closing': -1,\n      'closing->opening': 0,\n      'closing->other': 0,\n      'opening->single': 1,\n      'opening->closing': 0,\n      'opening->opening': 1,\n      'opening->other': 1,\n      'other->single': 0,\n      'other->closing': -1,\n      'other->opening': 0,\n      'other->other': 0\n    };\n    let i = 0;\n    for (i = 0; i < lines.length; i++) {\n      const ln = lines[i];\n\n      // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\n      if (ln.match(/\\s*<\\?xml/)) {\n        formatted += ln + '\\n';\n        continue;\n      }\n      // ---\n\n      const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\n      const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\n      const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\n      const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\n      const fromTo = lastType + '->' + type;\n      lastType = type;\n      let padding = '';\n      indent += transitions[fromTo];\n      let j;\n      for (j = 0; j < indent; j++) {\n        padding += pad;\n      }\n      if (fromTo === 'opening->closing') {\n        formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\n      } else {\n        formatted += padding + ln + '\\n';\n      }\n    }\n    return formatted.trim();\n  }\n\n  // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\n  static circularStringify(obj, replacer, space) {\n    let maxDepth_unsupported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    const cache = [];\n    return JSON.stringify(obj, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        // Duplicate reference found, discard key\n        if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\n        if (replacer) {\n          value = replacer(key, value);\n          if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\n        }\n        // Store value in our collection\n        cache.push(value);\n      }\n      return value;\n    }, space);\n  }\n  static getFirstNumber(s) {\n    let allowDecimalDot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allowDecimalComma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let valueifmismatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let commamode = allowDecimalComma ? allowDecimalDot ? \"(\\\\.|\\\\,)\" : \"\\\\,\" : allowDecimalDot ? \"\\\\.\" : \"will not use this regex\";\n    let floatregex = new RegExp(\"-?\" + commamode + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\n    let intregex = /-?\\d+/;\n    let ret;\n    if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);else ret = intregex.exec(s);\n    ret = ret && ret[0]; // first match\n    if (ret === null) return valueifmismatch;\n    let tmpindex;\n    if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\n    // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\n    while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex + 1); // ret.indexOf(.)\n    // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\n    return +ret;\n  }\n\n  // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\n  static isEmptyObject(obj) {\n    for (var i in obj) return false;\n    return true;\n  }\n  static pairArrayElementsRepeatFunc(val, index, arr) {\n    return [arr[index], arr[index + 1]];\n  }\n  static pairArrayElementsReducerFunc(accumulator, value, index, array) {\n    if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\n    return accumulator;\n  }\n\n  // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\n  // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\n  static pairArrayElements(arr) {\n    let withRepetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (withRepetitions) {\n      return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length - 1);\n    }\n    return arr.reduce(U.pairArrayElementsReducerFunc, []);\n  }\n\n  // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\n  static decomment_all(str) {\n    return this.decomment_line(this.decomment_block(str));\n  }\n  // removes line comments //\n  static decomment_line(str) {\n    let trimLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return str.split(\"\\n\").map(s => {\n      let i = s.indexOf(\"//\");\n      s = i === -1 ? s : s.substring(i);\n      return trimLines ? s.trim() : s;\n    }).join(\"\\n\");\n  }\n  // removes block comments /**/\n  static decomment_block(str) {\n    // let maxcomments = 100;\n    while (true) {\n      // if (--maxcomments===0) break;\n      let s = str.indexOf(\"/*\");\n      if (s === -1) break;\n      let e = str.indexOf(\"*/\", s + 1);\n      if (e === -1) e = str.length;\n      str = str.substring(0, s) + str.substring(e + 2);\n    }\n    return str;\n  }\n  static uppercaseFirstLetter(str) {\n    if (typeof str !== \"string\") return str;\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  // CAREFUL! it's imperfect.\n  // Does not handle strings starting with ( that are not ()=> arrow functions\n  // or codes whose last chars are () but not in (function)() form\n  static wrapUserFunction(str) {\n    str = str.trim();\n    if (str[0] !== '(' || str.indexOf(\"function\") !== 0) {\n      str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\n    }\n\n    if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\n    return str;\n  }\n\n  // adds ellipsis in the middle of a string to truncate it when it's too long.\n  static stringMiddleCut(str, maxLength) {\n    let ellipsisChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '…';\n    let asArray = arguments.length > 3 ? arguments[3] : undefined;\n    if (!str || maxLength < 0 || str.length <= maxLength) return asArray ? [str] : str;\n    var midpoint = Math.ceil(str.length / 2);\n    var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\n    var lstrip = Math.ceil(toremove / 2); // left strip is the bigger one if odd chars\n    var rstrip = toremove - lstrip;\n    if (asArray) return [str.substring(0, midpoint - lstrip), ellipsisChar, str.substring(midpoint + rstrip)];else return str.substring(0, midpoint - lstrip) + ellipsisChar + str.substring(midpoint + rstrip);\n  }\n\n  // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\n  static invertHex(s) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';\n    let transformGrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\n    let r, g, b, h; // might be NaN if parseInt fails\n    if (s.length === 3 || s.length === 4) {\n      r = parseInt('0x' + s[0]); // works with hex numbers\n      g = parseInt('0x' + s[1]);\n      b = parseInt('0x' + s[2]);\n      h = s.length === 4 ? parseInt('0x' + s[4]) : undefined;\n    } else if (s.length === 6 || s.length === 8) {\n      r = parseInt('0x' + s.substring(0, 2));\n      g = parseInt('0x' + s.substring(2, 4));\n      b = parseInt('0x' + s.substring(4, 6));\n      h = s.length === 8 ? parseInt('0x' + s.substring(6, 8)) : undefined;\n    } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {\n      s\n    });\n    if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s + \", invalid red\", {\n      s\n    });\n    if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s + \", invalid green\", {\n      g\n    });\n    if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s + \", invalid blue\", {\n      b\n    });\n    transformGrays = transformGrays * 128;\n    r = Math.abs(r - 128) <= transformGrays ? r >= 128 ? 0 : 255 : 255 - r;\n    g = Math.abs(g - 128) <= transformGrays ? g >= 128 ? 0 : 255 : 255 - g;\n    b = Math.abs(b - 128) <= transformGrays ? b >= 128 ? 0 : 255 : 255 - b;\n    if (h || h === 0) h = 255 - h;\n    let rs = r.toString(16);\n    if (rs.length === 1) rs = '0' + rs;\n    let gs = g.toString(16);\n    if (gs.length === 1) gs = '0' + gs;\n    let bs = b.toString(16);\n    if (bs.length === 1) bs = '0' + bs;\n    let hs = h ? h.toString(16) : '';\n    if (hs.length === 1) hs = '0' + hs;\n    return prefix + rs + gs + bs + hs;\n  }\n  static parentUntil(tagName, p) {\n    while (p && p.tagName !== tagName) p = p.parentElement;\n    return p;\n  }\n  static paletteSplit(palette) {\n    let ret = {\n      color: {},\n      number: {},\n      text: {},\n      path: {}\n    };\n    for (let entry of Object.entries(palette)) {\n      let k = entry[0];\n      let v = entry[1];\n      ret[v.type][k] = v;\n    }\n    return ret;\n  }\n  static mergeNamedArray(ret, classes) {\n    for (let key of Object.getOwnPropertyNames(classes)) {\n      // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\n      if (key === \"length\") continue;\n      if (!isNaN(+key)) ret.push(classes[key]);\n      // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\n      if (!ret[key]) ret[key] = classes[key];\n    }\n  }\n  static async clipboardCopy(text, onSuccess, onFailure) {\n    let ret = false;\n    return navigator.clipboard.writeText(text).then(() => {\n      ret = true;\n      return onSuccess();\n    }, () => {\n      ret = U.clipboardCopy_old(text);\n      return ret ? onSuccess() : onFailure();\n    });\n  }\n  static clipboardCopy_old(text) {\n    try {\n      if (!U.clipboardinput) {\n        U.clipboardinput = document.createElement('input');\n        U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\n        U.clipboardinput.type = 'text';\n        U.clipboardinput.style.display = 'block';\n        U.clipboardinput.style.position = 'absolute';\n        U.clipboardinput.style.top = '-100vh';\n      }\n      document.body.appendChild(U.clipboardinput);\n      U.clipboardinput.value = text;\n      U.clipboardinput.select();\n      if (!document.execCommand) return false;\n      let ret = document.execCommand('copy');\n      document.body.removeChild(U.clipboardinput);\n      U.clearSelection();\n      return ret;\n    } catch (e) {\n      return false;\n    }\n  }\n  static clearSelection() {}\n  static toNamedArray(larr, darr) {\n    if (!darr || darr.length !== larr.length) darr = larr.map(l => l.__raw);\n    for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) larr[\"$\" + darr[i].name] = larr[i];\n    /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n        if (index === \"length\") continue;\r\n        let d = darr[index as any as number];\r\n        let l = larr[index as any as number];\r\n        if (!d || !l) continue;\r\n        (larr as any)[\"$\" + (d as any).name] = l;\r\n    }*/\n    return larr;\n  }\n}, _class4.isStrict = function () {\n  return !this;\n}(), _class4.validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/, _class4.gotcalledby = {}, _class4.maxID = 0, _class4.idPrefix = '', _class4.getID = function* idgenerator() {\n  let i = 0;\n  while (true) yield i++;\n}(), _class4.prefix = 'ULibrary_', _class4.clipboardinput = void 0, _class4)) || _class3);\nexport class DDate {\n  static addDay(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setDate(date.getDate() + offset);\n    return ret;\n  }\n  static addMonth(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setMonth(date.getMonth() + offset);\n    return ret;\n  }\n  static addYear(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setFullYear(date.getFullYear() + offset);\n    return ret;\n  }\n}\nDDate.cname = \"DDate\";\nexport class myFileReader {\n  // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\n  static setinfos(fileTypes, onchange, readcontent) {\n    myFileReader.fileTypes = fileTypes || myFileReader.fileTypes;\n    const debug = false;\n    debug && console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\n    myFileReader.input = document.createElement('input');\n    const input = myFileReader.input;\n    myFileReader.onchange = function (e) {\n      if (!readcontent) {\n        onchange(e, input.files, undefined);\n        return;\n      }\n      let contentObj = {};\n      let fileLetti = 0;\n      for (let i = 0; input.files && i < input.files.length; i++) {\n        const f = input.files[i];\n        debug && console.log('filereadContent[' + i + ']( file:', f, ')');\n        U.fileReadContent(f, content => {\n          var _input$files;\n          debug && console.log('file[' + i + '] read complete. done: ' + (1 + fileLetti) + ' / ' + ((_input$files = input.files) === null || _input$files === void 0 ? void 0 : _input$files.length), 'contentObj:', contentObj);\n          contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\n          // this is last file to read.\n          if (input.files && ++fileLetti === input.files.length) {\n            const contentArr = [];\n            for (let j = 0; j < input.files.length; j++) {\n              contentArr.push(contentObj[j]);\n            }\n            onchange(e, input.files, contentArr);\n          }\n        });\n      }\n    } || myFileReader.onchange;\n  }\n  static reset() {\n    myFileReader.fileTypes = undefined;\n    myFileReader.onchange = undefined;\n    myFileReader.input = undefined;\n  }\n  static show(onChange) {\n    let extensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let readContent = arguments.length > 2 ? arguments[2] : undefined;\n    console.log(\"importEcore: pre file reader\", myFileReader.input);\n    myFileReader.setinfos(extensions, onChange, readContent);\n    //if (!myFileReader.input) return;\n    myFileReader.input.setAttribute('type', 'file');\n    if (myFileReader.fileTypes) {\n      myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\n    }\n    //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\n    $(myFileReader.input).on('change.custom', myFileReader.onchange).trigger('click');\n    myFileReader.reset();\n  }\n}\nmyFileReader.input = null;\nmyFileReader.fileTypes = null;\nmyFileReader.onchange = null;\nexport let Uarr = (_dec3 = RuntimeAccessible('Uarr'), _dec3(_class5 = class Uarr {\n  static arrayIntersection(arr1, arr2) {\n    if (!arr1 || !arr2) return null;\n    return arr1.filter(e => arr2.indexOf(e) >= 0);\n  }\n  static arraySubtract(arr1, arr2, inPlace) {\n    let i;\n    const ret = inPlace ? arr1 : [...arr1];\n    for (i = 0; i < arr2.length; i++) {\n      U.arrayRemoveAll(ret, arr2[i]);\n    }\n    return ret;\n  }\n  static equals(a1, a2, deep) {\n    Log.ex(deep, \"deep array comparison is not supported yet\");\n    if (!a1 || !a2) return false;\n    if (a1.length !== a2.length) return false;\n    for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\n    return true;\n  }\n}) || _class5);\nexport class FocusHistoryEntry {\n  constructor(e, element, time) {\n    this.time = void 0;\n    this.evt = void 0;\n    this.element = void 0;\n    this.evt = e;\n    this.element = element || e.target;\n    this.time = time || new Date();\n  }\n}\nFocusHistoryEntry.cname = \"FocusHistoryEntry\";\nexport let ShortDefaultEClasses;\n(function (ShortDefaultEClasses) {\n  ShortDefaultEClasses[\"EObject\"] = \"EObject\";\n  ShortDefaultEClasses[\"EAnnotation\"] = \"EAnnotation\";\n  ShortDefaultEClasses[\"EClass\"] = \"EClass\";\n  ShortDefaultEClasses[\"EPackage\"] = \"EPackage\";\n  ShortDefaultEClasses[\"ENamedElement\"] = \"ENamedElement\";\n})(ShortDefaultEClasses || (ShortDefaultEClasses = {}));\nexport let ShortAttribETypes; // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\n/*\r\nECharObj  = 'ECharObj',\r\nEStringObj  = 'EStringObj',\r\nEDateObj  = 'EDateObj',\r\nEFloatObj  = 'EFloatObj',\r\nEDoubleObj  = 'EDoubleObj',\r\nEBooleanObj = 'EBooleanObj',\r\nEByteObj  = 'EByteObj',\r\nEShortObj  = 'EShortObj',\r\nEIntObj  = 'EIntObj',\r\nELongObj  = 'ELongObj',\r\nEELIST  = 'EELIST',*/\n(function (ShortAttribETypes) {\n  ShortAttribETypes[\"EVoid\"] = \"EVoid\";\n  ShortAttribETypes[\"EChar\"] = \"EChar\";\n  ShortAttribETypes[\"EString\"] = \"EString\";\n  ShortAttribETypes[\"EDate\"] = \"EDate\";\n  ShortAttribETypes[\"EBoolean\"] = \"EBoolean\";\n  ShortAttribETypes[\"EByte\"] = \"EByte\";\n  ShortAttribETypes[\"EShort\"] = \"EShort\";\n  ShortAttribETypes[\"EInt\"] = \"EInt\";\n  ShortAttribETypes[\"ELong\"] = \"ELong\";\n  ShortAttribETypes[\"EFloat\"] = \"EFloat\";\n  ShortAttribETypes[\"EDouble\"] = \"EDouble\";\n})(ShortAttribETypes || (ShortAttribETypes = {}));\nwindoww.ShortAttribETypes = ShortAttribETypes;\nexport const ShortAttribSuperTypes = {\n  \"EVoid\": [],\n  \"EChar\": [ShortAttribETypes.EString],\n  \"EString\": [],\n  \"EDate\": [],\n  \"EBoolean\": [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EByte\": [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EShort\": [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EInt\": [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"ELong\": [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EFloat\": [ShortAttribETypes.EDouble],\n  \"EDouble\": []\n};\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\nexport function toShortEType(a) {\n  return a.substring(ecoreprefix.length);\n}\nexport function toLongEType(a) {\n  return AttribETypes[a];\n  // return ecoreprefix + a as any;\n}\n\nexport function toShortEClass(a) {\n  return a.substring(ecoreclasprefix.length);\n}\nexport function toLongEClass(a) {\n  return DefaultEClasses[a];\n}\nexport class SelectorOutput {\n  constructor() {\n    this.jqselector = void 0;\n    this.attrselector = void 0;\n    this.attrRegex = void 0;\n    this.exception = void 0;\n    this.resultSetAttr = void 0;\n    this.resultSetElem = void 0;\n  }\n}\n// compare it with event.key\nexport let Keystrokes; // not even triggering event?\n(function (Keystrokes) {\n  Keystrokes[Keystrokes[\"clickLeft\"] = 0] = \"clickLeft\";\n  Keystrokes[Keystrokes[\"clickWheel\"] = 1] = \"clickWheel\";\n  Keystrokes[Keystrokes[\"clickRight\"] = 2] = \"clickRight\";\n  Keystrokes[Keystrokes[\"clickBackMouseButton\"] = 3] = \"clickBackMouseButton\";\n  Keystrokes[Keystrokes[\"clickForwardMouseButton\"] = 4] = \"clickForwardMouseButton\";\n  Keystrokes[\"escape\"] = \"Escape\";\n  Keystrokes[\"capsLock\"] = \"CapsLock\";\n  Keystrokes[\"shift\"] = \"Shift\";\n  Keystrokes[\"tab\"] = \"Tab\";\n  Keystrokes[\"alt\"] = \"Alt\";\n  Keystrokes[\"control\"] = \"Control\";\n  Keystrokes[\"end\"] = \"End\";\n  Keystrokes[\"home\"] = \"Home\";\n  Keystrokes[\"pageUp\"] = \"PageUp\";\n  Keystrokes[\"pageDown\"] = \"PageDown\";\n  Keystrokes[\"enter\"] = \"Enter\";\n  Keystrokes[\"numpadEnter\"] = \"NumpadEnter\";\n  Keystrokes[\"audioVolumeMute\"] = \"AudioVolumeMute\";\n  Keystrokes[\"audioVolumeUp\"] = \"AudioVolumeUp\";\n  Keystrokes[\"audioVolumeDown\"] = \"AudioVolumeDown\";\n  Keystrokes[\"mediaTrackPrevious\"] = \"MediaTrackPrevious\";\n  Keystrokes[\"delete\"] = \"Delete\";\n  Keystrokes[\"backspace\"] = \"Backspace\";\n  Keystrokes[\"space\"] = \" \";\n  Keystrokes[\"altGraph\"] = \"AltGraph\";\n  Keystrokes[\"arrowLeft\"] = \"ArrowLeft\";\n  Keystrokes[\"arrowRight\"] = \"ArrowRight\";\n  Keystrokes[\"arrowUp\"] = \"ArrowUp\";\n  Keystrokes[\"arrowDown\"] = \"ArrowDown\";\n  Keystrokes[\"insert\"] = \"Insert\";\n  Keystrokes[\"f1\"] = \"F1\";\n  Keystrokes[\"meta\"] = \"Meta\";\n  Keystrokes[\"unidentified\"] = \"Unidentified\";\n  Keystrokes[\"__NotReacting__\"] = \"fn, print, maybe others\";\n})(Keystrokes || (Keystrokes = {}));\nexport let DefaultEClasses;\n(function (DefaultEClasses) {\n  DefaultEClasses[\"EObject\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\";\n  DefaultEClasses[\"EAnnotation\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\";\n  DefaultEClasses[\"EClass\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\";\n  DefaultEClasses[\"EPackage\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\";\n  DefaultEClasses[\"ENamedElement\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\";\n})(DefaultEClasses || (DefaultEClasses = {}));\nexport let AttribETypes; // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\n// EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\n/*\r\nECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\nEStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\nEDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\nEFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\nEDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\nEBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\nEByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\nEShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\nEIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\nELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\n// EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\n\n// export type Json = object;\n(function (AttribETypes) {\n  AttribETypes[\"EVoid\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid\";\n  AttribETypes[\"EChar\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar\";\n  AttribETypes[\"EString\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\";\n  AttribETypes[\"EDate\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate\";\n  AttribETypes[\"EFloat\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat\";\n  AttribETypes[\"EDouble\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble\";\n  AttribETypes[\"EBoolean\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean\";\n  AttribETypes[\"EByte\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte\";\n  AttribETypes[\"EShort\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort\";\n  AttribETypes[\"EInt\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\";\n  AttribETypes[\"ELong\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong\";\n})(AttribETypes || (AttribETypes = {}));\nexport class ParseNumberOrBooleanOptions {\n  constructor() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let allowNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let nullValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let allowUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let undefinedValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    let allowedNan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let nanValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : NaN;\n    let allowBooleans = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n    let trueValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n    let falseValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    this.defaultValue = void 0;\n    this.allowNull = void 0;\n    this.nullValue = void 0;\n    this.allowUndefined = void 0;\n    this.undefinedValue = void 0;\n    this.allowedNan = void 0;\n    this.nanValue = void 0;\n    this.allowBooleans = void 0;\n    this.trueValue = void 0;\n    this.falseValue = void 0;\n    this.defaultValue = defaultValue;\n    this.allowNull = allowNull;\n    this.nullValue = nullValue;\n    this.allowUndefined = allowUndefined;\n    this.undefinedValue = undefinedValue;\n    this.allowedNan = allowedNan;\n    this.nanValue = nanValue;\n    this.allowBooleans = allowBooleans;\n    this.trueValue = trueValue;\n    this.falseValue = falseValue;\n  }\n}\nexport class LoggerCategoryState {\n  constructor(args, short_string, cat) {\n    this.category = void 0;\n    this.time = void 0;\n    this.raw_args = void 0;\n    this.short_string = void 0;\n    this.long_string = void 0;\n    this.raw_args = args;\n    this.time = new Date().getTime();\n    this.category = cat;\n    this.short_string = short_string;\n    this.long_string = '';\n    const maxChars = {\n      function: [50, 0],\n      object: [100, 0],\n      string: [80, 20]\n    };\n    let ansiConvert = window.ansiConvert;\n    if (!ansiConvert) {\n      window.ansiconvert = ansiConvert = new Convert();\n    }\n    for (let a of args) {\n      let s;\n      let ta = typeof a;\n      switch (ta) {\n        case \"function\":\n          s = a.toString();\n          break;\n        case \"object\":\n          let outstr = U.inspect(a, true, 2, true);\n          outstr = U.replaceAll(ansiConvert.toHtml(outstr), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\n          let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\n          outstr = U.replaceAll(outstr, \"$\", \"£\");\n          outstr = outstr.replace(regexpCloseTags, \"</span>$1\");\n          outstr = U.replaceAll(outstr, \"£\", \"$\");\n          s = outstr;\n          break;\n        default:\n          s = '' + a;\n      }\n      if (maxChars[ta]) s = U.cropStr(s, maxChars[ta][0], maxChars[ta][1]);\n      this.long_string += s;\n    }\n  }\n}\nexport let Log = (_dec4 = RuntimeAccessible('Log'), _dec4(_class6 = (_class7 = class Log {\n  // public static history: Dictionary<string, Dictionary<string, any[]>> = {}; // history['pe']['key'] = ...parameters\n  /*\r\n  public static last_e: LoggerCategoryState[] = [];\r\n  public static last_eDev: LoggerCategoryState[] = [];\r\n  public static last_ex: LoggerCategoryState[] = [];\r\n  public static last_exDev: LoggerCategoryState[] = [];\r\n  public static last_w: LoggerCategoryState[] = [];\r\n  public static last_i: LoggerCategoryState[] = [];*/ // private static loggerMapping: Dictionary<string, LoggerInterface[]> = {} // takes function name returns logger list\n  // takes function name returns log messages list\n  /*\r\n      public static registerLogger(logger: LoggerInterface, triggerAt: (typeof windoww.U.pe) & {name: string, cname:string}) {\r\n          let tname: string = (triggerAt as any).cname || (triggerAt as any).name;\r\n          if (!Log.loggerMapping[tname]) Log.loggerMapping[tname] = [];\r\n          Log.loggerMapping[tname].push(logger);\r\n      }*/\n  static disableConsole() {\n    // @ts-ignore\n    console['logg'] = console.log;\n    console.log = () => {};\n  }\n  static enableConsole() {\n    // @ts-ignore\n    if (console['logg']) console.log = console['logg'];\n  }\n  static log(prefix, category, originalFunc, b) {\n    for (var _len10 = arguments.length, restArgs = new Array(_len10 > 4 ? _len10 - 4 : 0), _key11 = 4; _key11 < _len10; _key11++) {\n      restArgs[_key11 - 4] = arguments[_key11];\n    }\n    if (!b) {\n      return '';\n    }\n    const key = windoww.U.getCaller(1); // todo: remove replace heavy fumc\n    if (restArgs === null || restArgs === undefined) {\n      restArgs = [];\n    }\n    let str = key + ': ';\n    for (let i = 0; i < restArgs.length; i++) {\n      // console.log(prefix, {i, restArgs, curr:restArgs[i]});\n      str += '' + (typeof restArgs[i] === 'symbol' ? '' + String(restArgs[i]) : restArgs[i]) + '\\t\\r\\n';\n    }\n    Log.updateLoggerComponent(category, restArgs, str, category);\n    // merged loggers if (Log.loggerMapping[category]) for (const logger of Log.loggerMapping[category]) { logger.log(category, key, restArgs, str); }\n    originalFunc(key, ...restArgs);\n    return '[' + prefix + ']' + str;\n  }\n  static e(b) {\n    if (!b) return '';\n    for (var _len11 = arguments.length, restArgs = new Array(_len11 > 1 ? _len11 - 1 : 0), _key12 = 1; _key12 < _len11; _key12++) {\n      restArgs[_key12 - 1] = arguments[_key12];\n    }\n    const str = Log.log('Error', 'e', console.error, b, ...restArgs);\n    Log.lastError = restArgs;\n    return str;\n    // throw new Error(str);\n  }\n\n  static eDev(b) {\n    if (!b) return '';\n    for (var _len12 = arguments.length, restArgs = new Array(_len12 > 1 ? _len12 - 1 : 0), _key13 = 1; _key13 < _len12; _key13++) {\n      restArgs[_key13 - 1] = arguments[_key13];\n    }\n    const str = Log.log('Dev Error', 'eDev', console.error, b, ...restArgs);\n    Log.lastError = restArgs;\n    return str;\n    // throw new Error(str);\n  }\n\n  static ex(b) {\n    if (!b) return null;\n    for (var _len13 = arguments.length, restArgs = new Array(_len13 > 1 ? _len13 - 1 : 0), _key14 = 1; _key14 < _len13; _key14++) {\n      restArgs[_key14 - 1] = arguments[_key14];\n    }\n    const str = Log.log('Error', 'e', console.error, b, ...restArgs);\n    Log.lastError = restArgs;\n    windoww.ee = restArgs;\n    windoww.e1 = restArgs[1];\n    throw new MyError(str, ...restArgs);\n  }\n  static exDev(b) {\n    if (!b) return null;\n    for (var _len14 = arguments.length, restArgs = new Array(_len14 > 1 ? _len14 - 1 : 0), _key15 = 1; _key15 < _len14; _key15++) {\n      restArgs[_key15 - 1] = arguments[_key15];\n    }\n    const str = Log.log('Dev Error', 'eDev', console.error, b, ...restArgs);\n    Log.lastError = restArgs;\n    windoww.ee = restArgs;\n    windoww.e1 = restArgs[1];\n    throw new MyError(str, ...restArgs);\n  }\n  static i(b) {\n    if (!b) return null;\n    for (var _len15 = arguments.length, restArgs = new Array(_len15 > 1 ? _len15 - 1 : 0), _key16 = 1; _key16 < _len15; _key16++) {\n      restArgs[_key16 - 1] = arguments[_key16];\n    }\n    return Log.log('Info', 'i', console.log, b, ...restArgs);\n  }\n  static get_loggercomponent() {\n    return Log._loggerComponent;\n  }\n  static updateLoggerComponent(type, args, short_str, cat) {\n    let c = Log.get_loggercomponent();\n    let update = new LoggerCategoryState(args, short_str, cat);\n    Log.messageMapping[type].push(update);\n    // (Log as GObject)[\"last_\"+type].push(args);\n    if (!c) return;\n    c.setState({\n      [type + \"_counter\"]: c.state[type + \"_counter\"]++\n    }); // so it doesn't pass through redux\n  }\n\n  static l(b) {\n    if (!b) return null;\n    for (var _len16 = arguments.length, restArgs = new Array(_len16 > 1 ? _len16 - 1 : 0), _key17 = 1; _key17 < _len16; _key17++) {\n      restArgs[_key17 - 1] = arguments[_key17];\n    }\n    return Log.log('Log', 'l', console.log, b, ...restArgs);\n  }\n  static w(b) {\n    if (!b) return null;\n    for (var _len17 = arguments.length, restArgs = new Array(_len17 > 1 ? _len17 - 1 : 0), _key18 = 1; _key18 < _len17; _key18++) {\n      restArgs[_key18 - 1] = arguments[_key18];\n    }\n    return Log.log('Warn', 'w', console.warn, b, ...restArgs);\n  }\n  static eDevv(firstParam) {\n    for (var _len18 = arguments.length, restAgs = new Array(_len18 > 1 ? _len18 - 1 : 0), _key19 = 1; _key19 < _len18; _key19++) {\n      restAgs[_key19 - 1] = arguments[_key19];\n    }\n    return Log.eDev(true, ...[firstParam, ...restAgs]);\n  }\n  static ee() {\n    for (var _len19 = arguments.length, restAgs = new Array(_len19), _key20 = 0; _key20 < _len19; _key20++) {\n      restAgs[_key20] = arguments[_key20];\n    }\n    return Log.e(true, ...restAgs);\n  }\n  static exDevv(firstParam) {\n    for (var _len20 = arguments.length, restAgs = new Array(_len20 > 1 ? _len20 - 1 : 0), _key21 = 1; _key21 < _len20; _key21++) {\n      restAgs[_key21 - 1] = arguments[_key21];\n    }\n    return Log.exDev(true, ...[firstParam, ...restAgs]);\n  }\n  static exx() {\n    for (var _len21 = arguments.length, restAgs = new Array(_len21), _key22 = 0; _key22 < _len21; _key22++) {\n      restAgs[_key22] = arguments[_key22];\n    }\n    return Log.ex(true, ...restAgs);\n  }\n  static ii() {\n    for (var _len22 = arguments.length, restAgs = new Array(_len22), _key23 = 0; _key23 < _len22; _key23++) {\n      restAgs[_key23] = arguments[_key23];\n    }\n    return Log.i(true, ...restAgs);\n  }\n  static ll() {\n    for (var _len23 = arguments.length, restAgs = new Array(_len23), _key24 = 0; _key24 < _len23; _key24++) {\n      restAgs[_key24] = arguments[_key24];\n    }\n    return Log.l(true, ...restAgs);\n  }\n  static ww() {\n    for (var _len24 = arguments.length, restAgs = new Array(_len24), _key25 = 0; _key25 < _len24; _key25++) {\n      restAgs[_key25] = arguments[_key25];\n    }\n    return Log.w(true, ...restAgs);\n  }\n}, _class7.lastError = void 0, _class7.messageMapping = {\n  l: [],\n  i: [],\n  w: [],\n  e: [],\n  ex: [],\n  eDev: [],\n  exDev: []\n}, _class7._loggerComponent = undefined, _class7)) || _class6);\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\n\nexport class FileReadTypeEnum {}\n\n// console.info('loaded ts U');\nFileReadTypeEnum.image = \"image/*\";\nFileReadTypeEnum.audio = \"audio/*\";\nFileReadTypeEnum.video = \"video/*\";\nFileReadTypeEnum.AndManyOthersButThereAreTooMuch = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\nFileReadTypeEnum.OrJustPutFileExtension = \"OrJustPutFileExtension\";","map":{"version":3,"names":["JsType","LModelElement","LNamedElement","MyError","RuntimeAccessible","store","windoww","Swal","Storage","compressToUTF16","decompressFromUTF16","util","Convert","console","warn","Color","_dec","_class","constructor","r","g","b","fromHex","hex","undefined","fromHLS","_ref","h","l","s","getHex","mixWith","c","getHLS","duplicate","U","_dec2","_class3","_class4","decompressState","state","compressedState","JSON","stringify","getState","isOffline","read","refresh","window","location","reload","inspect","object","showHidden","depth","color","_object","__raw","Array","isArray","map","o","objectInspect","val","arguments","length","ansiConvert","ansiconvert","replaceAll","toHtml","cropStr","msg","atStart","atEnd","arr","split","splice","join","extractByKey","dict","path","keys","topic","data","values","d","value","k","hasOwnProperty","push","extractKeys","traverse","obj","key","wrapper","json","dElement","parse","hexToPalette","_len","hexs","_key","type","substring","a","Number","parseInt","Log","exDev","i","fatherChain","me","fathers","id","toCheck","element","pop","father","isShallowEqualWithProxies","obj1","obj2","skipKeys","out","maxDepth","returnIfMaxDepth","tobj1","tobj2","reason","error","isNaN","toString","o1Raw","o2Raw","className","clonedCounter","oldp","newp","deepEqual","x","y","tx","ty","Object","every","sleep","Promise","resolve","setTimeout","getRandomString","characters","randomString","index","randomNumber","Math","floor","random","charAt","alert","title","text","toLowerCase","html","result","fire","backdrop","showCloseButton","showConfirmButton","popup","filteredPointedBy","label","models","pointedBy","source","fromPointer","getFatherFieldToDelete","field","initializeValue","typeclassifier","pointer","name","Date","toJSON","slice","orderChildrenByTimestamp","context","children","proxyObject","orderedChildren","Map","child","timestamp","set","entries","sort","followPath","base","patharr","base0","ret","chain","lastObject","lastkey","failedRemainingPath","lastval","Error","multiReplaceAllKV","kv","vals","multiReplaceAll","searchText","replacement","str","debug","toFileName","trim","objectMergeInPlace","output","_len2","objarr","_key2","_out$key","log","clear","removeEmptyObjectKeys","objectMergeInPlace_conditional","condition","_len3","_key3","buildFunctionDocumentation","f","e","isFunction","parameters","returns","fname","isLambda","signature","starti","indexOf","endi","parcounter","parameterStr","substr","returnstarti","returnendi","bodystarti","max","regexp","match","exec","par","defaultVal","typedesc","parseFunctionWithContextAndScope","codeStr0","context0","scope0","codestrParamNames","protectShallowValues","doIdentifierValidation","codeStr","scopeParams","scope","scopekeys","_key4","validIdentfierRegexp","test","filter","innerFuncParams","_jevalfunc","evalmode","params","eval","Function","bind","evalInContextAndScopeNew","injectScopeToo","evalInContextAndScope","ex","_ret","__proto__","w","eDev","prefixDeclarations","postfixDeclarations","isStrict","_eval","__codeStr","call","_len4","_key5","execInContextAndScope","func","apply","execInScope_DO_NOT_USE","evalInContext","js","highOrderFunctionExampleTyped","funcName","cname","time","results","timeEnd","asClass","classe","elseReturn","asString","propKey","isString","loadScript","useEval","script","document","createElement","src","body","append","ancestorArray","domelem","stopNode","includeSelf","tmp","parentNode","container","containerTag","innerHTML","firstChild","removeChild","levenshtein","cost","min","getClosestPropertyName","names","lowest","Infinity","reduce","previous","current","distance","getClosestPropertyNames","distances","autoCorrectProxy","target","recursive","logger","Proxy","get","namestr","suggestions","getOwnPropertyNames","arrayRemoveAll","elem","arrayUnique","Set","fileReadContent","file","callback","textType","reader","FileReader","onload","readAsText","fileRead","onChange","extensions","readContent","myFileReader","show","htmlNode","clearAllTimeouts","highestTimeoutId","clearTimeout","getStackTrace","sliceCalls","stack","getCaller","stacksToSkip","isFirstTimeCalledByThisLine","caller","gotcalledby","lineKey","preventBackSlashHistoryNavigation","event","types","srcElement","$","disabled","prop","isContentEditable","is","attr","preventDefault","SetMerge","modifyFirst","_len5","iterables","_key6","iterable","item","add","ArrayMergeU","arr1","_len6","arr2","_key7","ArrayMerge0","ArrayMerge","_len7","_key8","unique","arrtarget","_len8","arrays","_key9","arri","ArrayAdd","prototype","throwIfContained","getType","param","_param$constructor","stringCompare","s1","s2","endsWith","suffix","suf","lastIndexOf","arrayMergeInPlace","_len9","otherArrs","_key10","getEndingNumber","ignoreNonNumbers","allowDecimal","numberEnd","parseFloat","increaseEndingNumber","allowLastNonNumberChars","increaseWhile","regexpstr","matches","RegExp","prefix","num","shallowEqual","objA","objB","keysA","keysB","keya","isNumber","getAllPrototypes","_constructor$prototyp","_constructor$__proto_","chainoutoutrecursive","currentRecursion","maxRecursion","cache","__allprototypes","classIsExtending","subconstructor","superconstructor","_extends","includes","isObject","v","returnIfNull","returnIfUndefined","retIfArray","objectFromArray","getKey","acc","objectFromArrayValues","toBoolString","bool","ifNotBoolean","fromBoolString","allowNull","allowUndefined","arrayDifference","starting","final","removed","Uarr","arraySubtract","added","objectDelta","old","neww","deep","newwobj","oldobj","diff","objdiff","changed","subold","subnew","removedprefix","unchanged","flattenObjectToRoot","pathseparator","pre","assign","ObjectToAssignementStrings","maxkeylength","maxsubpaths","maxvallength","toolongreplacer","quotestrings","valueseparator","filterrow","rowpaths","flatten","halfpath","start","end","ceil","halfval","halfsubpaths","bestpathsize","best","countsize","total","arrelem","filterbest","row","pathlength","fullstr","fullpath","fullvalue","p","download","filename","htmla","blob","Blob","endings","blobUrl","URL","createObjectURL","style","display","href","appendChild","click","revokeObjectURL","formatXml","xml","reg","wsexp","contexp","replace","pad","formatted","lines","indent","lastType","transitions","ln","single","Boolean","closing","opening","fromTo","padding","j","circularStringify","replacer","space","maxDepth_unsupported","getFirstNumber","allowDecimalDot","allowDecimalComma","valueifmismatch","commamode","floatregex","intregex","tmpindex","isEmptyObject","pairArrayElementsRepeatFunc","pairArrayElementsReducerFunc","accumulator","array","pairArrayElements","withRepetitions","decomment_all","decomment_line","decomment_block","trimLines","uppercaseFirstLetter","toUpperCase","wrapUserFunction","stringMiddleCut","maxLength","ellipsisChar","asArray","midpoint","toremove","lstrip","rstrip","invertHex","transformGrays","ee","abs","rs","gs","bs","hs","parentUntil","tagName","parentElement","paletteSplit","palette","number","entry","mergeNamedArray","classes","clipboardCopy","onSuccess","onFailure","navigator","clipboard","writeText","then","clipboardCopy_old","clipboardinput","position","top","select","execCommand","clearSelection","toNamedArray","larr","darr","maxID","idPrefix","getID","idgenerator","DDate","addDay","date","offset","inplace","setDate","getDate","addMonth","setMonth","getMonth","addYear","setFullYear","getFullYear","setinfos","fileTypes","onchange","readcontent","input","files","contentObj","fileLetti","content","_input$files","contentArr","reset","setAttribute","on","trigger","_dec3","_class5","arrayIntersection","inPlace","equals","a1","a2","FocusHistoryEntry","evt","ShortDefaultEClasses","ShortAttribETypes","ShortAttribSuperTypes","EString","EByte","EShort","EInt","ELong","EFloat","EDouble","ecoreprefix","ecoreclasprefix","toShortEType","toLongEType","AttribETypes","toShortEClass","toLongEClass","DefaultEClasses","SelectorOutput","jqselector","attrselector","attrRegex","exception","resultSetAttr","resultSetElem","Keystrokes","ParseNumberOrBooleanOptions","defaultValue","nullValue","undefinedValue","allowedNan","nanValue","NaN","allowBooleans","trueValue","falseValue","LoggerCategoryState","args","short_string","cat","category","raw_args","long_string","getTime","maxChars","function","string","ta","outstr","regexpCloseTags","_dec4","_class6","_class7","disableConsole","enableConsole","originalFunc","_len10","restArgs","_key11","String","updateLoggerComponent","_len11","_key12","lastError","_len12","_key13","_len13","_key14","e1","_len14","_key15","_len15","_key16","get_loggercomponent","_loggerComponent","short_str","update","messageMapping","setState","_len16","_key17","_len17","_key18","eDevv","firstParam","_len18","restAgs","_key19","_len19","_key20","exDevv","_len20","_key21","exx","_len21","_key22","ii","_len22","_key23","ll","_len23","_key24","ww","_len24","_key25","FileReadTypeEnum","image","audio","video","AndManyOthersButThereAreTooMuch","OrJustPutFileExtension"],"sources":["C:/d/Programming/web/jodel-mde/src/common/U.ts"],"sourcesContent":["// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\r\n// import {Mixin} from \"ts-mixer\";\r\nimport type {\r\n    AbstractConstructor,\r\n    Constructor,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    Pointer,\r\n    PrimitiveType,\r\n    Temporary,\r\n    LPointerTargetable,\r\n    DPointerTargetable,\r\n} from \"../joiner\";\r\nimport {\r\n    DClassifier,\r\n    DModelElement,\r\n    Json,\r\n    JsType,\r\n    LClassifier,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LogicContext,\r\n    MyError,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, store,\r\n    windoww\r\n} from \"../joiner\";\r\nimport Swal from \"sweetalert2\";\r\nimport Storage from '../data/storage';\r\nimport {compressToUTF16, decompressFromUTF16} from \"async-lz-string\";\r\nimport {NumberControl, PaletteControl, PaletteType, PathControl, StringControl} from \"../view/viewElement/view\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport {StringDecoder} from \"string_decoder\";\r\nimport util from \"util\";\r\nimport Convert from \"ansi-to-html\";\r\n// var Convert = require('ansi-to-html');\r\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\r\n\r\nconsole.warn('loading ts U log');\r\n\r\n@RuntimeAccessible('Color')\r\nexport class Color {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n\r\n    constructor(r: number, g: number, b: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    static fromHex(hex:string): Color {\r\n        return undefined as any;\r\n    }\r\n    static fromHLS({h, l, s}:{h: number, l:number, s: number}): Color {\r\n        return undefined as any;\r\n    }\r\n    getHex(): string {\r\n        return undefined as any;\r\n    }\r\n    mixWith(c: Color): void {\r\n\r\n    }\r\n    getHLS(): {h: number, l:number, s: number} {\r\n        return undefined as any;\r\n    }\r\n    duplicate(): Color {\r\n        return undefined as any;\r\n    }\r\n}\r\n\r\n\r\n@RuntimeAccessible('U')\r\nexport class U {\r\n\r\n    static async decompressState(state: string): Promise<string> {\r\n        return await decompressFromUTF16(state);\r\n    }\r\n    static async compressedState(): Promise<string> {\r\n        return await compressToUTF16(JSON.stringify(store.getState()));\r\n    }\r\n    static isOffline(): boolean {\r\n        return Storage.read('offline') === 'true';\r\n    }\r\n    static refresh(): void {\r\n        window.location.reload();\r\n    }\r\n\r\n    public static inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string {\r\n        object = object?.__raw || object;\r\n        if (Array.isArray(object)) object = object.map(o => o?.__raw || o);\r\n        return util.inspect(object, showHidden, depth, color);\r\n    }\r\n\r\n    public static objectInspect(val: GObject, depth: number = 2, color: boolean = true, showHidden = true): string{\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n        return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)),\r\n            \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n    }\r\n\r\n    public static cropStr(msg: string, atStart: number = 10, atEnd: number = 0): string{\r\n        let arr = msg.split('\\n');\r\n        if (atEnd + atStart < arr.length) {\r\n            //arr = arr.slice(0, 10) + arr.slice(10, 0);\r\n            arr.splice(atStart, arr.length - atStart - atEnd, '...')\r\n        }\r\n        return arr.join('\\n');\r\n    }\r\n\r\n    static extractByKey(dict: Dictionary, path: string): PrimitiveType[]|undefined {\r\n        const keys = path.split('.');\r\n        const topic = keys[0];\r\n        const data = dict[topic];\r\n        const values: PrimitiveType[] = [];\r\n        if(!Array.isArray(data)) return undefined;\r\n        for(const d of data) {\r\n            let value = d;\r\n            for (const k of keys) if (value.hasOwnProperty(k)) value = value[k];\r\n            values.push(value);\r\n        }\r\n        return values;\r\n\r\n    }\r\n\r\n    static extractKeys(dict: Dictionary): string[] {\r\n        const keys: string[] = [];\r\n        function traverse(obj: any, path: string) {\r\n            for (const key in obj) {\r\n                if (typeof obj[key] === 'object') traverse(obj[key], path ? `${path}.${key}` : key);\r\n                else keys.push(path ? `${path}.${key}` : key);\r\n            }\r\n        }\r\n        for (const key in dict) {\r\n            traverse(dict[key][0], key);\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    // damiano: eseguire una funzione costa in performance, anche se è brutto fare questi cast\r\n    static wrapper<T>(obj: any): T {\r\n        return obj as unknown as T;\r\n    }\r\n    // damiano: mi sa che c'era un metodo l.__serialize or something\r\n    static json(dElement: GObject): Json {\r\n        return JSON.parse(JSON.stringify(dElement.__raw));\r\n    }\r\n\r\n    static hexToPalette(...hexs: string[]): PaletteControl{\r\n        return {type: \"color\", value: hexs.map( hex => {\r\n                if (hex[0] === '#') hex = hex.substring(1);\r\n                let r: number, g: number, b: number, a: number = 1;\r\n                if (hex.length === 4) {\r\n                    a = Number.parseInt('0x' + hex[3] + hex[3])/255;\r\n                    hex = hex.substring(0, 3);\r\n                }\r\n                if (hex.length === 7) {\r\n                    a = Number.parseInt('0x' + hex[5] + hex[6])/255;\r\n                    hex = hex.substring(0, 6);\r\n                }\r\n                Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {hex, a});\r\n                let i: number = 0;\r\n                if (hex.length === 3) {\r\n                    r =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i] + hex[i]);\r\n                }\r\n                else {\r\n                    r =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i++] + hex[i]);\r\n                }\r\n                return {r,g,b,a} as tinycolor.ColorFormats.RGBA;\r\n            })};\r\n    }\r\n    public static fatherChain(me: LModelElement): Pointer<DModelElement, 0, 'N', LModelElement> {\r\n        if(!me) return [];  // without this line go through delete error\r\n        const fathers: Pointer<DModelElement, 0, 'N', LModelElement>= [me.id];\r\n        const toCheck: LModelElement[] = [me];\r\n        while(toCheck.length > 0) {\r\n            const element = toCheck.pop();\r\n            if(element && element.father) {\r\n                fathers.push(element.father.id);\r\n                toCheck.push(element.father);\r\n            }\r\n        }\r\n        return fathers;\r\n    }\r\n\r\n    /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\r\n    static isShallowEqualWithProxies(obj1: GObject, obj2: GObject, skipKeys: Dictionary<string, any>={}, out?: {reason?: string},\r\n                                     depth: number = 0, maxDepth: number = 2, returnIfMaxDepth:boolean = false): boolean {\r\n        let tobj1 = obj1 === null ? 'null' : typeof obj1;\r\n        let tobj2 = obj2 === null ? 'null' : typeof obj2;\r\n        if (obj1 === obj2) {\r\n            // if (out) { out.reason = \"identical objects\"; }\r\n            return true; }\r\n        if (tobj1 !== tobj2) { if (out) { out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2; } return false; }\r\n\r\n        // at this point: same type, but different values\r\n        switch (tobj1) {\r\n            default: // primitive with different values\r\n                console.error(\"unexpected case in isshallowequal:\", {tobj1, obj1, obj2});\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case 'string': case 'boolean': // primitive with different values\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case \"number\": // if both re nan it fails\r\n                // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\r\n                if (isNaN(obj1 as any) && isNaN(obj2 as any)) return true;\r\n                if (out) out.reason = 'number changed';\r\n                return false;\r\n\r\n            case \"function\":\r\n                if (obj1.toString() === obj2.toString()) break;\r\n                if (out) out.reason = 'function body changed';\r\n                return false;\r\n\r\n            case \"object\":\r\n                let o1Raw = obj1.__raw;\r\n                let o2Raw = obj2.__raw;\r\n                if (o1Raw) {\r\n                    if (!o2Raw) {\r\n                        if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                        return false;\r\n                    }\r\n                    obj1 = o1Raw;\r\n                    obj2 = o2Raw;\r\n                }\r\n                // for proxies and DObjects\r\n                if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\r\n                    if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter+ ' != ' + obj2.clonedCounter;\r\n                    return false;\r\n                }/*\r\n                if (obj1.className !== obj2.className) {\r\n                 removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n                 nd it's checked anyway in for(let key in obj1)\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }*/\r\n                if (Array.isArray(obj1)) {\r\n                    if (obj1.length !== obj2.length) {\r\n                        if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\r\n                        return false;\r\n                    }\r\n                    if (!Array.isArray(obj2)){\r\n                        if (out) out.reason = 'array became an object';\r\n                        return false;\r\n                    }\r\n                }\r\n                if (depth > maxDepth) {\r\n                    // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\r\n                    if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\r\n                    return returnIfMaxDepth;\r\n                }\r\n                for (let key in obj1) {\r\n                    if (key in skipKeys) continue;\r\n                    let oldp: any = obj2[key];\r\n                    let newp: any = obj1[key];\r\n                    if (oldp === newp) continue;\r\n                    if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth +1, maxDepth, returnIfMaxDepth)) {\r\n                        if (out) out.reason = '['+key+']'+out.reason;\r\n                        return false;\r\n                    }\r\n                }\r\n                // just check for keys that were in props and are not in nextProps\r\n                for (let key in obj2) {\r\n                    if ((key in skipKeys) || (key in obj1)) continue;\r\n                    if (out) out.reason = \"deleted subobject property: \" + key;\r\n                    return false;\r\n                }\r\n            // else retIfMaxDepthReached; split the above if\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    public static deepEqual (x: GObject, y: GObject): boolean {\r\n        const tx = typeof x, ty = typeof y;\r\n        return x && y && tx === 'object' && tx === ty ? (\r\n            Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key]))\r\n        ) : (x === y);\r\n    }\r\n\r\n    public static sleep(s: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, s * 1000));\r\n    }\r\n\r\n    public static getRandomString(length: number): string {\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        let randomString = '';\r\n        let index = 0;\r\n        while(index < length) {\r\n            const randomNumber = Math.floor(Math.random() * characters.length);\r\n            randomString += characters.charAt(randomNumber);\r\n            index += 1;\r\n        }\r\n        return randomString;\r\n    }\r\n\r\n    public static alert(title: string, text: string) {\r\n        let color = 'text-';\r\n        switch(title.toLowerCase()) {\r\n            case 'error': color += 'danger'; break;\r\n            default: color += 'primary'\r\n        }\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>';\r\n        html += `<div><b><label class='fs-5 mb-2 text-uppercase ${color}'>${title}</label></b><hr/>`;\r\n        html += `<label class='fs-6 mt-3'>${text}</label><br/>`;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n\r\n    public static popup(element: any) {\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>'+ element;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n    public static filteredPointedBy(data: LModelElement, label: string): LModelElement[] {\r\n        const models: LModelElement[] = [];\r\n        for(let dict of data.pointedBy) {\r\n            const pointedBy = dict.source.split('.');\r\n            if(pointedBy.length === 3 && pointedBy[2] === label) {\r\n                models.push(LModelElement.fromPointer(pointedBy[1]));\r\n            }\r\n        }\r\n        return models;\r\n    }\r\n\r\n    public static getFatherFieldToDelete(data: LModelElement): keyof DModelElement|null {\r\n        const father = data.father;\r\n        let field = '';\r\n        switch(father.className + '|' + data.className) {\r\n            // DPackage\r\n            case 'DModel|DPackage': field = 'packages'; break;\r\n            case 'DPackage|DPackage': field = 'subpackages'; break;\r\n            // DEnumerator and DClass\r\n            case 'DPackage|DEnumerator':\r\n            case 'DPackage|DClass': field = 'classifiers'; break;\r\n            // DAttribute\r\n            case 'DClass|DAttribute': field = 'attributes'; break;\r\n            // DReference\r\n            case 'DClass|DReference': field = 'references'; break;\r\n            // DOperation\r\n            case 'DClass|DOperation': field = 'operations'; break;\r\n            // DEnumLiteral\r\n            case 'DEnumerator|DEnumLiteral': field = 'literals'; break;\r\n            // DObject\r\n            case 'DModel|DObject': field = 'objects'; break;\r\n            // DParameter\r\n            case 'DOperation|DParameter': field = 'parameters'; break;\r\n            // DValue\r\n            case 'DObject|DValue': field = 'features'; break;\r\n            // Error\r\n            default: return null;\r\n        }\r\n        return field as keyof DModelElement;\r\n    }\r\n\r\n    public static initializeValue(typeclassifier: undefined|DClassifier|LClassifier|Pointer<DClassifier, 1, 1, LClassifier>): string {\r\n        // if(!classifier) return 'null';\r\n        const pointer: Pointer = typeof typeclassifier === 'string' ? typeclassifier : (typeclassifier as DClassifier)?.id;\r\n        const me: LNamedElement = LNamedElement.fromPointer(pointer);\r\n        switch(me?.name) {\r\n            default:\r\n            case 'EString': return '';\r\n            case 'EChar':  return 'a';\r\n            case 'EInt': return '0';\r\n            case 'ELong': return '0';\r\n            case 'EShort': return '0';\r\n            case 'Byte': return '0';\r\n            case 'EFloat': return '0';\r\n            case 'EDouble': return '0';\r\n            case 'EBoolean': return 'false';\r\n            case 'EDate': return new Date().toJSON().slice(0,10);\r\n        }\r\n        return 'null';\r\n    }\r\n\r\n    public static orderChildrenByTimestamp(context: LogicContext): LModelElement[] {\r\n        const children = context.proxyObject.children;\r\n        if(children && children.length > 0) {\r\n            let orderedChildren = new Map<number, LModelElement>();\r\n            for(let child of children) {\r\n                let timestamp = child.id.slice(-13);\r\n                orderedChildren.set(+timestamp, child);\r\n            }\r\n            orderedChildren = new Map([...orderedChildren.entries()].sort());\r\n            return [...orderedChildren.values()];\r\n        } else return [];\r\n    }\r\n\r\n\r\n    public static followPath(base: GObject, path: string): {chain: GObject[], lastObject: GObject, keys:string[], lastkey: string, lastval: any, failedRemainingPath: string[]} {\r\n        let patharr = path.split('.');\r\n        let base0 = base;\r\n        let ret: {chain: GObject[], lastObject: GObject, keys: string[], lastkey: string, lastval: any, failedRemainingPath: string[]}  = {} as any;\r\n        ret.keys = patharr;\r\n        ret.chain = [base];\r\n        let lastObject = base;\r\n\r\n        for (let i = 0; i < patharr.length; i++) {\r\n            let path = ret.lastkey = patharr[i];\r\n            lastObject = base;\r\n            base = base[path];\r\n            ret.chain.push(base);\r\n            if (typeof base !== \"object\" || i + 1 === patharr.length) {\r\n                ret.failedRemainingPath = patharr.slice(i);\r\n                ret.lastval = base;\r\n                ret.lastObject = lastObject;\r\n                return ret;\r\n            }\r\n        }\r\n        throw new Error(\"followPath should never reach here\");\r\n        return ret;\r\n    }\r\n\r\n    static multiReplaceAllKV(a: string, kv: string[][] = []): string {\r\n        const keys: string[] = [];\r\n        const vals: string[] = [];\r\n        let i: number;\r\n        for (i = 0; i < kv.length; i++) { keys.push(kv[i][0]); vals.push(kv[i][0]); }\r\n        return U.multiReplaceAll(a, keys, vals); }\r\n\r\n    // if replacement is empty, it will be filled with '';\r\n    // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\r\n    static multiReplaceAll(a: string, searchText: string[] = [], replacement: string[] = []): string {\r\n        // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\r\n        let i = -1;\r\n        while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\r\n        i = -1;\r\n        while (++i < searchText.length) { a = U.replaceAll(a, searchText[i], replacement[i]); }\r\n        return a; }\r\n\r\n    static replaceAll(str: string, searchText: string, replacement: string | undefined, debug: boolean = false, warn: boolean = true): string {\r\n        if (!str) { return str; }\r\n        return str.split(searchText).join(replacement||''); }\r\n\r\n    static toFileName(a: string = 'nameless.txt'): string {\r\n        if (!a) { a = 'nameless.txt'; }\r\n        a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'],\r\n            ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\r\n        return a;\r\n    }\r\n\r\n\r\n    // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\r\n    // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\r\n    // @ts-ignore\r\n    public static isStrict: boolean = ( function() { return !this; })();\r\n\r\n    // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\r\n    static objectMergeInPlace<A extends object, B extends object>(output: A, ...objarr: B[]): void {\r\n        const out: GObject = output;\r\n        if (objarr)\r\n            for (let o of objarr) {\r\n                if (o && typeof o === \"object\")\r\n                    for (let key in o) {\r\n                        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\r\n                        out[key] ?? (out[key] = o[key]);\r\n                    }\r\n            }\r\n    }\r\n\r\n    public static log(obj: unknown, label: string = '###') {\r\n        console.clear();\r\n        console.log(label, obj);\r\n    }\r\n\r\n    static removeEmptyObjectKeys(obj: GObject): void{\r\n        for (let key of Object.keys(obj)) {\r\n            if (obj[key] === null || obj[key] === undefined) delete obj[key];\r\n        }\r\n    }\r\n\r\n    // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\r\n    // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\r\n    static objectMergeInPlace_conditional<A extends GObject, B extends GObject>(output: A, condition: (...a:any)=>any, ...objarr: B[]): A & B {\r\n        const out: GObject<\"A & B\"> = output;\r\n        let i: number = 0;\r\n        for (let o of objarr) for (let key in o) { if (condition(out, key, o, objarr, i++)) out[key] = o[key]; }\r\n        return out as  A & B; }\r\n\r\n    static buildFunctionDocumentation(f: Function): {parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string} {\r\n        Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\r\n        // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\r\n        let ret: {parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string}\r\n            = {parameters: [], returns: undefined, f: f, fname: undefined, isLambda: null as Temporary, signature: ''};\r\n        let str: string = f.toString();\r\n        let starti: number = str.indexOf('(');\r\n        let endi: number;\r\n        let parcounter: number = 1;\r\n        for (endi = starti + 1; endi < str.length; endi++) {\r\n            if (str[endi] === ')' && --parcounter === 0) break;\r\n            if (str[endi] === '(') parcounter++; }\r\n\r\n        let parameterStr = str.substring(starti + 1, endi);\r\n        // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\r\n        ret.fname = str.substr(0, starti).trim();\r\n        ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\r\n        // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\r\n        if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\r\n\r\n\r\n\r\n        let returnstarti: number = str.indexOf('/*', endi + 1);\r\n        let returnendi: number = -1;\r\n        let bodystarti: number = str.indexOf('{', endi + 1);\r\n        if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\r\n            // no return type or comment is past body\r\n            ret.returns = undefined;\r\n        } else {\r\n            returnendi = str.indexOf('*/', returnstarti + 2);\r\n            ret.returns = str.substring(returnstarti + 2, returnendi).trim();\r\n            bodystarti = str.indexOf('{', returnendi); }\r\n        if (ret.returns === '') ret.returns = undefined;\r\n\r\n        // is lambda if do not have curly body or contains => between return comment and body\r\n        // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\r\n        ret.isLambda =  bodystarti === -1 || str.substring((window as any).Math.max(endi, returnendi)+1, bodystarti).trim() === '=>';\r\n\r\n        let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\r\n        let match;\r\n        while ((match = regexp.exec(parameterStr + ','))) {\r\n            // match[0] is always the full match (not a capture group)\r\n            // match[2] can only be \"=\" or empty string\r\n            // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\r\n            let par: {name: string, defaultVal: string | undefined, typedesc: string | null} = {name: match[1], defaultVal: match[3], typedesc: match[4] && match[4].length > 1 ? match[4] : null};\r\n            par.name = par.name.trim();\r\n            par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\r\n            par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\r\n            ret.parameters.push(par); }\r\n        // set signature\r\n\r\n        ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\r\n        let i: number;\r\n        for (i = 0; i < ret.parameters.length; i++) {\r\n            let par = ret.parameters[i];\r\n            ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\r\n        }\r\n        ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\r\n        return ret; }\r\n\r\n\r\n\r\n    // NB: need to use result.apply(context) to have a usable \"this\"\r\n    // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\r\n    //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\r\n    // rest values are declared with ellipsis in codestrParamNames\r\n    // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\r\n    // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\r\n    // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\r\n    public static parseFunctionWithContextAndScope<ParamNames extends string[], T extends Function = Function, TT extends GObject | undefined = GObject>(\r\n        codeStr0: string | Function, context0: GObject | undefined, scope0: TT, codestrParamNames?: ParamNames, protectShallowValues: boolean = false, doIdentifierValidation: boolean = false):\r\n        (TT extends undefined ? (...params: any)=>any : (scopee:TT, ...paramss: { [K in keyof ParamNames]: any;})=>any){\r\n        if (!codestrParamNames) codestrParamNames = [] as any;\r\n\r\n        let codeStr: string = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\r\n        let scopeParams: string = '';\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\r\n                scope = {};\r\n                for (let k in scope0) scope[k] = scope0[k];\r\n            } else scope = undefined;\r\n            if (context0) { // context = {...context0}; context.__proto__ = context0.__proto__;\r\n                context = {};\r\n                for (let k in context0) context[k] = context0[k];\r\n            } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n\r\n        if (scope) {\r\n            let scopekeys: string[] = Object.keys(scope);\r\n            if (doIdentifierValidation) scopekeys.map((key)=>{\r\n                key = key?.trim() || '';\r\n                if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\r\n                return key;\r\n            }).filter(k=>!!k);\r\n            scopeParams = '{'+scopekeys.join(',')+'}';\r\n        }\r\n\r\n        let innerFuncParams = (codestrParamNames as string[]).join(',');\r\n        let _jevalfunc = undefined as any; // is set by eval\r\n        const evalmode = false;\r\n        console.log('parseFunctionWithContextAndScope', {codeStr, scope, context, params:{scopeParams, innerFuncParams}});\r\n        scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\r\n        if (evalmode) {\r\n            codeStr = \"_jevalfunc = function (\"+scopeParams+\") { return (\"+codeStr+\")(\"+innerFuncParams+\") }\";\r\n            eval(codeStr);\r\n        } else {\r\n            _jevalfunc = new Function(scopeParams, \" return (\"+codeStr+\")(\"+innerFuncParams+\")\");\r\n        }\r\n\r\n        console.log('parseFunctionWithContextAndScope', {_jevalfunc, params:{scopeParams}});\r\n\r\n        if (context) return _jevalfunc.bind(context);\r\n        else return _jevalfunc;\r\n    }/*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\r\n    public static evalInContextAndScopeNew<T = any>(codeStr: string | ((...a:any)=>any), context0: GObject, injectScopeToo: boolean,\r\n                                                    protectShallowValues?: boolean, doIdentifierValidation?: boolean): T {\r\n        return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\r\n    }\r\n\r\n    // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\r\n    public static validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\n\r\n    // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\r\n    // can modify scope AND context\r\n    // warn: can access global scope (window)\r\n    // if the context (this) is missing it will take the scope as context.\r\n    // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\r\n    // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\r\n    // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\r\n    public static evalInContextAndScope<T = any>(codeStr: string | ((...a:any)=>any), scope0: GObject | undefined, context0?: GObject,\r\n                                                 protectShallowValues?: boolean, doIdentifierValidation?:boolean): T {\r\n        // console.log('evalInContextAndScope', {codeStr, scope, context});\r\n        // scope per accedere a variabili direttamente \"x + y\"\r\n        // context per accedervi tramite this, possono essere impostati come diversi.\r\n        if (!scope0 && !context0) { Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {codeStr, scope0, context0}); }\r\n\r\n        // scope.this = scope.this || context || scope; non funziona\r\n        // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\r\n        // eslint-disable-next-line no-restricted-syntax,no-with\r\n        // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\r\n        // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\r\n        let _ret: T = null as any;\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { scope = {...scope0, __proto__: scope0.__proto__}; scope.__proto__ = scope0.__proto__; } else scope = undefined;\r\n            if (context0) { context = {...context0, __proto__: context0.__proto__}; context.__proto__ = context0.__proto__; } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n        Log.w(!!(!context && scope),\r\n            \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" +\r\n            \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" +\r\n            \"Autofixed by assigning context = scope;\");\r\n        Log.eDev(!!((context && scope) && (context !== scope)),\r\n            \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" +\r\n            \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n\r\n\r\n        /*\r\n        if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n        if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n        if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\r\n//      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    if (doIdentifierValidation) {\r\n                        key = key.trim();\r\n                        if (!key || !U.validIdentfierRegexp.test(key)) continue;\r\n                    }\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n\r\n        if (scope && context) {\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n            // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\r\n            _ret = new (Function as any)(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\r\n            delete (context as any)._eval;\r\n        } else\r\n        if (!scope && context) {\r\n            if (typeof codeStr === \"function\") {\r\n                _ret = (function(...a: any){ return (codeStr as Function).call(context, ...a)}) as any;\r\n                // _ret = (...a: any)=>codeStr.call(context, ...a);\r\n            } else {\r\n                // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\r\n                (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n                _ret = new (Function as any)(\"return eval( this._eval.__codeStr );\").call(context);\r\n                delete (context as any)._eval;\r\n                // this below  is not good, as i need to quote the expanded result of codeStr,\r\n                // but since it might contain quotes as well i would need to escape them too.\r\n                // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\r\n            }\r\n        } else\r\n        if (scope && !context) {\r\n            // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\r\n            // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            _ret = eval(prefixDeclarations + codeStr + postfixDeclarations); }\r\n\r\n        return _ret; }\r\n\r\n    //T extends ( ((...args: any[]) => any) | (() => any)\r\n    public static execInContextAndScope<T extends (...args: any) => any>(func: T, parameters: Parameters<T>, scope?: GObject, context?: GObject): ReturnType<T>{\r\n        Log.l(false, 'execInCtxScope', {func, parameters, scope, context});\r\n        let ret: any;\r\n        const _eval = {context, scope, func, parameters: parameters || []};\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n        if (!scope && !context) { Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {func, scope, context}); }\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n        if (scope && context) {\r\n            context._eval = _eval;\r\n            // will the scope work with \"with\" outside the function body?\r\n            ret = new Function( prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\r\n            delete context._eval;\r\n        }\r\n        if (!scope && context) { return _eval.func.apply(_eval.context, _eval.parameters); }\r\n        if (scope && !context) {\r\n            // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\r\n            return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations); }\r\n        return ret; }\r\n\r\n    // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\r\n    // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\r\n    // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\r\n    // warn4: richiede un return per leggere il valore\r\n    // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\r\n    private static execInScope_DO_NOT_USE(codeStr: string, scope: GObject) {\r\n        return (new Function(...Object.keys(scope), codeStr))(...Object.values(scope));\r\n    }\r\n\r\n    // can modify context in-place, requires \"this\" before variable\r\n    private static evalInContext(js: string, context: GObject): unknown {\r\n        //# Return the results of the in-line anonymous function we .call with the passed context\r\n        return function() { return eval(js); }.call(context);\r\n    }/*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n        return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n\r\n    // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n*/\r\n    public static highOrderFunctionExampleTyped<T extends (...args: any[]) => ReturnType<T>>(func: T): (...funcArgs: Parameters<T>) => ReturnType<T> {\r\n        const funcName = (func as any).cname || func.name;\r\n\r\n        // Return a new function that tracks how long the original took\r\n        return (...args: Parameters<T>): ReturnType<T> => {\r\n            console.time(funcName);\r\n            const results = func(...args);\r\n            console.timeEnd(funcName);\r\n            return results; };\r\n    }\r\n\r\n    static asClass<T extends Function>(obj: any, classe: T, elseReturn: T | null = null): null | T { return obj instanceof classe ? obj as any as T: elseReturn; }\r\n    static asString<T>(propKey: unknown, elseReturn: T | null = null): string | null | T { return typeof propKey === 'string' ? propKey : elseReturn; }\r\n    static isString(propKey: unknown): boolean { return typeof propKey === 'string'; }\r\n\r\n    static loadScript(path: string, useEval: boolean = false): void {\r\n        const script = document.createElement('script');\r\n        script.src = path;\r\n        script.type = 'text/javascript';\r\n        Log.eDev(useEval, 'loadScript', 'useEval','useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\r\n        document.body.append(script); }\r\n\r\n    static ancestorArray<T extends Element>(domelem: T, stopNode?: Node, includeSelf: boolean = true): Array<T> {\r\n        // [0]=element, [1]=father, [2]=grandfather... [n]=document\r\n        if (domelem === null || domelem === undefined) { return []; }\r\n        const arr = includeSelf ? [domelem] : [];\r\n        let tmp: T = domelem.parentNode as T;\r\n        while (tmp !== null && tmp !== stopNode) {\r\n            arr.push(tmp);\r\n            tmp = tmp.parentNode as T; }\r\n        return arr; }\r\n\r\n    static toHtml<T extends Element>(html: string, container?: Element, containerTag: string = 'div'): T {\r\n        if (!container) { container = document.createElement(containerTag); }\r\n        Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\r\n        container.innerHTML = html;\r\n        const ret: T = container.firstChild as any;\r\n        if (ret) container.removeChild(ret);\r\n        return ret; }\r\n\r\n    public static levenshtein(a: string, b: string): number {\r\n        if (!a.length) return b.length;\r\n        if (!b.length) return a.length;\r\n        let cost = (a.charAt(a.length - 1) === b.charAt(b.length - 1)) ? 0 : 1;\r\n        return (window as any).Math.min(\r\n            U.levenshtein(a.substring(0, a.length - 1), b) + 1,\r\n            U.levenshtein(a, b.substring(0, b.length - 1)) + 1,\r\n            U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost,\r\n        );\r\n    }\r\n\r\n    public static getClosestPropertyName(names: string[], name: string): string {\r\n        let lowest = Infinity;\r\n        return names.reduce(function(previous, current) {\r\n            let distance = U.levenshtein(current, name);\r\n            if (distance < lowest) {\r\n                lowest = distance;\r\n                return current;\r\n            }\r\n            return previous;\r\n        }, '');\r\n    }\r\n    public static getClosestPropertyNames(names: string[], name: string): string[] {\r\n        let distances: {distance: number, value: string}[] = names.map( value => { return {distance: U.levenshtein(value, name), value}; });\r\n        return distances.sort( (a, b) => a.distance - b.distance).map( e => e.value);\r\n    }\r\n\r\n    //todo for console\r\n    public static autoCorrectProxy<T extends GObject>(target: T, recursive: boolean, logger: Console): ProxyHandler<T> {\r\n        return new Proxy(target, {\r\n            get: function(target, name) {\r\n                let namestr = U.asString(name, null);\r\n                if (!namestr) return undefined;\r\n                if (name in target) return target[namestr];\r\n                const suggestions: string[] = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\r\n                logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\r\n                return namestr && target[suggestions[0]];\r\n            },\r\n        });\r\n    }\r\n\r\n    static arrayRemoveAll<T>(arr: Array<T>, elem: T, debug: boolean = false): void {\r\n        let index;\r\n        if (!arr) return;\r\n        while (true) {\r\n            index = arr.indexOf(elem);\r\n            Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\r\n            if (index === -1) { return; }\r\n            arr.splice(index, 1);\r\n            Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\r\n        }\r\n    }\r\n\r\n    static arrayUnique<T>(arr: T[]): Array<T> { return [ ...new Set<T>(arr)]; }\r\n\r\n    static fileReadContent(file: File, callback: (content :string) => void): void {\r\n        const textType = /text.*/;\r\n        try { if (!file.type || file.type.match(textType)) {\r\n            let reader = new FileReader();\r\n            reader.onload = function(e) { callback( '' + reader.result ); };\r\n            reader.readAsText(file);\r\n            return;\r\n        } } catch(e) { Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file); }\r\n        Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file); }\r\n\r\n    static fileRead(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: string[] | FileReadTypeEnum[], readContent: boolean): void {\r\n        // $(document).on('change', (e) => console.log(e));\r\n        console.log(\"importEcore: pre file reader\");\r\n        myFileReader.show(onChange, extensions, readContent);\r\n    }\r\n\r\n    public static clear(htmlNode: Element): void {\r\n        if (htmlNode) while (htmlNode.firstChild) { htmlNode.removeChild(htmlNode.firstChild); }\r\n    }\r\n\r\n    static clearAllTimeouts(): void {\r\n        const highestTimeoutId: number = setTimeout(() => {}, 1) as any;\r\n        for (let i = 0 ; i < highestTimeoutId ; i++) { clearTimeout(i); }\r\n    }\r\n\r\n    static getStackTrace(sliceCalls: number = 2): string[] {\r\n        const ret: string | undefined = Error().stack;\r\n        // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\r\n        // if (Array.isArray(ret)) return ret;\r\n        if (!ret) return ['UnknownStackTrace'];\r\n        const arr: string[] = ret.split('\\n');\r\n        // first 2 entries are \"Erorr\" and \"getStackTrace()\"\r\n        return sliceCalls > 0 ? arr.slice( sliceCalls ) : arr; }\r\n\r\n    // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\r\n    public static getCaller(stacksToSkip: number = 0): string {\r\n        const stack: string[] = this.getStackTrace(4);\r\n        // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\r\n        return stack[stacksToSkip]; }\r\n\r\n    private static gotcalledby: Dictionary<string, boolean> = {};\r\n\r\n    // todo: use in Log.once\r\n    // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\r\n    public static isFirstTimeCalledByThisLine(stacksToSkip: number = 0): boolean {\r\n        const caller: string = this.getCaller(stacksToSkip);\r\n        if (U.gotcalledby[caller]) return false;\r\n        return U.gotcalledby[caller] = true; }\r\n\r\n    public static lineKey(): string { return this.getCaller(0); }\r\n\r\n    // Prevent the backspace key from navigating back.\r\n    static preventBackSlashHistoryNavigation(event: JQuery.KeyDownEvent): boolean {\r\n        if (!event || !event.key || event.key.toLowerCase() !== 'backspace') { return true; }\r\n        const types: string[] = ['text', 'password', 'file', 'search', 'email', 'number', 'date',\r\n            'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\r\n        const srcElement: JQuery<any> = $((event as any)['srcElement'] || event.target);\r\n        const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\r\n        if (!disabled) {\r\n            if (srcElement[0].isContentEditable || srcElement.is('textarea')) { return true; }\r\n            if (srcElement.is('input')) {\r\n                const type = srcElement.attr('type');\r\n                if (!type || types.indexOf(type.toLowerCase()) > -1) { return true; }\r\n            }\r\n        }\r\n        event.preventDefault();\r\n        return false; }\r\n\r\n    static SetMerge<T>(modifyFirst: boolean = true, ...iterables: Iterable<T>[]): Set<T> {\r\n        const set: Set<T> = modifyFirst ? iterables[0] as Set<T>: new Set<T>();\r\n        Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\r\n        for (let iterable of iterables) { for (let item of iterable) { set.add(item); } }\r\n        return set; }\r\n\r\n    // merge with unique elements\r\n    static ArrayMergeU(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(true, arr1, arr2); }\r\n    // merge without unique check\r\n    static ArrayMerge(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(false, arr1, arr2); }\r\n    // implementation\r\n    static ArrayMerge0(unique: boolean, arrtarget: any[], ...arrays: any[]): void {\r\n        if (!arrtarget || !arrays) return;\r\n\r\n        if (unique) { for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e); }\r\n        else { for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri); }\r\n    }\r\n\r\n    static ArrayAdd<T>(arr: Array<T>, elem: T, unique: boolean = true, throwIfContained: boolean = false): boolean {\r\n        Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\r\n        if (!unique) { arr.push(elem); return true; }\r\n        if (arr.indexOf(elem) === -1) { arr.push(elem); return true; }\r\n        Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\r\n        return false; }\r\n\r\n\r\n    private static maxID: number = 0;\r\n    public static idPrefix: string = '';\r\n    // static getID(): string { return U.idPrefix + U.maxID++; }\r\n    static getID: Generator<number> = function* idgenerator(): Generator<number> { let i: number = 0; while(true) yield i++; }();\r\n\r\n\r\n    static getType(param: any): string {\r\n        switch (typeof param) {\r\n            default: return typeof param;\r\n            case 'object':\r\n                return (param?.constructor as typeof RuntimeAccessibleClass)?.cname || param?.className || \"{_rawobject_}\";\r\n            case 'function': // and others\r\n                return \"geType for function todo: distinguish betweeen arrow and classic\";\r\n        }\r\n    }\r\n\r\n    static stringCompare(s1: string, s2: string): -1 | 0 | 1 { return (s1 < s2) ? -1 : (s1 > s2) ? 1 : 0; }\r\n\r\n    static endsWith(str: string, suffix: string | string[]): boolean {\r\n        if (Array.isArray(suffix)) {\r\n            for (let suf of suffix) {\r\n                if (U.endsWith(str, suf)) return true;\r\n            }\r\n            return false;\r\n        }\r\n        return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\r\n    }\r\n\r\n\r\n    static arrayMergeInPlace<T>(arr1: T[], ...otherArrs: T[][]): T[] {\r\n        for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\r\n        return arr1; }\r\n\r\n    static getEndingNumber(s: string, ignoreNonNumbers: boolean = false, allowDecimal: boolean = false): number {\r\n        let i = s.length;\r\n        let numberEnd = -1;\r\n        while (--i > 0) {\r\n            if (!isNaN(+s[i])) { if (numberEnd === -1) { numberEnd = i; } continue; }\r\n            if (s[i] === '.' && !allowDecimal) { break; }\r\n            if (s[i] === '.') { allowDecimal = false; continue; }\r\n            if (!ignoreNonNumbers) { break; }\r\n            if (numberEnd !== -1) { ignoreNonNumbers = false; }\r\n        }\r\n        s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\r\n        return +parseFloat(s); }\r\n\r\n    static increaseEndingNumber(s: string, allowLastNonNumberChars: boolean = false, allowDecimal: boolean = false, increaseWhile?: ((x: string) => boolean)): string {\r\n        let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\r\n        const matches: RegExpExecArray | null = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\r\n        // S flag removed for browser support (firefox), should work anyway.\r\n        let prefix: string;\r\n        let num: number;\r\n        if (!matches) {\r\n            prefix = s;\r\n            num = 2;\r\n        } else {\r\n            Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\r\n            let i = s.length - matches[0].length;\r\n            prefix = s.substring(0, i);\r\n            num = 1 + (+matches[1]);\r\n        }\r\n        if (increaseWhile) while (increaseWhile(prefix + num)) { num++; }\r\n        return prefix + num; }\r\n\r\n\r\n    public static shallowEqual(objA: GObject, objB: GObject): boolean {\r\n        if (objA === objB) { return true; }\r\n\r\n        if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') { return false; }\r\n\r\n        var keysA = Object.keys(objA);\r\n        var keysB = Object.keys(objB);\r\n        if (keysA.length !== keysB.length) return false;\r\n\r\n        // if (keysA.length !== keysB.length) { return false; }\r\n        // Test for A's keys different from B.\r\n        // var bHasOwnProperty = hasOwnProperty.bind(objB);\r\n        for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\r\n\r\n        // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\r\n        return true;\r\n    }\r\n\r\n    // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\r\n    static isNumber(o: any): o is number { return typeof o === \"number\" && !isNaN(o); }\r\n\r\n    public static getAllPrototypes(constructor: Constructor, chainoutoutrecursive: GObject[] = [], currentRecursion = 0, maxRecursion = 20, cache: boolean = true): GObject[] {\r\n        // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\r\n        if (cache && (constructor as any).__allprototypes) return (constructor as any).__allprototypes;\r\n        let prototype = (constructor.prototype?.name) && constructor.prototype;\r\n        let __proto__ = (constructor.__proto__?.name) && constructor.__proto__;\r\n        if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\r\n        if (prototype) chainoutoutrecursive.push(prototype);\r\n        if (__proto__) chainoutoutrecursive.push(__proto__);\r\n        if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (cache) (constructor as any).__allprototypes = chainoutoutrecursive;\r\n        return chainoutoutrecursive;\r\n    }\r\n\r\n    public static classIsExtending(subconstructor: Constructor | AbstractConstructor, superconstructor: Constructor | AbstractConstructor): boolean {\r\n        return (superconstructor as typeof DPointerTargetable)?._extends?.includes(subconstructor as any) || false;\r\n        // return U.getAllPrototypes(subconstructor).includes(superconstructor);\r\n    }\r\n\r\n    static isObject(v: GObject|any, returnIfNull: boolean = true, returnIfUndefined: boolean = false, retIfArray: boolean = false): boolean {\r\n        if (v === null) { return returnIfNull; }\r\n        if (v === undefined) { return returnIfUndefined; }\r\n        if (Array.isArray(v)) { return retIfArray; }\r\n        // nb: mind that typeof [] === 'object'\r\n        return typeof v === 'object'; }\r\n\r\n    static objectFromArray<V extends any>(arr: V[], getKey: (entry:V) => string): Dictionary<string, V>{\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => { acc[getKey(val)] = val; return acc; }, {});\r\n    }\r\n\r\n    static objectFromArrayValues<T extends any>(arr: (string | number)[], val: T = true as T): Dictionary<string | number, T> {\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => { acc[val] = val; return acc; }, {});\r\n        /*let ret: Dictionary = {};\r\n        for (let val of arr) { ret[val] = true; }\r\n        return ret;*/\r\n    }\r\n\r\n    static toBoolString(bool: boolean, ifNotBoolean: boolean = false): string { return bool === true ? 'true' : (bool === false ? 'false' : '' + ifNotBoolean); }\r\n    static fromBoolString<T extends any>(str: string | boolean): boolean;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T): boolean | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T, allowNull?: boolean): boolean | null | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal: T = false as any, allowNull: boolean = false, allowUndefined: boolean = false): boolean | null | undefined | T {\r\n        str = ('' + str).toLowerCase();\r\n        if (allowNull && (str === 'null')) return null;\r\n        if (allowUndefined && (str === 'undefined')) return undefined;\r\n\r\n        if (str === \"true\" || str === 't' || str === '1') return true;\r\n        // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\r\n        if (str === \"false\" || str === 'f' || str === '0') return false;\r\n        return defaultVal;\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} {\r\n        let ret: {added: T[], removed: T[], starting: T[], final: T[]} = {} as any;\r\n        ret.starting = starting;\r\n        ret.final = final;\r\n        if (!starting) starting = [];\r\n        if (!final) final = [];\r\n        ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\r\n        ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\r\n        return ret;\r\n    }\r\n\r\n    // returns <\"what changed from old to neww\"> and in nested objects recursively\r\n    // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\r\n    // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\r\n    public static objectDelta<T extends object>(old: T, neww: T, deep: boolean = true): Partial<T>{\r\n        let newwobj: GObject = neww;\r\n        let oldobj: GObject = old;\r\n        if (old === neww) return {};\r\n        let diff = U.objdiff(old, neww); // todo: optimize this, remove the 3 loops below and add those directly in U.objdiff(old, neww, ret); writing inside the obj in third parameter\r\n\r\n        let ret: GObject = {}; // {__isAdelta:true};\r\n        for (let key in diff.added) { ret[key] = newwobj[key]; }\r\n        for (let key in diff.changed) {\r\n            let subold = oldobj[key];\r\n            let subnew = newwobj[key];\r\n            if (typeof subold === typeof subnew && typeof subold === \"object\") { ret[key] = deep ? U.objectDelta(subold, subnew, true) : subnew; }\r\n            else ret[key] = subnew;\r\n        }\r\n        // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\r\n        let removedprefix = \"\"; // \"_-\";\r\n        for (let key in diff.removed) { ret[removedprefix + key] = undefined; } //newwobj[key]; }\r\n        // console.log(\"objdiff\", {old, neww, diff, ret});\r\n        return ret as Partial<T>;\r\n    }\r\n\r\n    // difference react-style. lazy check by === equality field by field. parameters are readonly\r\n    public static objdiff<T extends GObject>(old:T, neww: T): {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>} {\r\n        // let ret: GObject = {removed:{}, added:{}, changed:{}};\r\n        let ret: {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>}  = {removed:{}, added:{}, changed:{}, unchanged: {}};\r\n        if (!neww && !old) { return ret; }\r\n        if (!neww) { ret.removed = old; return ret; }\r\n        if (!old) { ret.added = neww; return ret; }\r\n        // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\r\n\r\n        let key: any;\r\n        for (key in old) {\r\n            // if (neww[key] === undefined){\r\n            // if neww have a key with undefined value, it counts (and should) as having that property key defined\r\n            if (!(key in neww)){ (ret.removed as GObject)[key] = old[key]; }\r\n            else if (neww[key] === old[key]) { (ret.unchanged as GObject)[key] = old[key] }\r\n            else (ret.changed as GObject)[key] = old[key];\r\n        }\r\n        for (let key in neww) {\r\n            if (!(key in old)){ (ret.added as GObject)[key] = neww[key]; }\r\n        }\r\n        return ret;\r\n    }\r\n    /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\r\n    public static flattenObjectToRoot(obj: GObject, prefix: string = '', pathseparator: string = '.'): GObject{\r\n        return Object.keys(obj).reduce((acc: GObject, k: string) => {\r\n            const pre = prefix.length ? prefix + pathseparator : '';\r\n            if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));\r\n            else acc[pre + k] = obj[k];\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\r\n    // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\r\n    // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\r\n    public static ObjectToAssignementStrings<R extends {str: string, fullstr: string, path:string[], fullpath:string[], val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\", out?:{best: R}&R[], quotestrings: boolean = true): {best: string}&string[] {\r\n        const pathseparator = \".\";\r\n        const valueseparator = \" = \";\r\n        const filterrow = (rowpaths: string[]) => { return (!rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\")); };\r\n        let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\r\n        let i = -1;\r\n        let tmp;\r\n        let ret: {best: string} & string[] = [] as GObject as {best: string} & string[];\r\n        tmp = (maxkeylength - toolongreplacer.length)/2;\r\n        let halfpath = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxvallength - toolongreplacer.length)/2;\r\n        let halfval = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxsubpaths - toolongreplacer.length)/2;\r\n        let halfsubpaths = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n\r\n\r\n        let bestpathsize = 0;\r\n        let best: R | null = null;\r\n        let countsize = (total: number, arrelem: string): number => total + arrelem.length;\r\n        const filterbest = (row: R) => {\r\n            row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\r\n            if (!best || bestpathsize < row.pathlength && filterrow(row.fullpath)) {\r\n                best = row; bestpathsize = row.pathlength;\r\n                if (out) out.best = best;\r\n                ret.best = best.str;\r\n            }\r\n        }\r\n        console.log(\"u get assignements\", {flatten, obj});\r\n\r\n        for (let key in flatten) {\r\n            let row: R = {fullpath: key.split(pathseparator), fullstr: key} as R;\r\n            // if (!filterrow(row.fullpath)) continue;\r\n            // stringify(undefined) = undefined, so i add + \"\"\r\n            try {\r\n                if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];\r\n                else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\r\n            } catch(e) { row.fullvalue = \"⁜not serializable⁜\"; }\r\n            // console.log(\"U get assignements loop\", {row, key, flatten, obj});\r\n            row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\r\n            if (row.fullpath.length > maxsubpaths) {\r\n                row.path = [...row.fullpath];\r\n                row.path.splice( halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\r\n            } else row.path = row.fullpath;\r\n\r\n            // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\r\n            row.path = row.path.map((p: string) => (p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end)));\r\n            if (out) { out.push(row); }\r\n            row.str = row.path.join(pathseparator) + valueseparator + row.val;\r\n            ret.push( row.str );\r\n            filterbest(row);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    static download(filename: string = 'nameless.txt', text: string = '', debug: boolean = true): void {\r\n        if (!text) { return; }\r\n        filename = U.toFileName(filename);\r\n        const htmla: HTMLAnchorElement = document.createElement('a');\r\n        const blob: Blob = new Blob([text], {type: 'text/plain', endings: 'native'});\r\n        const blobUrl: string = URL.createObjectURL(blob);\r\n        Log.l(debug, text + '|\\r\\n| <-- rn, |\\n| <--n.');\r\n        htmla.style.display = 'none';\r\n        htmla.href = blobUrl;\r\n        htmla.download = filename;\r\n        document.body.appendChild(htmla);\r\n        htmla.click();\r\n        window.URL.revokeObjectURL(blobUrl);\r\n        document.body.removeChild(htmla); }\r\n\r\n    static formatXml(xml: string): string {\r\n        const reg = /(>)\\s*(<)(\\/*)/g;\r\n        const wsexp = / *(.*) +\\n/g;\r\n        const contexp = /(<.+>)(.+\\n)/g;\r\n        xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\r\n        const pad: string = '' || '\\t';\r\n        let formatted = '';\r\n        const lines = xml.split('\\n');\r\n        let indent = 0;\r\n        let lastType = 'other';\r\n        // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\r\n        const transitions: GObject = {\r\n            'single->single': 0,\r\n            'single->closing': -1,\r\n            'single->opening': 0,\r\n            'single->other': 0,\r\n            'closing->single': 0,\r\n            'closing->closing': -1,\r\n            'closing->opening': 0,\r\n            'closing->other': 0,\r\n            'opening->single': 1,\r\n            'opening->closing': 0,\r\n            'opening->opening': 1,\r\n            'opening->other': 1,\r\n            'other->single': 0,\r\n            'other->closing': -1,\r\n            'other->opening': 0,\r\n            'other->other': 0\r\n        };\r\n        let i = 0;\r\n        for (i = 0; i < lines.length; i++) {\r\n            const ln = lines[i];\r\n\r\n            // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\r\n            if (ln.match(/\\s*<\\?xml/)) {\r\n                formatted += ln + '\\n';\r\n                continue;\r\n            }\r\n            // ---\r\n\r\n            const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\r\n            const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\r\n            const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\r\n            const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\r\n            const fromTo = lastType + '->' + type;\r\n            lastType = type;\r\n            let padding = '';\r\n\r\n            indent += transitions[fromTo];\r\n            let j: number;\r\n            for (j = 0; j < indent; j++) {\r\n                padding += pad;\r\n            }\r\n            if (fromTo === 'opening->closing') {\r\n                formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\r\n            } else {\r\n                formatted += padding + ln + '\\n';\r\n            }\r\n        }\r\n\r\n        return formatted.trim(); }\r\n\r\n\r\n    // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\r\n    static circularStringify(obj: GObject, replacer?: null | ((key: string, value: any) => any), space?: string | number, maxDepth_unsupported: number = 100): string {\r\n        const cache: any[] = [];\r\n        return JSON.stringify(obj, (key, value: any) => {\r\n            if (typeof value === 'object' && value !== null) {\r\n                // Duplicate reference found, discard key\r\n                if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                if (replacer){\r\n                    value = replacer(key, value);\r\n                    if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                }\r\n                // Store value in our collection\r\n                cache.push(value);\r\n            }\r\n            return value;\r\n        }, space);\r\n    }\r\n\r\n    static getFirstNumber(s: string, allowDecimalDot: boolean = true, allowDecimalComma: boolean = true, valueifmismatch: any = null): number {\r\n        let commamode = (allowDecimalComma ? (allowDecimalDot ?\"(\\\\.|\\\\,)\" : \"\\\\,\") : (allowDecimalDot ? \"\\\\.\" : \"will not use this regex\"));\r\n        let floatregex = new RegExp(\"-?\" + commamode  + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\r\n        let intregex = /-?\\d+/;\r\n        let ret: any;\r\n        if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);\r\n        else ret = intregex.exec(s);\r\n        ret = ret && ret[0]; // first match\r\n        if (ret === null) return valueifmismatch;\r\n\r\n        let tmpindex:number;\r\n        if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\r\n        // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\r\n        while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex+1) // ret.indexOf(.)\r\n        // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\r\n        return +ret;\r\n    }\r\n\r\n    // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\r\n    public static isEmptyObject(obj: GObject | undefined): boolean {\r\n        for(var i in obj) return false;\r\n        return true;\r\n    }\r\n\r\n    private static pairArrayElementsRepeatFunc<T>(val: T, index: number, arr:T[]): T[]{ return [arr[index], arr[index+1]] }\r\n    private static pairArrayElementsReducerFunc<T>(accumulator: T[][], value: T, index: number, array: T[]):T[][] {\r\n        if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\r\n        return accumulator; }\r\n\r\n    // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\r\n    // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\r\n    public static pairArrayElements<T>(arr:T[], withRepetitions:boolean = false):T[][] {\r\n        if (withRepetitions) { return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length-1); }\r\n        return arr.reduce( U.pairArrayElementsReducerFunc as ((accumulator: T[][], value: T, index: number, array: T[]) => T[][]), []); }\r\n\r\n    // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\r\n    public static decomment_all(str: string): string { return this.decomment_line(this.decomment_block(str)); }\r\n    // removes line comments //\r\n    public static decomment_line(str: string, trimLines: boolean = true): string {\r\n        return str\r\n            .split(\"\\n\")\r\n            .map(s=> { let i = s.indexOf(\"//\"); s = (i === -1 ? s : s.substring(i)); return trimLines ? s.trim() : s; } )\r\n            .join(\"\\n\");\r\n    }\r\n    // removes block comments /**/\r\n    public static decomment_block(str: string): string {\r\n        // let maxcomments = 100;\r\n        while(true){\r\n            // if (--maxcomments===0) break;\r\n            let s: number = str.indexOf(\"/*\");\r\n            if (s === -1) break;\r\n            let e: number = str.indexOf(\"*/\", s+1);\r\n            if (e === -1) e = str.length;\r\n            str = str.substring(0, s) + str.substring(e+2);\r\n        }\r\n        return str; }\r\n\r\n    static uppercaseFirstLetter<T extends (string | GObject<\"jsx\">)>(str: T): T {\r\n        if (typeof str !== \"string\") return str;\r\n        return str.charAt(0).toUpperCase() + str.slice(1) as T;\r\n    }\r\n\r\n    // CAREFUL! it's imperfect.\r\n    // Does not handle strings starting with ( that are not ()=> arrow functions\r\n    // or codes whose last chars are () but not in (function)() form\r\n    static wrapUserFunction(str: string): string {\r\n        str = str.trim();\r\n        if (str[0]!=='(' || str.indexOf(\"function\") !== 0) {\r\n            str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\r\n        }\r\n        if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\r\n        return str;\r\n    }\r\n\r\n    // adds ellipsis in the middle of a string to truncate it when it's too long.\r\n    public static stringMiddleCut<T extends boolean | undefined, RET extends string | string[] = T extends true ? string[] : string>\r\n    (str: string, maxLength: number, ellipsisChar: string = '…', asArray?: T): RET{\r\n        if (!str as unknown || maxLength < 0 || str.length <= maxLength) return (asArray ? [str] : str) as RET;\r\n        var midpoint = Math.ceil(str.length / 2);\r\n        var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\r\n        var lstrip = Math.ceil(toremove/2); // left strip is the bigger one if odd chars\r\n        var rstrip = toremove - lstrip;\r\n        if (asArray) return [str.substring(0, midpoint-lstrip), ellipsisChar, str.substring(midpoint+rstrip)] as RET;\r\n        else return str.substring(0, midpoint-lstrip) + ellipsisChar + str.substring(midpoint+rstrip) as RET;\r\n    }\r\n\r\n    // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\r\n    public static invertHex(s: string, prefix: string='#', transformGrays: number = 0.2): string {\r\n        if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\r\n        let r: number, g: number, b: number, h: number | undefined; // might be NaN if parseInt fails\r\n        if (s.length === 3 || s.length === 4) {\r\n            r = parseInt('0x'+s[0]);// works with hex numbers\r\n            g = parseInt('0x'+s[1]);\r\n            b = parseInt('0x'+s[2]);\r\n            h = s.length === 4 ? parseInt('0x'+s[4]) : undefined;\r\n        } else if (s.length === 6 || s.length === 8){\r\n            r = parseInt('0x'+s.substring(0, 2));\r\n            g = parseInt('0x'+s.substring(2, 4));\r\n            b = parseInt('0x'+s.substring(4, 6));\r\n            h = s.length === 8 ? parseInt('0x'+s.substring(6, 8)) : undefined;\r\n        } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {s});\r\n        if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s +\", invalid red\", {s});\r\n        if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s +\", invalid green\", {g});\r\n        if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s +\", invalid blue\", {b});\r\n\r\n        transformGrays = transformGrays * 128;\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (h || h === 0) h = 255 - h;\r\n\r\n        let rs = r.toString(16);\r\n        if (rs.length === 1) rs = '0'+rs;\r\n        let gs = g.toString(16);\r\n        if (gs.length === 1) gs = '0'+gs;\r\n        let bs = b.toString(16);\r\n        if (bs.length === 1) bs = '0'+bs;\r\n        let hs = h ? h.toString(16) : '';\r\n        if (hs.length === 1) hs = '0'+hs;\r\n\r\n        return (prefix) + rs+gs+bs+hs;\r\n    }\r\n\r\n    public static parentUntil(tagName: string, p: Element | null): Element | null {\r\n        while (p && p.tagName !== tagName) p = p.parentElement;\r\n        return p;\r\n    }\r\n\r\n    static paletteSplit(palette: Readonly<PaletteType>): {\r\n        color: Dictionary<string, PaletteControl>,\r\n        number: Dictionary<string, NumberControl>,\r\n        text: Dictionary<string, StringControl>,\r\n        path: Dictionary<string, PathControl>,\r\n    } {\r\n        type clist = PaletteControl | NumberControl | StringControl | PathControl;\r\n        let ret = {\r\n            color: {} as Dictionary<string, PaletteControl>,\r\n            number: {} as Dictionary<string, NumberControl>,\r\n            text: {} as Dictionary<string, StringControl>,\r\n            path: {} as Dictionary<string, PathControl>,\r\n        } as Dictionary<(clist)[\"type\"], Dictionary<string, any>>;\r\n        for (let entry of Object.entries(palette)) {\r\n            let k = entry[0];\r\n            let v = entry[1];\r\n            ret[(v as clist).type][k] = v;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static mergeNamedArray<T extends GObject>(ret: T[] & Dictionary<DocString<\"$name\">, T>, classes: T[] & Dictionary<DocString<\"$name\">, T>) {\r\n        for (let key of Object.getOwnPropertyNames(classes)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (key === \"length\") continue;\r\n            if (!isNaN(+key)) ret.push(classes[key]);\r\n            // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\r\n            if (!ret[key]) ret[key] = classes[key];\r\n        }\r\n    }\r\n\r\n    private static prefix = 'ULibrary_';\r\n    private static clipboardinput: HTMLInputElement;\r\n    static async clipboardCopy<T>(text: string, onSuccess:()=>T, onFailure:()=>T): Promise<T> {\r\n        let ret: boolean = false;\r\n        return navigator.clipboard.writeText(text).then(() => {\r\n            ret = true;\r\n            return onSuccess();\r\n        },() => {\r\n            ret = U.clipboardCopy_old(text);\r\n            return ret ? onSuccess() : onFailure();\r\n        });\r\n    }\r\n    static clipboardCopy_old(text: string): boolean {\r\n        try{\r\n        if (!U.clipboardinput) {\r\n            U.clipboardinput = document.createElement('input');\r\n            U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\r\n            U.clipboardinput.type = 'text';\r\n            U.clipboardinput.style.display = 'block';\r\n            U.clipboardinput.style.position = 'absolute';\r\n            U.clipboardinput.style.top = '-100vh'; }\r\n        document.body.appendChild(U.clipboardinput);\r\n        U.clipboardinput.value = text;\r\n        U.clipboardinput.select();\r\n        if (!document.execCommand) return false;\r\n        let ret = document.execCommand('copy');\r\n        document.body.removeChild(U.clipboardinput);\r\n        U.clearSelection();\r\n        return ret;\r\n        }\r\n        catch(e){ return false; }\r\n    }\r\n\r\n    static clearSelection() {}\r\n\r\n    static toNamedArray<D extends DPointerTargetable, L extends LPointerTargetable>(larr:L[], darr?:D[]): L[] & Dictionary<DocString<\"$name\">, L>{\r\n        if (!darr || darr.length !== larr.length) darr = larr.map(l=>l.__raw as D);\r\n\r\n        for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) (larr as GObject)[\"$\"+(darr[i] as GObject).name] = larr[i];\r\n        /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (index === \"length\") continue;\r\n            let d = darr[index as any as number];\r\n            let l = larr[index as any as number];\r\n            if (!d || !l) continue;\r\n            (larr as any)[\"$\" + (d as any).name] = l;\r\n        }*/\r\n        return larr as any;\r\n    }\r\n}\r\nexport class DDate{\r\n    static cname: string = \"DDate\";\r\n\r\n    public static addDay(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setDate(date.getDate() + offset);\r\n        return ret;\r\n    }\r\n    public static addMonth(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setMonth(date.getMonth() + offset);\r\n        return ret;\r\n    }\r\n    public static addYear(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setFullYear(date.getFullYear() + offset);\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class myFileReader {\r\n    private static input: HTMLInputElement = null as any;\r\n    private static fileTypes: string[] = null as any;\r\n    private static onchange: (e: Event) => void = null as any;\r\n    // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\r\n    private static setinfos(fileTypes: undefined | FileReadTypeEnum[] | string[], onchange: (e: Event, files: FileList | null, contents: string[] | undefined ) => void, readcontent: boolean) {\r\n        myFileReader.fileTypes = (fileTypes || myFileReader.fileTypes) as string[];\r\n        const debug: boolean = false;\r\n        debug&&console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\r\n        myFileReader.input = document.createElement('input');\r\n        const input: HTMLInputElement = myFileReader.input;\r\n        myFileReader.onchange = function (e: Event): void {\r\n            if (!readcontent) { onchange(e, input.files, undefined); return; }\r\n            let contentObj: Dictionary<number, string> = {};\r\n            let fileLetti: number = 0;\r\n            for (let i: number = 0; input.files && i <input.files.length; i++) {\r\n                const f: File = input.files[i];\r\n                debug&&console.log('filereadContent['+i+']( file:', f, ')');\r\n                U.fileReadContent(f, (content: string) => {\r\n                    debug&&console.log('file['+i+'] read complete. done: ' + ( 1 + fileLetti) + ' / ' + input.files?.length, 'contentObj:', contentObj);\r\n                    contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\r\n                    // this is last file to read.\r\n                    if (input.files && ++fileLetti === input.files.length) {\r\n                        const contentArr: string[] = [];\r\n                        for (let j: number = 0; j < input.files.length; j++) { contentArr.push(contentObj[j]); }\r\n                        onchange(e, input.files, contentArr);\r\n                    }\r\n                });\r\n            }\r\n        } || myFileReader.onchange;\r\n    }\r\n    private static reset(): void {\r\n        myFileReader.fileTypes = undefined as any;\r\n        myFileReader.onchange = undefined as any;\r\n        myFileReader.input = undefined as any;\r\n    }\r\n    public static show(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: undefined | string[] | FileReadTypeEnum[] = undefined, readContent: boolean): void {\r\n        console.log(\"importEcore: pre file reader\", myFileReader.input);\r\n        myFileReader.setinfos(extensions, onChange, readContent);\r\n        //if (!myFileReader.input) return;\r\n        myFileReader.input.setAttribute('type', 'file');\r\n        if (myFileReader.fileTypes) {\r\n            myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\r\n        }\r\n        //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\r\n        $(myFileReader.input).on('change.custom' as any, myFileReader.onchange).trigger('click');\r\n        myFileReader.reset();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('Uarr')\r\nexport class Uarr{\r\n    public static arrayIntersection<T>(arr1: T[], arr2: T[]): T[]{\r\n        if (!arr1 || ! arr2) return null as any;\r\n        return arr1.filter( e => arr2.indexOf(e) >= 0);\r\n    }\r\n\r\n    static arraySubtract(arr1: any[], arr2: any[], inPlace: boolean): any[]{\r\n        let i: number;\r\n        const ret: any[] = inPlace ? arr1 : [...arr1];\r\n        for (i = 0; i < arr2.length; i++) { U.arrayRemoveAll(ret, arr2[i]); }\r\n        return ret; }\r\n\r\n    static equals<T extends any>(a1: T[], a2: T[], deep: boolean): boolean {\r\n        Log.ex(deep, \"deep array comparison is not supported yet\");\r\n        if (!a1 || !a2) return false;\r\n        if (a1.length !== a2.length) return false;\r\n        for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\r\n        return true;\r\n    }\r\n}\r\n\r\nexport class FocusHistoryEntry {\r\n    static cname: string = \"FocusHistoryEntry\";\r\n    time: Date;\r\n    evt: JQuery.FocusInEvent;\r\n    element: Element;\r\n    constructor(e: JQuery.FocusInEvent, element?: Element, time?: Date) {\r\n        this.evt = e;\r\n        this.element = element || e.target;\r\n        this.time = time || new Date();\r\n    }\r\n}\r\nexport enum ShortDefaultEClasses{\r\n    EObject = \"EObject\",\r\n    EAnnotation = \"EAnnotation\",\r\n    EClass = \"EClass\",\r\n    EPackage = \"EPackage\",\r\n    ENamedElement = \"ENamedElement\",\r\n}\r\nexport enum ShortAttribETypes {\r\n    EVoid = 'EVoid',\r\n    EChar  = 'EChar',\r\n    EString  = 'EString',\r\n    EDate  = 'EDate',\r\n    EBoolean = 'EBoolean',\r\n    EByte  = 'EByte',\r\n    EShort  = 'EShort',\r\n    EInt  = 'EInt',\r\n    ELong  = 'ELong',\r\n    EFloat  = 'EFloat',\r\n    EDouble  = 'EDouble',\r\n    // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    /*\r\n  ECharObj  = 'ECharObj',\r\n  EStringObj  = 'EStringObj',\r\n  EDateObj  = 'EDateObj',\r\n  EFloatObj  = 'EFloatObj',\r\n  EDoubleObj  = 'EDoubleObj',\r\n  EBooleanObj = 'EBooleanObj',\r\n  EByteObj  = 'EByteObj',\r\n  EShortObj  = 'EShortObj',\r\n  EIntObj  = 'EIntObj',\r\n  ELongObj  = 'ELongObj',\r\n  EELIST  = 'EELIST',*/\r\n\r\n}\r\nwindoww.ShortAttribETypes = ShortAttribETypes;\r\n\r\nexport const ShortAttribSuperTypes: Dictionary<ShortAttribETypes, ShortAttribETypes[]> = {\r\n    \"EVoid\"    : [],\r\n    \"EChar\"    : [ShortAttribETypes.EString],\r\n    \"EString\"  : [],\r\n    \"EDate\"    : [],\r\n    \"EBoolean\" : [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EByte\"    : [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EShort\"   : [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EInt\"     : [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"ELong\"    : [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EFloat\"   : [ShortAttribETypes.EDouble],\r\n    \"EDouble\"  : []\r\n};\r\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\r\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\r\nexport function toShortEType(a: AttribETypes): ShortAttribETypes{ return a.substring(ecoreprefix.length) as any; }\r\nexport function toLongEType(a: ShortAttribETypes): AttribETypes {\r\n    return AttribETypes[a];\r\n    // return ecoreprefix + a as any;\r\n}\r\n\r\nexport function toShortEClass(a: DefaultEClasses): ShortDefaultEClasses{ return a.substring(ecoreclasprefix.length) as any; }\r\nexport function toLongEClass(a: ShortDefaultEClasses): DefaultEClasses { return DefaultEClasses[a]; }\r\n\r\nexport class SelectorOutput {\r\n    jqselector!: string;\r\n    attrselector!: string;\r\n    attrRegex!: RegExp;\r\n    exception!: any;\r\n    resultSetAttr!: Attr[];\r\n    resultSetElem!: JQuery<Element>;\r\n}\r\n// compare it with event.key\r\nexport enum Keystrokes {\r\n    clickLeft = 0,\r\n    clickWheel = 1,\r\n    clickRight = 2,\r\n    clickBackMouseButton = 3,\r\n    clickForwardMouseButton = 4,\r\n\r\n    // keyboard\r\n    escape = 'Escape',\r\n    capsLock = 'CapsLock',\r\n    shift = 'Shift',\r\n    tab = 'Tab',\r\n    alt = 'Alt',\r\n    control = 'Control',\r\n    end = 'End',\r\n    home = 'Home',\r\n    pageUp = 'PageUp',\r\n    pageDown = 'PageDown',\r\n    enter = 'Enter', // event.code = 'NumpadEnter' se fatto da numpad, oppure \"numpad3\", \"NumpadMultiply\", ShiftLeft, etc...\r\n    numpadEnter = 'NumpadEnter',\r\n    audioVolumeMute = 'AudioVolumeMute',\r\n    audioVolumeUp = 'AudioVolumeUp',\r\n    audioVolumeDown = 'AudioVolumeDown',\r\n    mediaTrackPrevious = 'MediaTrackPrevious',\r\n    delete = 'Delete', // canc\r\n    backspace = 'Backspace',\r\n    space = ' ',\r\n    altGraph = 'AltGraph',\r\n    arrowLeft = 'ArrowLeft',\r\n    arrowRight = 'ArrowRight',\r\n    arrowUp = 'ArrowUp',\r\n    arrowDown = 'ArrowDown',\r\n    insert = 'Insert',\r\n    f1 = 'F1',\r\n    // weird ones:\r\n    meta = 'Meta', // f1, or other f's with custom binding and windows key\r\n    unidentified = 'Unidentified', // brightness\r\n    __NotReacting__ = 'fn, print, maybe others', // not even triggering event?\r\n}\r\n\r\nexport enum DefaultEClasses{\r\n    EObject = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\",\r\n    EAnnotation = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\",\r\n    EClass = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\",\r\n    EPackage = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\",\r\n    ENamedElement = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\",\r\n}\r\nexport enum AttribETypes {\r\n    EVoid = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid', // ??? i invented this.\r\n    EChar = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar',\r\n    EString = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString',\r\n    EDate = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate',\r\n    EFloat = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat',\r\n    EDouble = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble',\r\n    EBoolean = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',\r\n    EByte = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte',\r\n    EShort = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort',\r\n    EInt = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt',\r\n    ELong = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong',\r\n    // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    // EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\r\n    /*\r\n  ECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\n  EStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\n  EDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\n  EFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\n  EDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\n  EBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\n  EByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\n  EShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\n  EIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\n  ELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\r\n    // EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\r\n}\r\n\r\n// export type Json = object;\r\n\r\nexport class ParseNumberOrBooleanOptions{\r\n    defaultValue?: any;\r\n    allowNull?: boolean; nullValue?: any;\r\n    allowUndefined?: boolean; undefinedValue?: any;\r\n    allowedNan?: boolean; nanValue?: any;\r\n    allowBooleans?: boolean; trueValue?: any; falseValue?: any;\r\n    constructor(\r\n        defaultValue: any = null, allowNull: boolean = false, nullValue: any = null,\r\n        allowUndefined: boolean = false, undefinedValue: any = undefined,\r\n        allowedNan: boolean = false, nanValue: any = NaN,\r\n        allowBooleans: boolean = true, trueValue : any = 1, falseValue: any = 0) {\r\n        this.defaultValue = defaultValue; this.allowNull = allowNull; this.nullValue = nullValue;\r\n        this.allowUndefined = allowUndefined; this.undefinedValue = undefinedValue;\r\n        this.allowedNan = allowedNan; this.nanValue = nanValue;\r\n        this.allowBooleans = allowBooleans; this.trueValue = trueValue; this.falseValue = falseValue;\r\n    }\r\n}\r\nexport type LoggerType = \"l\" | \"i\" | \"w\" | \"e\" | \"ex\" | \"eDev\" | \"exDev\";\r\nexport class LoggerCategoryState{\r\n    category: LoggerType;\r\n    time: number;\r\n    raw_args: any[];\r\n    short_string: string;\r\n    long_string: string;\r\n    constructor(args: any[], short_string: string, cat: LoggerType) {\r\n        this.raw_args = args;\r\n        this.time = new Date().getTime();\r\n        this.category = cat;\r\n        this.short_string = short_string;\r\n        this.long_string = '';\r\n\r\n        const maxChars: Dictionary<string, [number, number]> = {\r\n            function: [50, 0],\r\n            object: [100, 0],\r\n            string: [80, 20],\r\n        }\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) {\r\n            (window as any).ansiconvert = ansiConvert = new Convert();\r\n        }\r\n        for (let a of args){\r\n            let s: string;\r\n            let ta: string = typeof a;\r\n            switch(ta){\r\n                case \"function\": s = a.toString(); break;\r\n                case \"object\":\r\n                    let outstr = U.inspect(a, true, 2, true);\r\n                    outstr = U.replaceAll(ansiConvert.toHtml(outstr), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n                    let regexpCloseTags = new RegExp(\"(\\\\<span style\\\\=\\\"color\\\\:\\\\#)\", \"gm\");\r\n                    outstr = U.replaceAll( outstr, \"$\", \"£\");\r\n                    outstr = outstr.replace(regexpCloseTags,  \"</span>$1\");\r\n                    outstr = U.replaceAll(outstr, \"£\", \"$\");\r\n                    s = outstr;\r\n                    break;\r\n                default: s = ''+a;\r\n            }\r\n            if (maxChars[ta]) s = U.cropStr(s, maxChars[ta][0], maxChars[ta][1]);\r\n            this.long_string += s;\r\n        }\r\n    }\r\n}\r\n@RuntimeAccessible('Log')\r\nexport class Log{\r\n    // public static history: Dictionary<string, Dictionary<string, any[]>> = {}; // history['pe']['key'] = ...parameters\r\n    public static lastError: any[];/*\r\n    public static last_e: LoggerCategoryState[] = [];\r\n    public static last_eDev: LoggerCategoryState[] = [];\r\n    public static last_ex: LoggerCategoryState[] = [];\r\n    public static last_exDev: LoggerCategoryState[] = [];\r\n    public static last_w: LoggerCategoryState[] = [];\r\n    public static last_i: LoggerCategoryState[] = [];*/\r\n    // private static loggerMapping: Dictionary<string, LoggerInterface[]> = {} // takes function name returns logger list\r\n    private static messageMapping: Dictionary<LoggerType, LoggerCategoryState[]> = {\r\n        l: [],\r\n        i: [],\r\n        w: [],\r\n        e: [],\r\n        ex: [],\r\n        eDev: [],\r\n        exDev: [],\r\n    } // takes function name returns log messages list\r\n\r\n\r\n/*\r\n    public static registerLogger(logger: LoggerInterface, triggerAt: (typeof windoww.U.pe) & {name: string, cname:string}) {\r\n        let tname: string = (triggerAt as any).cname || (triggerAt as any).name;\r\n        if (!Log.loggerMapping[tname]) Log.loggerMapping[tname] = [];\r\n        Log.loggerMapping[tname].push(logger);\r\n    }*/\r\n\r\n    static disableConsole(){\r\n        // @ts-ignore\r\n        console['logg'] = console.log;\r\n        console.log = () => {}; }\r\n\r\n    static enableConsole() {\r\n        // @ts-ignore\r\n        if (console['logg']) console.log = console['logg']; }\r\n\r\n    private static log(prefix: string, category: LoggerType, originalFunc: typeof console.log, b: boolean, ...restArgs: any[]): string {\r\n        if (!b) { return ''; }\r\n        const key: string = windoww.U.getCaller(1); // todo: remove replace heavy fumc\r\n        if (restArgs === null || restArgs === undefined) { restArgs = []; }\r\n        let str = key + ': ';\r\n        for (let i = 0; i < restArgs.length; i++) {\r\n            // console.log(prefix, {i, restArgs, curr:restArgs[i]});\r\n            str += '' +\r\n                (typeof restArgs[i] === 'symbol' ?\r\n                    '' + String(restArgs[i]) :\r\n                    restArgs[i])\r\n                + '\\t\\r\\n'; }\r\n        Log.updateLoggerComponent(category, restArgs, str, category);\r\n        // merged loggers if (Log.loggerMapping[category]) for (const logger of Log.loggerMapping[category]) { logger.log(category, key, restArgs, str); }\r\n        originalFunc(key, ...restArgs);\r\n        return '[' + prefix + ']' + str; }\r\n\r\n    public static e(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        const str = Log.log('Error', 'e', console.error, b, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        return str;\r\n        // throw new Error(str);\r\n    }\r\n\r\n    public static eDev(b: boolean, ...restArgs: any[]): string {\r\n        if (!b) return '';\r\n        const str = Log.log('Dev Error','eDev', console.error, b, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        return str;\r\n        // throw new Error(str);\r\n    }\r\n\r\n    public static ex(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        const str = Log.log('Error', 'e', console.error, b, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        throw new MyError(str, ...restArgs); }\r\n\r\n    public static exDev(b: boolean, ...restArgs: any[]): null | never | any {\r\n        if (!b) return null;\r\n        const str = Log.log('Dev Error','eDev', console.error, b, ...restArgs);\r\n        Log.lastError = restArgs;\r\n        windoww.ee = restArgs;\r\n        windoww.e1 = restArgs[1];\r\n        throw new MyError(str, ...restArgs); }\r\n\r\n    public static i(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Info', 'i', console.log, b, ...restArgs);\r\n    }\r\n    public static _loggerComponent: any = undefined as any;\r\n    private static get_loggercomponent(): any { return Log._loggerComponent; }\r\n    private static updateLoggerComponent(type: LoggerType, args: any[], short_str: string, cat: LoggerType): void {\r\n        let c = Log.get_loggercomponent();\r\n        let update: LoggerCategoryState = new LoggerCategoryState(args, short_str, cat);\r\n        Log.messageMapping[type].push(update);\r\n        // (Log as GObject)[\"last_\"+type].push(args);\r\n        if (!c) return;\r\n        c.setState({[type+\"_counter\"]: c.state[type+\"_counter\"]++}); // so it doesn't pass through redux\r\n    }\r\n    public static l(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Log', 'l', console.log, b, ...restArgs);\r\n    }\r\n    public static w(b: boolean, ...restArgs: any[]): string | null {\r\n        if (!b) return null;\r\n        return Log.log('Warn', 'w', console.warn, b, ...restArgs); }\r\n\r\n\r\n    public static eDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): string { return Log.eDev(true, ...[firstParam, ...restAgs]); }\r\n    public static ee(...restAgs: any): string { return Log.e(true, ...restAgs); }\r\n    public static exDevv<T extends any = any>(firstParam?: NotBool<T>, ...restAgs: any): never | any { return Log.exDev(true, ...[firstParam, ...restAgs]); }\r\n    public static exx(...restAgs: any): never | any { return Log.ex(true, ...restAgs); }\r\n    public static ii(...restAgs: any): string { return Log.i(true, ...restAgs) as string; }\r\n    public static ll(...restAgs: any): string { return Log.l(true, ...restAgs) as string; }\r\n    public static ww(...restAgs: any): string { return Log.w(true, ...restAgs) as string; }\r\n}\r\n\r\ntype NotBool<T> = Exclude<T, boolean>;\r\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\r\n\r\n\r\n\r\nexport class FileReadTypeEnum {\r\n    public static image: FileReadTypeEnum = \"image/*\" as any;\r\n    public static audio: FileReadTypeEnum = \"audio/*\" as any;\r\n    public static video: FileReadTypeEnum = \"video/*\" as any;\r\n    /// a too much huge list https://www.iana.org/assignments/media-types/media-types.xhtml\r\n    public static AndManyOthersButThereAreTooMuch: string = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\r\n    public static OrJustPutFileExtension: string = \"OrJustPutFileExtension\";\r\n}\r\n\r\n// console.info('loaded ts U');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}