{"ast":null,"code":"var _dec, _class, _class2, _dec2, _class3, _class4, _dec3, _class5, _class6, _dec4, _class7, _class8, _dec5, _class9, _class10, _dec6, _class11, _class12, _dec7, _class13, _class14, _dec8, _class15, _class16, _dec9, _class17, _class18, _dec10, _class19, _class20, _dec11, _class21;\nimport { Constructors, DUser, Log, Pointers, RuntimeAccessible, RuntimeAccessibleClass, store, windoww } from \"../../joiner\";\n\n// transactional-like start of storage modification\n// todo: nested transaction che conti quanti begin hai effettuato e crei una matrice di pendingActions una per ogni livello nested?\n\n/*\r\n// let nestedlevel: number = 0;\r\nclass NestedLevel{\r\n    level: number;\r\n    actions: Action[] = [];\r\n    up:NestedLevel[] = [];\r\n    down?:NestedLevel;\r\n\r\n    constructor(prevLevel?: NestedLevel, actions: Action[] = []) {\r\n        // this.prev = prev;\r\n        this.down = prevLevel;\r\n        this.actions = actions;\r\n        this.level = prevLevel ? prevLevel.level + 1 : 0;\r\n    }\r\n\r\n    add1(a:Action){ this.actions.push(a); }\r\n    add(a:Action[]){ this.actions.push(...a); }\r\n    push(actions:Action[]=[]){\r\n        this.up.push(new NestedLevel(this, actions));\r\n    }\r\n}\r\n// @Singleton\r\nclass NestedTransactionManager{\r\n    // private levels: NestedLevel[] = [];\r\n    public currentLevel?: NestedLevel;\r\n    // simple array is not good i can have spikes as russian mountains going up and down in deepness it's kinda a matrix or a pile of dishes like below'\r\n\r\n\r\n    /*\r\n    todo: to debug missing END paired with a begin, seve stack trace of begins and ends\r\n    * every level must have his own array?\r\n    * Begin0, Begin1, Begin2, End2, End1, Begin1.1 Begin 1.2....\r\n    it's a tree!\r\n    *\r\n    *\r\n    * ______begin lv2                              _______Begin1.2\r\n    * _________________________begin lv1           ___________________Begin1.1\r\n    * ____________________________________________________________________________________________________ a begin lv0\r\n    * * /\r\n    constructor() {}\r\n    begin(actions: Action[]=[]): void { this.pushLevel(actions); }\r\n    pushLevel(actions: Action[]=[]): void {\r\n        if (!this.currentLevel) { this.currentLevel = new NestedLevel(undefined, actions); return; }\r\n        this.currentLevel.push(actions); }\r\n    end(){\r\n        if (!this.currentLevel) return this.finalEnd();\r\n        this.currentLevel = this.currentLevel?.down; }\r\n    finalEnd(){\r\n\r\n    }\r\n    // current(): NestedLevel { return this.currentLevel; }\r\n    addActions(a:Action[]): void { this.currentLevel!.add(a); }\r\n    addAction(a:Action): void { this.currentLevel!.add1(a); }\r\n}\r\nlet transactionmanager = new NestedTransactionManager();\r\nfunction BEGIN2(){\r\n    transactionmanager.pushLevel();\r\n}\r\nfunction ABORT2(){\r\n    transactionmanager.end();\r\n}\r\nfunction END2(){\r\n\r\n}*/\n\nclass TransactionStatus {\n  constructor() {\n    this.pendingActions = [];\n    this.hasBegun = false;\n    this.hasAborted = false;\n    this.transactionDepthLevel = 0;\n  }\n}\nlet t = new TransactionStatus();\nwindoww.transactionStatus = t;\nexport function BEGIN() {\n  if (t.transactionDepthLevel === 0) t.hasAborted = false;\n  t.hasBegun = true; // redundant but actions are reading this, minimize changes\n  t.transactionDepthLevel++;\n}\n_c = BEGIN;\nexport function ABORT() {\n  let ret = t.transactionDepthLevel > 0;\n  t.hasAborted = true; // at any depth level since i have only a flat TRANSACTION array\n  END();\n  return ret;\n}\n// if without parameter: commits the current pending stuff, with parameter: fires the action ignoring transaction block while keeping te transaction active\n_c2 = ABORT;\nexport function COMMIT(action) {\n  let olddepth = t.transactionDepthLevel;\n  if (olddepth <= 0) {\n    END(); //just safety to restore has begun state, should be necessary.\n    return false;\n  }\n  t.transactionDepthLevel = 1;\n  END();\n  t.transactionDepthLevel = olddepth - 1;\n  BEGIN();\n  return true;\n}\n_c3 = COMMIT;\nexport function END() {\n  let actionstoPrepend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let path = arguments.length > 1 ? arguments[1] : undefined;\n  let oldval = arguments.length > 2 ? arguments[2] : undefined;\n  let newval = arguments.length > 3 ? arguments[3] : undefined;\n  let desc = arguments.length > 4 ? arguments[4] : undefined;\n  t.transactionDepthLevel--;\n  if (actionstoPrepend.length) t.pendingActions = [...actionstoPrepend, ...t.pendingActions];\n  if (t.transactionDepthLevel < 0) {\n    console.error(\"mismatching END()\");\n    t.transactionDepthLevel = 0;\n  }\n  if (t.transactionDepthLevel === 0) return FINAL_END(path, oldval, newval, desc);\n  return false;\n}\n_c4 = END;\nfunction FINAL_END(path, oldval, newval, desc) {\n  t.hasBegun = false;\n  // pendingActions.sort( (a, b) => a.timestamp - b.timestamp)\n  if (t.hasAborted) {\n    t.pendingActions = [];\n    t.hasAborted = false;\n    return false;\n  }\n  const ca = new CompositeAction(t.pendingActions, false);\n  if (lastDescription) {\n    path = lastDescription.name;\n    oldval = lastDescription.oldval;\n    newval = lastDescription.newval;\n    desc = lastDescription.desc;\n    lastDescription = undefined;\n  }\n  if (path) ca.descriptor = new ActionDescriptor(path, oldval, newval, desc);\n  t.pendingActions = [];\n  return ca.fire();\n}\n_c5 = FINAL_END;\nexport class ActionDescriptor {\n  constructor(path, oldval, newval, desc) {\n    this.path = void 0;\n    this.desc = void 0;\n    this.oldval = void 0;\n    this.newval = void 0;\n    this.path = path;\n    this.oldval = oldval;\n    this.newval = newval;\n    this.desc = desc;\n  }\n}\nlet lastDescription = undefined;\n\n// make class isinstorage e mettici il path studia annotazioni per annotare gli oggett in modo che vengano rwappati prima di farli ritornare se sono annotati\n// minor todo: type as (...args: infer P) => any) ?\n// NB: cannot be async, it changes execution order and break many codes where return value is determined in a transaction.\n// also because BEGIN() becomes stuck and actions cannot fire until the server replies or times out.\n// export function TRANSACTION<F extends (...args: any)=>any>(func: NoAsyncFn<F>, ...params: Parameters<F>): boolean | DState {\nexport function TRANSACTION(name, func, oldval, newval, desc) {\n  //export function TRANSACTION<F extends NoAsyncFn)>(func: F, ...params: Parameters<F>): boolean | DState {\n  BEGIN();\n  if (!lastDescription) lastDescription = {\n    name,\n    oldval,\n    newval,\n    desc\n  };\n  let e = null;\n  try {\n    func();\n  } catch (err) {\n    e = err;\n    ABORT();\n  }\n  if (t.hasAborted) {\n    if (e) Log.ee('Transaction failed:', e);else Log.ee('Transaction aborted.');\n    return false;\n  }\n  return END([]);\n}\n_c6 = TRANSACTION;\nwindow.TRANSACTION = TRANSACTION;\nwindow.BEGIN = BEGIN;\nwindow.ABORT = ABORT;\nwindow.END = END;\nwindow.FINAL_END = FINAL_END;\nwindow.maxActionFiring = 0;\n\n// todo: ma non so come, fare in modo che [], +=, -=, siano disponibili solo se la chiave è il nome di un attributo di tipo array\n\nexport let Action = (_dec = RuntimeAccessible('Action'), _dec(_class = (_class2 = class Action extends RuntimeAccessibleClass {\n  // targetID: string | undefined;\n  // target: IClass = null as any;\n\n  // field: string = ''; // es: ID_58\n  // value: any; // es: lowerbound, name, namespace, values (for attrib-ref)...\n\n  // private src?: string[];\n  //?\n\n  constructor(field, value, subType) {\n    var _Error$stack;\n    super();\n    this.field = void 0;\n    this.value = void 0;\n    this.id = void 0;\n    this.timestamp = void 0;\n    this.sender = void 0;\n    this.hasFired = 0;\n    this.consoleTargetSelector = '';\n    this.type = void 0;\n    this.subType = void 0;\n    this.stack = void 0;\n    this.id = 'Action_' + Date.now() + \"_\" + Action.maxCounter++; // NB: the prefix must be the same for all actions because it must not affect order\n    this.timestamp = Date.now();\n    this.sender = DUser.current;\n    this.field = field;\n    this.value = value;\n    this.type = this.constructor.type;\n    this.stack = (_Error$stack = new Error().stack) === null || _Error$stack === void 0 ? void 0 : _Error$stack.split('\\n').splice(4);\n    this.subType = subType;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n\n  // forces the action to fire alone ignoring a TRANSACTION or BEGIN/END blocks\n  commit() {\n    return COMMIT(this);\n  }\n  fire() {\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.hasFired && !forceRelaunch) return false;\n    if (this.value && this.value.__isProxy) {\n      Log.ee(\"Attempted to set a proxy object inside the store.\", {\n        action: this,\n        value: this.value\n      });\n      return false;\n    }\n    this.hasFired++;\n    if (t.hasBegun) {\n      t.pendingActions.push(this);\n    } else {\n      // if ((window as any).maxActionFiring++ >= 400) return false;\n      let storee = store || windoww.store;\n      let printobj = {};\n      if (this.className === CompositeAction.cname) {\n        var _ca$descriptor, _ca$actions;\n        let ca = this;\n        printobj.title = (_ca$descriptor = ca.descriptor) === null || _ca$descriptor === void 0 ? void 0 : _ca$descriptor.path;\n        printobj.desc = ca.descriptor;\n        printobj.n = ((_ca$actions = ca.actions) === null || _ca$actions === void 0 ? void 0 : _ca$actions.length) || 1;\n      } else {\n        printobj.field = this.field;\n        printobj.val = this.value;\n      }\n      printobj['this'] = this;\n      printobj['stack'] = this.stack;\n      console.log('firing action:', printobj);\n      storee.dispatch({\n        ...this\n      });\n    }\n    return true;\n  }\n  static parse1(action) {\n    const ret = action;\n    ret.path = action.field; // normalize the path\n    ret.pathArray = ret.path.split('.');\n    ret.executionCount = 0;\n    if (!action.subType) return ret;\n    if (!Action.possibleInconsistencies[action.subType]) Action.possibleInconsistencies[action.subType] = [action.value];else Action.possibleInconsistencies[action.subType].push(action.value);\n    return ret;\n  }\n  static parse(actions) {\n    if (actions.className === CompositeAction.cname) throw new Error(\"Composite action cannot be parsed directly, parse composite.actions instead\");\n    if (!Array.isArray(actions)) return Action.parse1(actions);\n    return actions.map(Action.parse1);\n  }\n  static fromJson(json) {\n    let action = new Action('dummy', 'dummy');\n    for (let key in action) delete action[key]; // resetting the action\n    for (let key in json) action[key] = json[key];\n    return action;\n  }\n}, _class2.cname = \"Action\", _class2.maxCounter = 1, _class2.subclasses = [], _class2._extends = [], _class2.type = 'ACTION', _class2.SubType = void 0, _class2.possibleInconsistencies = {}, _class2)) || _class);\nexport let LoadAction = (_dec2 = RuntimeAccessible('LoadAction'), _dec2(_class3 = (_class4 = class LoadAction extends Action {\n  static new(state) {\n    return state && new LoadAction(state).fire();\n  }\n  static create(state) {\n    return state && new LoadAction(state);\n  }\n  constructor(state) {\n    let fire = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super('', state, '');\n    this.className = this.constructor.cname || this.constructor.name;\n    if (fire) this.fire();\n  }\n}, _class4.cname = \"LoadAction\", _class4.type = 'LOAD', _class4)) || _class3);\nexport let SetRootFieldAction = (_dec3 = RuntimeAccessible('SetRootFieldAction'), _dec3(_class5 = (_class6 = class SetRootFieldAction extends Action {\n  static create(fullpath, val) {\n    let accessModifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let isPointer = arguments.length > 3 ? arguments[3] : undefined;\n    if (accessModifier) fullpath += accessModifier;\n    return new SetRootFieldAction(fullpath, val, false, isPointer);\n  }\n  static new() {\n    return SetRootFieldAction.create(...arguments).fire();\n  }\n  constructor(fullpath) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let fire = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let isPointer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(fullpath, value, undefined);\n    this.isPointer = void 0;\n    this.className = this.constructor.cname || this.constructor.name;\n    this.isPointer = isPointer;\n    if (fire) this.fire();\n  }\n  static create_old(tocheck, fullpath, val) {\n    let accessModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let isPointer = arguments.length > 4 ? arguments[4] : undefined;\n    return new SetRootFieldAction(fullpath + (accessModifier || ''), val, false, isPointer);\n  }\n  fire() {\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let doChecks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    /* no need, the reducer should return old state in this case. verify it!\r\n    if (doChecks) {\r\n        // if action would not change the value, i don't fire it at all\r\n        let s: GObject<DState> = store.getState();\r\n        let field = (this.field||'');\r\n        let accessOperator: string = field.substring(field.length-2);\r\n        let fieldpath: string[] = field.split(\".\");\r\n        switch(accessOperator){\r\n            default:\r\n            case \"-=\":\r\n            case \"+=\":\r\n        }\r\n        // path can end with -=, +=, [] etc, but it's fine if i check it as if it was part of the name like object[\"fieldname+=\"]\r\n        // because in all those cases\r\n        if (s[this.field] === this.value) return false;\r\n    }*/\n    return super.fire(forceRelaunch);\n  }\n}, _class6.cname = \"SetRootFieldAction\", _class6.subclasses = [], _class6._extends = [], _class6.type = 'SET_ROOT_FIELD', _class6)) || _class5);\nexport let SetFieldAction = (_dec4 = RuntimeAccessible('SetFieldAction'), _dec4(_class7 = (_class8 = class SetFieldAction extends SetRootFieldAction {\n  static create(me, field, val) {\n    let accessModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let isPointer = arguments.length > 4 ? arguments[4] : undefined;\n    if (accessModifier) field += accessModifier;\n    return new SetFieldAction(me, field, val, false, isPointer);\n  }\n  static new(me, field, val) {\n    let accessModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let isPointer = arguments.length > 4 ? arguments[4] : undefined;\n    if (accessModifier) field += accessModifier;\n    return new SetFieldAction(me, field, val, false, isPointer).fire();\n  }\n  // field can end with \"+=\", \"[]\", or \"-1\" if it's array\n  constructor(me, field, val) {\n    let fire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let isPointer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    Log.exDev(!me, 'BaseObject missing in SetFieldAction', {\n      me,\n      field,\n      val\n    });\n    super('idlookup.' + (me.id || me) + (field ? '.' + field : ''), val, false, isPointer);\n    this.me = void 0;\n    this.me_field = void 0;\n    this.me = me;\n    this.me_field = field;\n    this.className = this.constructor.cname || this.constructor.name;\n    if (fire) this.fire();\n  }\n  fire() {\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let fire = this.fire0(forceRelaunch);\n    return fire;\n  }\n  fire0() {\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return super.fire(forceRelaunch, false);\n    // IMPORTANT system discarded!\n    // if in a composite action there are 2 editos on the same value, like like a.v = 1; a.v = 0; if v initial value was 0 this would accept a.v=1 and refuse a.v=0;\n    // this is making an issue in containment lvalue.values = lvalue.values\n    // because the values are first disconnected to model, then reconnected to .father=lvalue. but the second command is not firing.\n\n    /*\r\n        // if action would not change the value, i don't fire it at all\r\n        // by id because if item was updated, this.me as DElement might be an old version, different from the one in store.\r\n        let d: GObject<any> = DPointerTargetable.from((this.me as DPointerTargetable)?.id || this.me as any);\r\n        // console.warn(\"me fire\", {thiss:this, d, typeofd:typeof d, field:this.me_field, dfield:d[this.me_field], val:this.value});\r\n        if (d && typeof d === \"object\") {\r\n            let oldv = U.followPath(d, this.me_field);\r\n            console.log('set value index firing 0', {ov:d[this.me_field], me_field:this.me_field, oldv, d, newv:this.value});\r\n            if (oldv === this.value) return false;\r\n        }\r\n        return super.fire(forceRelaunch, false);*/\n  }\n}, _class8.type = 'SET_ME_FIELD', _class8)) || _class7);\n\n/*\r\ncould put in documentation\r\nlet dclass: DClass = null as any;\r\nSetFieldAction.new(dclass, 'namek', '') // non è un attributo di \"DCLass\"\r\nSetFieldAction.new(dclass, 'parent', '') // val (stringa) non è assegnabile a parent (array di puntatori)\r\nSetFieldAction.new(dclass, 'name.5k', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4k]', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4]', '') // ok, anche se non dovrebbe accettare la dicitura array per name che è un primitivo (check non implementato, troppo difficile)\r\nSetFieldAction.new(dclass, 'name.5', '') // ok, equivale a dicitura array\r\n*/\n\nexport let RedoAction = (_dec5 = RuntimeAccessible('RedoAction'), _dec5(_class9 = (_class10 = class RedoAction extends Action {\n  static new() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let forUser = arguments.length > 1 ? arguments[1] : undefined;\n    let notfire = arguments.length > 2 ? arguments[2] : undefined;\n    let act = new RedoAction(amount, forUser);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let forUser = arguments.length > 1 ? arguments[1] : undefined;\n    super('', amount);\n    this.forUser = void 0;\n    this.forUser = forUser;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}, _class10.cname = \"RedoAction\", _class10.type = 'RedoAction', _class10)) || _class9);\nexport let UndoAction = (_dec6 = RuntimeAccessible('UndoAction'), _dec6(_class11 = (_class12 = class UndoAction extends Action {\n  static new() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let forUser = arguments.length > 1 ? arguments[1] : undefined;\n    let notfire = arguments.length > 2 ? arguments[2] : undefined;\n    let act = new UndoAction(amount, forUser);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let forUser = arguments.length > 1 ? arguments[1] : undefined;\n    super('', amount);\n    this.forUser = void 0;\n    this.forUser = forUser;\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}, _class12.cname = \"UndoAction\", _class12.type = 'UndoAction', _class12)) || _class11);\n\n// todo: delete or find original idea back\nexport let CombineHistoryAction = (_dec7 = RuntimeAccessible('CombineHistoryAction'), _dec7(_class13 = (_class14 = class CombineHistoryAction extends Action {\n  static new(notfire) {\n    let act = new CombineHistoryAction();\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    super('', '');\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}, _class14.cname = \"CombineHistoryAction\", _class14.type = 'CombineHistoryAcCombineHistoryActiontion', _class14)) || _class13);\nexport let CreateElementAction = (_dec8 = RuntimeAccessible('CreateElementAction'), _dec8(_class15 = (_class16 = class CreateElementAction extends Action {\n  static newBatch(me, notfire) {\n    let ret = [];\n    if (!me.length) return [];\n    let types = [...new Set(me.map(e => e === null || e === void 0 ? void 0 : e.className))];\n    let typedesc = types.length > 1 ? ' objects of mixed types.' : me[0].className + 'objects.';\n    TRANSACTION('Created ' + me.length + ' ' + typedesc, () => ret = me.map(e => CreateElementAction.new(e, notfire)));\n    return ret;\n  }\n  static create(me) {\n    if (me.__raw) me = me.__raw;\n    return new CreateElementAction(me, true);\n  }\n  static new(me, notfire) {\n    let act = CreateElementAction.create(me);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor(me) {\n    let fire = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super('idlookup.' + me.id, me);\n    this.value = void 0;\n    this.className = this.constructor.cname || this.constructor.name;\n    this.value = me;\n    if (fire) this.fire();\n  }\n  fire() {\n    var _this$value;\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let ret = false;\n    TRANSACTION('Create ' + ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : _this$value.className), () => {\n      ret = super.fire(forceRelaunch);\n      if (this.value._derivedSubElements || this.value._persistCallbacks) {\n        Constructors.persist(this.value, true);\n      }\n    });\n    return ret;\n  }\n}, _class16.cname = \"CreateElementAction\", _class16.type = 'CREATE_ELEMENT', _class16)) || _class15);\nexport let DeleteElementAction = (_dec9 = RuntimeAccessible('DeleteElementAction'), _dec9(_class17 = (_class18 = class DeleteElementAction extends SetFieldAction {\n  static create(me) {\n    return new DeleteElementAction(me);\n  }\n  static new(me) {\n    return new DeleteElementAction(me).fire();\n  }\n  constructor(me) {\n    super(Pointers.from(me), '', undefined);\n    this.className = this.constructor.cname || this.constructor.name;\n  }\n}, _class18.type = 'DELETE_ELEMENT', _class18)) || _class17);\n\n/*\r\n\r\n@RuntimeAccessible\r\nexport class IDLinkAction extends Action{\r\n    constructor() {\r\n        super(IDLinkAction.name,\r\n    }\r\n    nope, uso un proxy\r\n}*/\n\nexport let CompositeAction = (_dec10 = RuntimeAccessible('CompositeAction'), _dec10(_class19 = (_class20 = class CompositeAction extends Action {\n  static new(actions) {\n    let launch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return new CompositeAction(actions, launch);\n  }\n  constructor(actions) {\n    let launch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super('', '');\n    this.actions = [];\n    this.descriptor = void 0;\n    this.actions = actions;\n    this.className = this.constructor.cname || this.constructor.name;\n    if (launch) this.fire();\n  }\n  fire(forceRelanch) {\n    if (!this.actions.length) return false;\n    return super.fire(forceRelanch);\n  }\n}, _class20.type = 'COMPOSITE_ACTION', _class20)) || _class19);\nexport let ParsedAction = (_dec11 = RuntimeAccessible('ParsedAction'), _dec11(_class21 = class ParsedAction extends SetRootFieldAction {\n  constructor() {\n    super(...arguments);\n    this.path = void 0;\n    this.pathArray = void 0;\n    this.executionCount = void 0;\n  } // NB: actually this is never created but \"converted\" from other actions by adding fields\n  // path to a property in the store \"something.like.this\"\n  // path splitted \"like.1.this\"\n}) || _class21);\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Action);\nRuntimeAccessibleClass.set_extend(Action, LoadAction);\nRuntimeAccessibleClass.set_extend(Action, SetRootFieldAction);\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, SetFieldAction);\nRuntimeAccessibleClass.set_extend(SetFieldAction, DeleteElementAction);\nRuntimeAccessibleClass.set_extend(Action, RedoAction);\nRuntimeAccessibleClass.set_extend(Action, UndoAction);\nRuntimeAccessibleClass.set_extend(Action, CreateElementAction);\nRuntimeAccessibleClass.set_extend(Action, CombineHistoryAction);\nRuntimeAccessibleClass.set_extend(Action, CompositeAction);\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, ParsedAction);\nvar _c, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"BEGIN\");\n$RefreshReg$(_c2, \"ABORT\");\n$RefreshReg$(_c3, \"COMMIT\");\n$RefreshReg$(_c4, \"END\");\n$RefreshReg$(_c5, \"FINAL_END\");\n$RefreshReg$(_c6, \"TRANSACTION\");","map":{"version":3,"names":["Constructors","DUser","Log","Pointers","RuntimeAccessible","RuntimeAccessibleClass","store","windoww","TransactionStatus","constructor","pendingActions","hasBegun","hasAborted","transactionDepthLevel","t","transactionStatus","BEGIN","_c","ABORT","ret","END","_c2","COMMIT","action","olddepth","_c3","actionstoPrepend","arguments","length","undefined","path","oldval","newval","desc","console","error","FINAL_END","_c4","ca","CompositeAction","lastDescription","name","descriptor","ActionDescriptor","fire","_c5","TRANSACTION","func","e","err","ee","_c6","window","maxActionFiring","Action","_dec","_class","_class2","field","value","subType","_Error$stack","id","timestamp","sender","hasFired","consoleTargetSelector","type","stack","Date","now","maxCounter","current","Error","split","splice","className","cname","commit","forceRelaunch","__isProxy","push","storee","printobj","_ca$descriptor","_ca$actions","title","n","actions","val","log","dispatch","parse1","pathArray","executionCount","possibleInconsistencies","parse","Array","isArray","map","fromJson","json","key","subclasses","_extends","SubType","LoadAction","_dec2","_class3","_class4","new","state","create","SetRootFieldAction","_dec3","_class5","_class6","fullpath","accessModifier","isPointer","create_old","tocheck","doChecks","SetFieldAction","_dec4","_class7","_class8","me","exDev","me_field","fire0","RedoAction","_dec5","_class9","_class10","amount","forUser","notfire","act","UndoAction","_dec6","_class11","_class12","CombineHistoryAction","_dec7","_class13","_class14","CreateElementAction","_dec8","_class15","_class16","newBatch","types","Set","typedesc","__raw","_this$value","_derivedSubElements","_persistCallbacks","persist","DeleteElementAction","_dec9","_class17","_class18","from","_dec10","_class19","_class20","launch","forceRelanch","ParsedAction","_dec11","_class21","set_extend","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/redux/action/action.ts"],"sourcesContent":["import {\r\n    Constructors,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    GObject,\r\n    Json,\r\n    Log,\r\n    LPointerTargetable,\r\n    orArr,\r\n    Pack1,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    U,\r\n    unArr,\r\n    windoww\r\n} from \"../../joiner\";\r\n\r\n// transactional-like start of storage modification\r\n// todo: nested transaction che conti quanti begin hai effettuato e crei una matrice di pendingActions una per ogni livello nested?\r\n\r\n/*\r\n// let nestedlevel: number = 0;\r\nclass NestedLevel{\r\n    level: number;\r\n    actions: Action[] = [];\r\n    up:NestedLevel[] = [];\r\n    down?:NestedLevel;\r\n\r\n    constructor(prevLevel?: NestedLevel, actions: Action[] = []) {\r\n        // this.prev = prev;\r\n        this.down = prevLevel;\r\n        this.actions = actions;\r\n        this.level = prevLevel ? prevLevel.level + 1 : 0;\r\n    }\r\n\r\n    add1(a:Action){ this.actions.push(a); }\r\n    add(a:Action[]){ this.actions.push(...a); }\r\n    push(actions:Action[]=[]){\r\n        this.up.push(new NestedLevel(this, actions));\r\n    }\r\n}\r\n// @Singleton\r\nclass NestedTransactionManager{\r\n    // private levels: NestedLevel[] = [];\r\n    public currentLevel?: NestedLevel;\r\n    // simple array is not good i can have spikes as russian mountains going up and down in deepness it's kinda a matrix or a pile of dishes like below'\r\n\r\n\r\n    /*\r\n    todo: to debug missing END paired with a begin, seve stack trace of begins and ends\r\n    * every level must have his own array?\r\n    * Begin0, Begin1, Begin2, End2, End1, Begin1.1 Begin 1.2....\r\n    it's a tree!\r\n    *\r\n    *\r\n    * ______begin lv2                              _______Begin1.2\r\n    * _________________________begin lv1           ___________________Begin1.1\r\n    * ____________________________________________________________________________________________________ a begin lv0\r\n    * * /\r\n    constructor() {}\r\n    begin(actions: Action[]=[]): void { this.pushLevel(actions); }\r\n    pushLevel(actions: Action[]=[]): void {\r\n        if (!this.currentLevel) { this.currentLevel = new NestedLevel(undefined, actions); return; }\r\n        this.currentLevel.push(actions); }\r\n    end(){\r\n        if (!this.currentLevel) return this.finalEnd();\r\n        this.currentLevel = this.currentLevel?.down; }\r\n    finalEnd(){\r\n\r\n    }\r\n    // current(): NestedLevel { return this.currentLevel; }\r\n    addActions(a:Action[]): void { this.currentLevel!.add(a); }\r\n    addAction(a:Action): void { this.currentLevel!.add1(a); }\r\n}\r\nlet transactionmanager = new NestedTransactionManager();\r\nfunction BEGIN2(){\r\n    transactionmanager.pushLevel();\r\n}\r\nfunction ABORT2(){\r\n    transactionmanager.end();\r\n}\r\nfunction END2(){\r\n\r\n}*/\r\n\r\nclass TransactionStatus{\r\n    pendingActions: Action[] = [];\r\n    hasBegun: boolean = false;\r\n    hasAborted: boolean = false;\r\n    transactionDepthLevel: number = 0;\r\n}\r\nlet t = new TransactionStatus();\r\nwindoww.transactionStatus = t;\r\n\r\nexport function BEGIN() {\r\n    if (t.transactionDepthLevel === 0) t.hasAborted = false;\r\n    t.hasBegun = true; // redundant but actions are reading this, minimize changes\r\n    t.transactionDepthLevel++;\r\n}\r\nexport function ABORT(): boolean {\r\n    let ret: boolean = t.transactionDepthLevel > 0;\r\n    t.hasAborted = true; // at any depth level since i have only a flat TRANSACTION array\r\n    END();\r\n    return ret;\r\n}\r\n// if without parameter: commits the current pending stuff, with parameter: fires the action ignoring transaction block while keeping te transaction active\r\nexport function COMMIT(action?:Action): boolean {\r\n    let olddepth = t.transactionDepthLevel;\r\n    if (olddepth<=0) {\r\n        END(); //just safety to restore has begun state, should be necessary.\r\n        return false;\r\n    }\r\n    t.transactionDepthLevel = 1;\r\n    END();\r\n    t.transactionDepthLevel = olddepth-1;\r\n    BEGIN();\r\n    return true;\r\n}\r\n\r\nexport function END(actionstoPrepend: Action[] = [], path?: string, oldval?: any, newval?: any, desc?:string): boolean {\r\n    t.transactionDepthLevel--;\r\n    if (actionstoPrepend.length) t.pendingActions = [...actionstoPrepend, ...t.pendingActions];\r\n\r\n    if (t.transactionDepthLevel < 0) { console.error(\"mismatching END()\"); t.transactionDepthLevel = 0; }\r\n    if (t.transactionDepthLevel === 0) return FINAL_END(path, oldval, newval, desc);\r\n    return false;\r\n}\r\nfunction FINAL_END(path?: string, oldval?: any, newval?: any, desc?:string): boolean{\r\n    t.hasBegun = false;\r\n    // pendingActions.sort( (a, b) => a.timestamp - b.timestamp)\r\n    if (t.hasAborted) {\r\n        t.pendingActions = [];\r\n        t.hasAborted = false;\r\n        return false;\r\n    }\r\n    const ca: CompositeAction = new CompositeAction(t.pendingActions, false);\r\n    if (lastDescription) {\r\n        path = lastDescription.name;\r\n        oldval = lastDescription.oldval;\r\n        newval = lastDescription.newval;\r\n        desc = lastDescription.desc;\r\n        lastDescription = undefined;\r\n    }\r\n    if (path) ca.descriptor = new ActionDescriptor(path, oldval, newval, desc);\r\n    t.pendingActions = [];\r\n    return ca.fire();\r\n}\r\nexport class ActionDescriptor{\r\n    path?: string;\r\n    desc?: string;\r\n    oldval: any;\r\n    newval: any;\r\n    public constructor (path?: string, oldval?: any, newval?: any, desc?:string){\r\n        this.path = path;\r\n        this.oldval = oldval;\r\n        this.newval = newval;\r\n        this.desc = desc;\r\n    }\r\n}\r\ntype NotPromise<T> = T extends Promise<any> ? never : T;\r\n\r\ntype NoAsyncFn<\r\n    T extends (...args: any)=>any,\r\n    ReturnsPromise extends (...args: any)=>any = ReturnType<T> extends Promise<any> ? never:T\r\n    >=ReturnsPromise;\r\n\r\nlet lastDescription: {name: string, oldval: any, newval: any, desc?: string} | undefined = undefined;\r\n\r\n// make class isinstorage e mettici il path studia annotazioni per annotare gli oggett in modo che vengano rwappati prima di farli ritornare se sono annotati\r\n// minor todo: type as (...args: infer P) => any) ?\r\n// NB: cannot be async, it changes execution order and break many codes where return value is determined in a transaction.\r\n// also because BEGIN() becomes stuck and actions cannot fire until the server replies or times out.\r\n// export function TRANSACTION<F extends (...args: any)=>any>(func: NoAsyncFn<F>, ...params: Parameters<F>): boolean | DState {\r\nexport function TRANSACTION(name:string, func: ()=> void, oldval?: any, newval?: any, desc?:string): boolean {\r\n//export function TRANSACTION<F extends NoAsyncFn)>(func: F, ...params: Parameters<F>): boolean | DState {\r\n    BEGIN();\r\n    if (!lastDescription) lastDescription = {name, oldval, newval, desc};\r\n    let e: Error = null as any;\r\n    try { func(); } catch(err: any) { e = err; ABORT(); }\r\n    if (t.hasAborted) {\r\n        if (e) Log.ee('Transaction failed:', e);\r\n        else Log.ee('Transaction aborted.');\r\n        return false;\r\n    }\r\n    return END([]);\r\n}\r\n(window as any).TRANSACTION = TRANSACTION;\r\n(window as any).BEGIN = BEGIN;\r\n(window as any).ABORT = ABORT;\r\n(window as any).END = END;\r\n(window as any).FINAL_END = FINAL_END;\r\n(window as any).maxActionFiring = 0;\r\n\r\n// todo: ma non so come, fare in modo che [], +=, -=, siano disponibili solo se la chiave è il nome di un attributo di tipo array\r\ntype arrayFieldNameTypes<D> = keyof D | `${string & keyof D}[]` | `${string & keyof D}+=` | `${string & keyof D}-=` | `${string & keyof D}.${number}` | `${string & keyof D}[${number}]`;\r\ntype AccessModifier = '' | '[]' | '+=' | '-=' | `.${number}` | `[${number}]` | undefined;\r\ntype StrictExclude<T, U> = T extends U ? U extends T ? never : T : T;\r\n\r\n@RuntimeAccessible('Action')\r\nexport class Action extends RuntimeAccessibleClass {\r\n    public static cname: string = \"Action\";\r\n    public static maxCounter: number = 1;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static type = 'ACTION';\r\n    static SubType: {\r\n        vertexSubElements: 'vertexSubElements',\r\n        vertexSize: 'vertexSize'\r\n    };\r\n    field: string;\r\n    value: any;\r\n    id: Pointer;\r\n    timestamp: number;\r\n    sender: Pointer<DUser>;\r\n    hasFired: number = 0;\r\n    // targetID: string | undefined;\r\n    // target: IClass = null as any;\r\n    consoleTargetSelector: string = '';\r\n    // field: string = ''; // es: ID_58\r\n    // value: any; // es: lowerbound, name, namespace, values (for attrib-ref)...\r\n    type: string;\r\n    // private src?: string[];\r\n    subType?: string; //?\r\n    private stack?: string[];\r\n    protected constructor(field: string, value: any, subType?: string) {\r\n        super();\r\n        this.id = 'Action_' + Date.now() + \"_\" + Action.maxCounter++; // NB: the prefix must be the same for all actions because it must not affect order\r\n        this.timestamp = Date.now();\r\n        this.sender = DUser.current;\r\n        this.field = field;\r\n        this.value = value;\r\n        this.type = (this.constructor as any).type;\r\n        this.stack = new Error().stack?.split('\\n').splice( 4);\r\n        this.subType = subType;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // forces the action to fire alone ignoring a TRANSACTION or BEGIN/END blocks\r\n    commit(): boolean{\r\n        return COMMIT(this);\r\n    }\r\n    fire(forceRelaunch: boolean = false): boolean {\r\n        if (this.hasFired && !forceRelaunch) return false;\r\n        if (this.value && this.value.__isProxy) {\r\n            Log.ee(\"Attempted to set a proxy object inside the store.\", {action:this, value: this.value});\r\n            return false;\r\n        }\r\n        this.hasFired++;\r\n        if (t.hasBegun) {\r\n            t.pendingActions.push(this);\r\n        } else {\r\n            // if ((window as any).maxActionFiring++ >= 400) return false;\r\n            let storee = store || windoww.store;\r\n            let printobj: GObject = {};\r\n            if (this.className === CompositeAction.cname) {\r\n                let ca: CompositeAction = this as any;\r\n                printobj.title = ca.descriptor?.path;\r\n                printobj.desc = ca.descriptor;\r\n                printobj.n = ca.actions?.length || 1;\r\n            }\r\n            else {\r\n                printobj.field = this.field;\r\n                printobj.val = this.value\r\n            }\r\n            printobj['this'] = this;\r\n            printobj['stack'] = this.stack;\r\n            console.log('firing action:', printobj);\r\n            storee.dispatch({...this});\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static possibleInconsistencies: Dictionary<DocString<'subtype'>, Pointer[]> = {};\r\n    private static parse1(action: Action): ParsedAction {\r\n        const ret: ParsedAction = action as any;\r\n        ret.path = action.field; // normalize the path\r\n        ret.pathArray = ret.path.split('.');\r\n        ret.executionCount = 0;\r\n        if (!action.subType) return ret;\r\n        if (!Action.possibleInconsistencies[action.subType]) Action.possibleInconsistencies[action.subType] = [ action.value ];\r\n        else Action.possibleInconsistencies[action.subType].push(action.value);\r\n        return ret;\r\n    }\r\n\r\n    static parse<T extends Action | Action[], RET extends T extends any[] ? ParsedAction[] : ParsedAction>(actions: T): RET {\r\n        if ((actions as Action).className === CompositeAction.cname) throw new Error(\"Composite action cannot be parsed directly, parse composite.actions instead\");\r\n        if (!Array.isArray(actions)) return Action.parse1(actions) as RET;\r\n        return actions.map( Action.parse1 ) as RET;\r\n    }\r\n\r\n    static fromJson(json: Json): Action{\r\n        let action = new Action('dummy', 'dummy');\r\n        for(let key in action) delete (action as GObject)[key]; // resetting the action\r\n        for(let key in json) (action as any)[key] = json[key];\r\n        return action;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LoadAction')\r\nexport class LoadAction extends Action {\r\n    public static cname: string = \"LoadAction\";\r\n    static type = 'LOAD';\r\n    static new(state: DState | GObject): boolean { return state && new LoadAction(state).fire(); }\r\n    static create(state: DState | GObject): LoadAction { return state && new LoadAction(state); }\r\n\r\n    constructor(state: DState | GObject, fire: boolean = true) {\r\n        super('', state, '');\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('SetRootFieldAction')\r\nexport class SetRootFieldAction extends Action {\r\n    public static cname: string = \"SetRootFieldAction\";\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static type = 'SET_ROOT_FIELD';\r\n    isPointer: boolean;\r\n\r\n    static create(fullpath: string, val: string | string[], accessModifier: AccessModifier | undefined, isPointer: boolean): SetRootFieldAction;\r\n    static create<\r\n        VAL extends any,\r\n        PATH extends VAL extends string | string[] ? 'must specify \"isPointer\" parameter' : string,\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: PATH, val: VAL, accessModifier?: AM | undefined, isPointer?: ISPOINTER): SetRootFieldAction;\r\n    static create<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetRootFieldAction {\r\n        if (accessModifier) (fullpath as any) += accessModifier;\r\n        return new SetRootFieldAction(fullpath, val, false, isPointer);\r\n    }\r\n    static new(...a:Parameters<(typeof SetRootFieldAction)[\"create\"]>): boolean{ return SetRootFieldAction.create(...a).fire();}\r\n\r\n    protected constructor(fullpath: string, value: any = undefined, fire: boolean = true, isPointer: boolean = false) {\r\n        super(fullpath, value, undefined);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.isPointer = isPointer;\r\n        if (fire) this.fire();\r\n    }\r\n\r\n    static create_old<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(tocheck:never, fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetRootFieldAction {\r\n        return new SetRootFieldAction(fullpath + (accessModifier || ''), val, false, isPointer);\r\n    }\r\n    fire(forceRelaunch: boolean = false, doChecks: boolean = true): boolean {\r\n        /* no need, the reducer should return old state in this case. verify it!\r\n        if (doChecks) {\r\n            // if action would not change the value, i don't fire it at all\r\n            let s: GObject<DState> = store.getState();\r\n            let field = (this.field||'');\r\n            let accessOperator: string = field.substring(field.length-2);\r\n            let fieldpath: string[] = field.split(\".\");\r\n            switch(accessOperator){\r\n                default:\r\n                case \"-=\":\r\n                case \"+=\":\r\n            }\r\n            // path can end with -=, +=, [] etc, but it's fine if i check it as if it was part of the name like object[\"fieldname+=\"]\r\n            // because in all those cases\r\n            if (s[this.field] === this.value) return false;\r\n        }*/\r\n        return super.fire(forceRelaunch);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('SetFieldAction')\r\nexport class SetFieldAction extends SetRootFieldAction {\r\n    static type = 'SET_ME_FIELD';\r\n\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends\r\n            D[T] extends string | string[] ? 'must specify \"isPointer\" parameter' :\r\n                (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: VAL,\r\n          accessModifier?: AM | undefined,\r\n          isPointer?: ISPOINTER): SetFieldAction;\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends AM extends '' | undefined ? orArr<string | null | undefined> :\r\n            (AM extends '-=' ? orArr<number> :\r\n                (AM extends '+=' ? orArr<string | null | undefined> : '_am_typeerror_')),\r\n        AM extends AccessModifier | undefined = undefined,\r\n        >(me: D | Pointer<D>, field: T,\r\n          val: VAL,\r\n          accessModifier: AM,\r\n          isPointer: boolean): SetFieldAction;\r\n    static create<\r\n        D extends DPointerTargetable,\r\n        T extends string & (keyof D),\r\n        VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>, field: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetFieldAction {\r\n        if (accessModifier) (field as any) += accessModifier;\r\n        return new SetFieldAction(me, field, val, false, isPointer as boolean);\r\n    }\r\n\r\n\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends\r\n            D[T] extends string | string[] ? 'must specify \"isPointer\" parameter' :\r\n                (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: VAL,\r\n          accessModifier?: AM | undefined,\r\n          isPointer?: ISPOINTER): boolean;\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends AM extends '' | undefined ? orArr<string | null | undefined> :\r\n            (AM extends '-=' ? orArr<number> :\r\n                (AM extends '+=' ? orArr<string | null | undefined> : '_am_typeerror_')),\r\n        AM extends AccessModifier | undefined = undefined,\r\n        >(me: D | Pointer<D>, field: T,\r\n          val: VAL,\r\n          accessModifier: AM,\r\n          isPointer: boolean): boolean;\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends string & (keyof D),\r\n        VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>, field: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): boolean {\r\n        if (accessModifier) (field as any) += accessModifier;\r\n        return new SetFieldAction(me, field, val, false, isPointer as boolean).fire();\r\n    }\r\n\r\n\r\n\r\n    me: Pointer | DPointerTargetable;\r\n    me_field: string;\r\n    // field can end with \"+=\", \"[]\", or \"-1\" if it's array\r\n    protected constructor(me: DPointerTargetable | Pointer, field: string, val: any, fire: boolean = true, isPointer: boolean = false) {\r\n        Log.exDev(!me, 'BaseObject missing in SetFieldAction', {me, field, val});\r\n        super('idlookup.' + ((me as DPointerTargetable).id || me) + ( field ? '.' + field : ''), val, false, isPointer);\r\n        this.me = me;\r\n        this.me_field = field;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n\r\n    fire(forceRelaunch: boolean = false): boolean {\r\n        let fire = this.fire0(forceRelaunch);\r\n        return fire;\r\n\r\n    }\r\n    fire0(forceRelaunch: boolean = false): boolean {\r\n        return super.fire(forceRelaunch, false);\r\n        // IMPORTANT system discarded!\r\n        // if in a composite action there are 2 editos on the same value, like like a.v = 1; a.v = 0; if v initial value was 0 this would accept a.v=1 and refuse a.v=0;\r\n        // this is making an issue in containment lvalue.values = lvalue.values\r\n        // because the values are first disconnected to model, then reconnected to .father=lvalue. but the second command is not firing.\r\n\r\n\r\n    /*\r\n        // if action would not change the value, i don't fire it at all\r\n        // by id because if item was updated, this.me as DElement might be an old version, different from the one in store.\r\n        let d: GObject<any> = DPointerTargetable.from((this.me as DPointerTargetable)?.id || this.me as any);\r\n        // console.warn(\"me fire\", {thiss:this, d, typeofd:typeof d, field:this.me_field, dfield:d[this.me_field], val:this.value});\r\n        if (d && typeof d === \"object\") {\r\n            let oldv = U.followPath(d, this.me_field);\r\n            console.log('set value index firing 0', {ov:d[this.me_field], me_field:this.me_field, oldv, d, newv:this.value});\r\n            if (oldv === this.value) return false;\r\n        }\r\n        return super.fire(forceRelaunch, false);*/\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\ncould put in documentation\r\nlet dclass: DClass = null as any;\r\nSetFieldAction.new(dclass, 'namek', '') // non è un attributo di \"DCLass\"\r\nSetFieldAction.new(dclass, 'parent', '') // val (stringa) non è assegnabile a parent (array di puntatori)\r\nSetFieldAction.new(dclass, 'name.5k', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4k]', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4]', '') // ok, anche se non dovrebbe accettare la dicitura array per name che è un primitivo (check non implementato, troppo difficile)\r\nSetFieldAction.new(dclass, 'name.5', '') // ok, equivale a dicitura array\r\n*/\r\n\r\n@RuntimeAccessible('RedoAction')\r\nexport class RedoAction extends Action {\r\n    public static cname: string = \"RedoAction\";\r\n    static type = 'RedoAction';\r\n    forUser: Pointer<DUser>\r\n    public static new<F extends boolean = true>(amount: number = 1, forUser: Pointer<DUser>, notfire?: F): (F extends false ? boolean : RedoAction) {\r\n        let act = new RedoAction(amount, forUser);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(amount: number = 1, forUser:Pointer<DUser>) {\r\n        super('', amount);\r\n        this.forUser = forUser;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('UndoAction')\r\nexport class UndoAction extends Action {\r\n    public static cname: string = \"UndoAction\";\r\n    static type = 'UndoAction';\r\n    forUser: Pointer<DUser>;\r\n    public static new<F extends boolean = true>(amount: number = 1, forUser:Pointer<DUser>, notfire?: F): (F extends false ? boolean : UndoAction) {\r\n        let act = new UndoAction(amount, forUser);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(amount: number = 1, forUser:Pointer<DUser>) {\r\n        super('', amount);\r\n        this.forUser = forUser;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n// todo: delete or find original idea back\r\n@RuntimeAccessible('CombineHistoryAction')\r\nexport class CombineHistoryAction extends Action {\r\n    public static cname: string = \"CombineHistoryAction\";\r\n    static type = 'CombineHistoryAcCombineHistoryActiontion';\r\n    public static new<F extends boolean = true>(notfire?: F): (F extends false ? boolean : CombineHistoryAction) {\r\n        let act = new CombineHistoryAction();\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor() {\r\n        super('', '');\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('CreateElementAction')\r\nexport class CreateElementAction extends Action {\r\n    public static cname: string = \"CreateElementAction\";\r\n    static type = 'CREATE_ELEMENT';\r\n    value!: DPointerTargetable;\r\n    public static newBatch<F extends boolean = true>(me: DPointerTargetable[], notfire?: F): (F extends false ? boolean : CreateElementAction)[]{\r\n        let ret: any[] = [];\r\n        if (!me.length) return [] as any;\r\n        let types = [...new Set(me.map(e=>e?.className))];\r\n        let typedesc = types.length > 1 ? ' objects of mixed types.' : me[0].className + 'objects.';\r\n        TRANSACTION('Created '+me.length+' '+typedesc, ()=>(ret = me.map( (e) => CreateElementAction.new(e, notfire))));\r\n        return ret;\r\n    }\r\n\r\n    public static create<F extends boolean = true>(me: DPointerTargetable): CreateElementAction {\r\n        if ((me as LPointerTargetable).__raw) me = (me as LPointerTargetable).__raw;\r\n        return new CreateElementAction(me, true);\r\n    }\r\n    public static new<F extends boolean = true>(me: DPointerTargetable, notfire?: F): (F extends false ? boolean : CreateElementAction) {\r\n        let act = CreateElementAction.create(me);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(me: DPointerTargetable, fire: boolean = true) {\r\n        super('idlookup.' + me.id, me);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.value = me;\r\n        if (fire) this.fire();\r\n    }\r\n    public fire(forceRelaunch: boolean = false): boolean {\r\n        let ret = false;\r\n        TRANSACTION('Create ' + this.value?.className, () => {\r\n            ret = super.fire(forceRelaunch);\r\n            if (this.value._derivedSubElements || this.value._persistCallbacks) { Constructors.persist(this.value, true); }\r\n        });\r\n        return ret;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('DeleteElementAction')\r\nexport class DeleteElementAction extends SetFieldAction {\r\n    static type = 'DELETE_ELEMENT';\r\n    public static create(me: Pack1<LPointerTargetable>): DeleteElementAction { return new DeleteElementAction(me as any); }\r\n    public static new(me: Pack1<LPointerTargetable>): boolean { return new DeleteElementAction(me as any).fire(); }\r\n\r\n    constructor(me: Pack1<LPointerTargetable>) {\r\n        super(Pointers.from(me), '', undefined);\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n\r\n@RuntimeAccessible\r\nexport class IDLinkAction extends Action{\r\n    constructor() {\r\n        super(IDLinkAction.name,\r\n    }\r\n    nope, uso un proxy\r\n}*/\r\n\r\n@RuntimeAccessible('CompositeAction')\r\nexport class CompositeAction extends Action {\r\n    static type: string = 'COMPOSITE_ACTION';\r\n    actions: Action[] = [];\r\n    descriptor?: ActionDescriptor;\r\n\r\n    public static new(actions: Action[], launch: boolean = true): CompositeAction { return new CompositeAction(actions, launch); }\r\n    constructor(actions: Action[], launch: boolean = false) {\r\n        super('', '');\r\n        this.actions = actions;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        if (launch) this.fire();\r\n    }\r\n    fire(forceRelanch?: boolean): boolean{\r\n        if (!this.actions.length) return false;\r\n        return super.fire(forceRelanch);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ParsedAction')\r\nexport class ParsedAction extends SetRootFieldAction {\r\n    // NB: actually this is never created but \"converted\" from other actions by adding fields\r\n    path!: string; // path to a property in the store \"something.like.this\"\r\n    pathArray!: string[]; // path splitted \"like.1.this\"\r\n    executionCount!: number;\r\n}\r\n\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Action);\r\nRuntimeAccessibleClass.set_extend(Action, LoadAction);\r\nRuntimeAccessibleClass.set_extend(Action, SetRootFieldAction);\r\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, SetFieldAction);\r\nRuntimeAccessibleClass.set_extend(SetFieldAction, DeleteElementAction);\r\nRuntimeAccessibleClass.set_extend(Action, RedoAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, UndoAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CreateElementAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CombineHistoryAction as any);\r\nRuntimeAccessibleClass.set_extend(Action, CompositeAction as any);\r\nRuntimeAccessibleClass.set_extend(SetRootFieldAction, ParsedAction as any);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}