{"ast":null,"code":"import { Log, DModel, DValue, DObject, DEnumerator, DEnumLiteral, DAttribute, DReference, DClass, DParameter, DOperation, DPackage, DAnnotation, AttribETypes, U, Selectors, PointedBy, LPointerTargetable, windoww, SetRootFieldAction, Constructors, store, SetFieldAction, DPointerTargetable, ShortAttribETypes, toLongEType } from \"../joiner\";\nimport { ShortDefaultEClasses, toLongEClass } from \"../common/U\";\nclass SavePack {\n  constructor() {\n    let model = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let vertexpos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    this.model = void 0;\n    this.vertexpos = void 0;\n    this.view = void 0;\n    this.model = model;\n    this.vertexpos = vertexpos;\n    this.view = view;\n  }\n}\nexport class IStorage {\n  static get() {\n    return Log.exx(\"IStorage.get (static) should be overridden\");\n  }\n  constructor(prefix, autosave) {\n    this.prefix = void 0;\n    this.autosave = void 0;\n    this.prefix = prefix;\n    this.autosave = autosave;\n  }\n  del(key) {\n    let isOverwrite = this.get(key) !== null;\n    this.set(key, '');\n    return isOverwrite;\n  }\n  get(key) {\n    let parse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return Log.exx(\"IStorage.get should be overridden\");\n  }\n  serialize(val) {\n    // serialize\n    try {\n      return JSON.stringify(val);\n    } catch (e) {\n      return \"\" + val;\n    }\n  }\n  deserialize(val) {\n    // de-serialize\n    try {\n      return JSON.parse(val);\n    } catch (e) {\n      return val;\n    }\n  }\n  set0(val) {\n    return this.serialize(val);\n  }\n  get0(val) {\n    return this.deserialize(val);\n  }\n  parse(val) {\n    return this.deserialize(val);\n  }\n}\nexport class LocalStorage extends IStorage {\n  static get() {\n    return new LocalStorage(\"_j\", true);\n  }\n  constructor(prefix, autosave) {\n    super(prefix, autosave);\n  }\n  get(key) {\n    let parse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let val = localStorage.getItem(this.prefix + key);\n    return parse ? this.parse(val) : val;\n  }\n  set(key, val) {\n    val = this.serialize(val);\n    // let isOverwrite = localStorage.getItem(this.prefix+key);\n    localStorage.set(this.prefix + key, val);\n    return true;\n  }\n  getLastOpened(modelNumber) {\n    let modelname = \"m\" + modelNumber + \"_\";\n    const ret = new SavePack();\n    ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\n    ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\n    ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\n    return ret;\n  }\n  deleteLastOpened(modelNumber) {\n    this.setLastOpened(modelNumber, '', '', '');\n  }\n  setLastOpened(modelNumber) {\n    let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let view = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let vertex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let modelname = \"m\" + modelNumber + \"_\";\n    if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);else this.del(modelname + LocalStorage.KeyList.lastOpenedModel);\n    if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);else this.del(modelname + LocalStorage.KeyList.lastOpenedView);\n    if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);else this.del(modelname + LocalStorage.KeyList.lastOpenedPosition);\n  }\n}\nLocalStorage.KeyList = {\n  lastOpenedModel: \"lastOpenedModel\",\n  lastOpenedView: \"lastOpenedView\",\n  lastOpenedPosition: \"lastOpenedPosition\"\n};\nexport class EcoreParser {\n  static parse(ecorejson, isMetamodel, filename) {\n    let persist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!ecorejson) return [];\n    let parsedjson;\n    if (typeof ecorejson === \"string\") try {\n      parsedjson = JSON.parse(ecorejson);\n    } catch (e) {\n      windoww.temp = ecorejson;\n      Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000));\n      throw e;\n    } else parsedjson = ecorejson;\n    console.log(\"root parse\", {\n      ecorejson,\n      parsedjson\n    });\n    // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\n\n    Constructors.paused = true;\n    let parsedElements = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\n    console.warn(\"parse.result D\", parsedElements);\n    this.LinkAllNamesToIDs(parsedElements);\n    this.fixNamingConflicts(parsedElements);\n    Constructors.paused = false;\n    // if (persist) CreateElementAction.newBatch(parsedElements);\n    // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\n    this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\n    Constructors.persist(parsedElements);\n    windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\n    this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\n    console.log('parsedElem', parsedElements);\n    return parsedElements;\n  }\n  static fixObjectPointers(parsedElements) {\n    let dobjects = parsedElements.filter(e => e.className === DObject.cname);\n    let values = parsedElements.filter(e => e.className === DValue.cname);\n    let lobjects = LPointerTargetable.fromArr(dobjects);\n    let m1pointermap = {}; //    \"//@rootrefname.index@/refname.index/@....etc\"\n    for (let o of lobjects) {\n      m1pointermap[o.ecorePointer()] = o;\n    }\n    for (let v of values) {\n      if (v.isMirage) continue;\n      let modified = false;\n      let newvalues = v.values.map(e => {\n        if (!m1pointermap[e]) return e;\n        modified = true;\n        console.log(\"m1 pointer resolved:\", {\n          from: e,\n          to: m1pointermap[e].id\n        });\n        return m1pointermap[e].id;\n      });\n      if (!modified) continue;\n      //let lv: LValue = LPointerTargetable.from(v);\n      v.values = newvalues;\n    }\n  }\n  static tempfix_untilopennewtabisdone(parsedElements, isMetamodel) {\n    // replaces current model with parsed model. this needs to be removed to open a new tab later on.\n    let model = null;\n    for (let elem of parsedElements) {\n      if (elem.className === DModel.cname) {\n        model = elem;\n        break;\n      }\n    }\n    SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\n  }\n\n  // resolve eCore pointers to Jodel pointers and set the PointedBy\n  static LinkAllNamesToIDs(parsedElements) {\n    // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\n    // update mref, attribute, parameter type\n    // update operation exception\n    // replace those names with id's\n\n    let idMap = {};\n    let nameMap = {};\n    let replacePrimitiveMap = {};\n    let d_Estring = Selectors.getAllPrimitiveTypes()[1];\n    replacePrimitiveMap[AttribETypes.EString] = d_Estring;\n    // todo: do the same for all other primitives\n    let state = store.getState();\n\n    // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\n    const typeprefix = \"#//\";\n    for (let shortkey in ShortAttribETypes) {\n      if (shortkey === ShortAttribETypes.EVoid) continue;\n      let shortetype = ShortAttribETypes[shortkey];\n      let longetype = toLongEType(shortetype);\n      let dClassType = Selectors.getPrimitiveType(shortetype, state);\n      Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {\n        shortkey,\n        shortetype,\n        longetype,\n        dClassType,\n        state\n      });\n      // the correct one\n      replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\n      // fallbacks for missing type instead of crash\n      if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\n      if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\n      if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\n    }\n    for (let shortkey in ShortDefaultEClasses) {\n      let shortetype = ShortDefaultEClasses[shortkey];\n      let longetype = toLongEClass(shortetype);\n      let dClassType = Selectors.getDefaultEcoreClass(shortetype, state);\n      Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {\n        shortkey,\n        shortetype,\n        longetype,\n        dClassType,\n        state\n      });\n\n      // the correct one\n      replacePrimitiveMap[longetype] = dClassType;\n      // fallbacks for missing type instead of crash\n      if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\n      if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\n      if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\n    }\n\n    for (let ecorename in replacePrimitiveMap) {\n      // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\n      if (idMap[replacePrimitiveMap[ecorename].id]) continue;\n      idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\n    }\n\n    // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\n    let replaceRules = [\"extends\", /*\"extendedBy\",*/\"exceptions\", \"type\", \"values\"];\n    let dobj;\n    for (dobj of parsedElements) {\n      idMap[dobj.id] = dobj;\n      if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\n      let name = dobj.__fullname;\n      delete dobj.__fullname;\n      if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\n        // operation overload, in this case i create N separate operations, but all references will point to the last operation.\n        // empty on purpose, just avoid naming check\n      }\n      // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\n      // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\n      else Log.w(nameMap[typeprefix + name], \"found 2 elements with same name\", {\n        nameMap,\n        new: dobj,\n        old: nameMap[typeprefix + name],\n        name,\n        shortname: dobj.name,\n        typeprefix\n      });\n      nameMap[typeprefix + name] = dobj;\n      // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\n    }\n\n    for (let replacekey of replaceRules) {\n      for (dobj of parsedElements) {\n        let valtmp = dobj[replacekey];\n        if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\n        let values;\n        let isArray = Array.isArray(valtmp);\n        if (isArray) {\n          values = valtmp;\n          dobj[replacekey] = [];\n        } else {\n          values = [valtmp];\n        }\n        for (let value of values) {\n          if (!value) continue;\n          // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\n          let target = replacePrimitiveMap[value];\n          if (!target) target = nameMap[value];\n          if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\n            Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\n            target = replacePrimitiveMap[AttribETypes.EString];\n          }\n          /*\r\n          if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n              Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n              target = replacePrimitiveMap[AttribETypes.EString];\r\n          }*/\n          // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\n          // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\n\n          if (replacekey === \"extends\") {\n            if (!target) continue;\n            Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {\n              target,\n              dobj,\n              replacePrimitiveMap,\n              nameMap,\n              idMap\n            });\n            target.extendedBy.push(dobj.id);\n          }\n          Log.ex(!target, \"LinkAllNames() can't find type target:\", {\n            value,\n            nameMap,\n            replacePrimitiveMap,\n            dobj,\n            replacekey\n          });\n          if (isArray) dobj[replacekey].push(target.id);else dobj[replacekey] = target.id;\n        }\n      }\n    }\n\n    // fix from ordinals to Pointer<DEnumLiteral>\n    function DfromPtr(id) {\n      return !id ? undefined : DPointerTargetable.fromPointer(id, state);\n    }\n    function getLiteral(id, ordinal) {\n      var _LPointerTargetable$f, _LPointerTargetable$f2;\n      return (_LPointerTargetable$f = LPointerTargetable.fromD(DfromPtr(id))) === null || _LPointerTargetable$f === void 0 ? void 0 : (_LPointerTargetable$f2 = _LPointerTargetable$f.ordinals[ordinal]) === null || _LPointerTargetable$f2 === void 0 ? void 0 : _LPointerTargetable$f2.__raw;\n    }\n    for (let elem of parsedElements) {\n      if (elem.className !== DValue.cname) continue;\n      let dval = elem;\n      let meta = DfromPtr(dval.instanceof);\n      if (!meta) continue;\n      let type = DfromPtr(meta.type);\n      if (!type || type.className !== DEnumLiteral.cname) continue;\n      let mapper = v => {\n        if (typeof v !== \"number\") {\n          Log.e(\"found non-numeric value in a literal value.\", v, dval);\n          return v;\n        }\n        let l = getLiteral(type.id, v);\n        return l ? l.id : v;\n      };\n      dval.values = dval.values.map(mapper);\n    }\n\n    // finally: set all pointedby\n    for (let ptrkey of PointedBy.list) for (dobj of parsedElements) {\n      let valtmp = dobj[ptrkey];\n      let values;\n      if (Array.isArray(valtmp)) {\n        values = valtmp;\n      } else {\n        if (valtmp === undefined) values = [];\n        // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\n        else values = [valtmp];\n      }\n      for (let value of values) {\n        if (!value) continue;\n        // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\n        let target = idMap[value];\n        if (target) {\n          target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\n        } else {\n          target = DfromPtr(value);\n          console.log(\"fixalltypes\", {\n            ptrkey,\n            valtmp,\n            dobj,\n            value,\n            values,\n            target,\n            idMap\n          });\n          if (!target) throw new Error(\"target undefined\");\n          SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey), '+=', false);\n        }\n      }\n    }\n    // update superclasses\n    this.updateSuperClasses(parsedElements);\n  }\n  static todoGetPrimitiveTypenope(type) {\n    // akready fixed in LinkAllNamesToID\n    return 'todoGetPrimitiveType from parser';\n  }\n  static updateSuperClasses(parsedElements) {\n    // todo:3\n  }\n  static fixNamingConflicts(parsedElements) {\n    // todo:4 final\n  }\n  static parseM2Model(json, filename) {\n    let generated = [];\n    if (!json) {\n      json = {};\n    }\n    let modelname = json[ECoreNamed.namee];\n    if (!modelname && filename) {\n      let pos = filename.indexOf(\".\");\n      modelname = pos === -1 ? filename : filename.substring(0, pos);\n    }\n    let dObject = DModel.new(modelname || \"imported_metamodel_1\", undefined, true, true);\n    console.log(\"made model\", json);\n    generated.push(dObject); // dObject.father = 'modeltmp' as any;\n    // const annotations: Json[] = this.getAnnotations(json); i set them on root package\n    // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\n    /// *** specific  *** ///\n    // let defPackage: DPackage = DPackage.new(json)\n    EcoreParser.parseRootPackage(dObject, json, generated);\n    return generated;\n  }\n  static parseM2Model_old(json, filename) {\n    let generated = [];\n    if (!json) {\n      json = {};\n    }\n    let modelname = json[ECoreNamed.namee];\n    if (!modelname && filename) {\n      let pos = filename.indexOf(\".\");\n      modelname = pos === -1 ? filename : filename.substring(0, pos);\n    }\n    let dObject = DModel.new(modelname || \"imported_metamodel_1\", undefined, true, true);\n    console.log(\"made model\", json);\n    generated.push(dObject); // dObject.father = 'modeltmp' as any;\n    /// *** specific  *** ///\n    const children = EcoreParser.getChildren(json);\n    const annotations = EcoreParser.getAnnotations(json);\n    // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\n    console.log(\"made model 2\", children, annotations);\n    for (let child of annotations) {\n      EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\n    }\n    console.log(\"made annotations\");\n    for (let child of children) {\n      EcoreParser.parseRootPackage(dObject, child, generated);\n    }\n    console.log(\"made packages\");\n    return generated;\n  }\n  static parseM1Model(json, meta, filename) {\n    var _meta;\n    let generated = [];\n    if (!json) {\n      json = {};\n    }\n    /// *** specific  *** ///\n    // this.parseDObject(json, dObject, DModel,undefined, generated);\n    let allmodels;\n    if (!meta && filename) {\n      allmodels = Selectors.getAll(DModel);\n      allmodels = allmodels.filter(m => m.name === filename);\n      meta = LPointerTargetable.fromD(allmodels[0]);\n    } else allmodels = [];\n    let xmlns = EcoreParser.XMLinlineMarker + \"xmlns:\";\n    let ns = undefined;\n    function findns(key) {\n      let pos = key.indexOf(\":\");\n      if (pos <= 0) return false;\n      return ns = key.substring(0, pos); // through namespace before the name of the root objects;\n      // additional method: through xmlns key\n      // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n      // ns = key.substring(xmlns.length); break;\n    }\n\n    outerloop: for (let key0 in json) {\n      // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\n      if (findns(key0)) break;\n      let val0 = json[key0];\n      if (typeof val0 === \"object\") for (let key1 in val0) {\n        if (findns(key0)) break outerloop;\n      }\n    }\n    if (ns && !meta) {\n      var _matchpkg$;\n      let allpkgs = Selectors.getAll(DPackage, undefined, undefined, true, true);\n      let matchpkg = allpkgs.filter(d => d.uri === ns);\n      meta = (_matchpkg$ = matchpkg[0]) === null || _matchpkg$ === void 0 ? void 0 : _matchpkg$.model;\n      // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\n    }\n\n    let modelname = '';\n    if (!modelname && filename) {\n      let pos = filename.indexOf(\".\");\n      modelname = pos === -1 ? filename : filename.substring(0, pos);\n    }\n    let dObject = DModel.new(modelname || \"imported_model_1\", (_meta = meta) === null || _meta === void 0 ? void 0 : _meta.id, false, true);\n    console.log(\"made model\", json);\n    generated.push(dObject);\n    for (let key in json) {\n      switch (key) {\n        case ECoreObject.xmi_version:\n          // this is only on roots\n          Log.ex(json[key] !== \"2.0\", \"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        // case ECoreObject.xmlnsecore:\n        case ECoreObject.xmlns_xmi:\n          let expected = \"http://www.omg.org/XMI\";\n          Log.ex(json[key] !== expected, \"Unexpected XMI schema. Should be \\\"\" + expected + \"\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        default:\n          // a feature name\n          let val = json[key];\n          if (!val) continue;\n          if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n          if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\n          const namespacedclass = key;\n          const mmclass = meta && meta.getClassByNameSpace(namespacedclass);\n          if (!mmclass) console.log(\"failed to get mmclass\", {\n            meta,\n            key,\n            mmclass\n          });\n          const roots_for_this_metaclass = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\n          for (let rootjson of roots_for_this_metaclass) {\n            // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\n            EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\n          }\n      }\n    }\n    return generated;\n  }\n  /*\r\n  {\r\n    \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n      \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n      \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n      \"-xmi:version\": \"2.0\",\r\n      \"Players\": [\r\n        { \"-name\": \"tizio\" },\r\n        { \"-name\": \"asd\" }\r\n      ]\r\n    }\r\n  }\r\n  */\n\n  /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\n  /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\n  static getobjectmetaclass(json, metaSuperClass) {\n    return metaSuperClass; // todo: comment this and execute below\n    let subclasses = !metaSuperClass ? [] : [metaSuperClass];\n    let subclasseshapes = {};\n    for (let sc of subclasses) {\n      subclasseshapes[sc.id] = {\n        l: sc\n      };\n      let row = subclasseshapes[sc.id];\n      for (let feat of sc.children) {\n        let lfeat = feat;\n        let dfeat = lfeat.__raw;\n        if (!dfeat.name || !dfeat.type) continue;\n        row[dfeat.name] = lfeat.type;\n      }\n    }\n    return this.findBestMatch(subclasseshapes, json);\n  }\n  static findBestMatch(m2classes, json) {\n    throw new Error(\"todo\");\n    return null;\n  }\n  static parseDObject(json, parent, parentType, meta, generated) {\n    var _meta2, _meta3;\n    if (!json) {\n      json = {};\n    }\n    meta = meta && this.getobjectmetaclass(json, meta);\n    // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\n    // let data: Partial<DObject> = {};\n    let dObject = DObject.new((_meta2 = meta) === null || _meta2 === void 0 ? void 0 : _meta2.id, parent.id, parentType, json[\"name\"] || \"obj_1\");\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) {\n      if (parentType === DModel) parent.objects.push(dObject.id);else parent.values.push(dObject.id);\n    }\n    console.log(\"made dobject\", {\n      json,\n      dObject,\n      meta,\n      metaname: (_meta3 = meta) === null || _meta3 === void 0 ? void 0 : _meta3.name\n    });\n    /// *** specific  *** ///\n    for (let key in json) {\n      switch (key) {\n        case ECoreObject.xmi_version:\n          // this is only on roots\n          Log.ex(json[key] !== \"2.0\", \"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        // case ECoreObject.xmlnsecore:\n        case ECoreObject.xmlns_xmi:\n          let expected = \"http://www.omg.org/XMI\";\n          Log.ex(json[key] !== expected, \"Unexpected XMI schema. Should be \\\"\" + expected + \"\\\", found instead: \\\"\" + json[key] + \"\\\"\");\n          break;\n        default:\n          // a feature name\n          let val = json[key];\n          if (!val) continue;\n          if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\n          if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\n          let metafeature = meta && meta[\"@\" + key];\n          console.log(\"feature meta\", {\n            json,\n            dObject,\n            key,\n            val,\n            metafeature,\n            classmeta: meta\n          });\n          let values;\n          if (Array.isArray(val)) values = val;else if (val === undefined) values = [];else values = [val];\n          EcoreParser.parseDValue(key, values, dObject /*father*/, metafeature /*meta*/, generated);\n        // DValue.new(key, metafeature?.id, values, dObject, true, false);\n      }\n    }\n\n    return generated;\n  }\n  static parseDValue(name, jsonvalues, parent, meta, generated) {\n    if (!jsonvalues) {\n      jsonvalues = [];\n    }\n    // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\n    console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\");\n    console.log(\"DValue.new(\", meta ? undefined : name, \",\", meta === null || meta === void 0 ? void 0 : meta.id, \",\", jsonvalues, \",\", parent.id);\n    let dValue = DValue.new(meta ? undefined : name, meta === null || meta === void 0 ? void 0 : meta.id, [], parent.id, true, false);\n    generated.push(dValue);\n    dValue.father = parent.id;\n    parent.features.push(dValue.id);\n    console.log(\"made dValue\", {\n      jsonvalues,\n      dValue,\n      meta,\n      metaname: meta === null || meta === void 0 ? void 0 : meta.name\n    });\n    if (meta && meta.className === DAttribute.cname) {\n      dValue.values = jsonvalues;\n      return generated;\n    }\n    for (let v of jsonvalues) {\n      if (typeof v !== \"object\") {\n        dValue.values.push(v);\n        continue;\n      }\n      // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\n      // generated.push(subdObject);\n      EcoreParser.parseDObject(v, dValue, DValue, meta === null || meta === void 0 ? void 0 : meta.type, generated);\n    }\n    return generated;\n  }\n  static parseDAnnotation(parent, json, generated, fullnamePrefix) {\n    return []; // todo\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    let dObject = DAnnotation.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    dObject.name = this.read(json, ECoreNamed.namee, undefined);\n    dObject.father = parent.id;\n    if (parent) parent.annotations.push(dObject.id);\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    dObject.__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\n    /// *** specific  *** ///\n    let key;\n    for (key in json) {\n      const value = json[key];\n      switch (key) {\n        //todo\n        default:\n          Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {\n            key,\n            value,\n            json\n          });\n          break;\n        // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\n        case ECoreAnnotation.details:\n          break;\n        case ECoreAnnotation.references:\n          break;\n        case ECoreAnnotation.source:\n          break;\n      }\n    }\n    // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\n    // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\n    // const details: Json[] = this.getDetails(json);\n    // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\n    return generated;\n  }\n  static parseRootPackage(parent, json, generated) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DPackage.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.packages.push(dObject.id);\n    let version = json[EcoreParser.prefix + \"xmlns:ecore\"] || '';\n    // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\n    // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\n    Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \" + version);\n    dObject.name = this.read(json, ECoreNamed.namee, 'default');\n    // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\n    dObject.__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    const subPackages = this.getSubPackages(json);\n    dObject.uri = this.read(json, ECorePackage.nsURI, null);\n    dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\n    console.warn(\"parseRootPackage.children\", {\n      childs,\n      annotations,\n      subPackages,\n      dObject,\n      generated\n    });\n    // if (!parent.uri) parent.uri = dObject.uri;\n    // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\n    for (let child of childs) {\n      switch (child[ECoreClass.xsitype]) {\n        default:\n          Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject);\n          break;\n        case 'ecore:EClass':\n          this.parseDClass(dObject, child, generated, '');\n          break;\n        case 'ecore:EEnum':\n          this.parseDEnum(dObject, child, generated, '');\n          break;\n      }\n    }\n    for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseSubPackage(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DPackage.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.subpackages.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\n    dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\n    const subPackages = this.getSubPackages(json);\n    console.warn(\"parseSubPackage.children\", {\n      childs,\n      annotations,\n      subPackages,\n      dObject,\n      generated\n    });\n    // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\n    // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\n    for (let child of childs) {\n      switch (child[ECoreClass.xsitype]) {\n        default:\n          Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject);\n          break;\n        case 'ecore:EClass':\n          this.parseDClass(dObject, child, generated, dObject.__fullname + \"/\");\n          break;\n        case 'ecore:EEnum':\n          this.parseDEnum(dObject, child, generated, dObject.__fullname + \"/\");\n          break;\n      }\n    }\n    for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDClass(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    let dObject = DClass.new(this.read(json, ECoreNamed.namee, 'Concept 1'), undefined, undefined, undefined, undefined, undefined, parent.id);\n    generated.push(dObject); // dObject.father = parent.id;\n    //if (parent) parent.classifiers.push(dObject.id);\n    //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    for (let key in json) {\n      switch (key) {\n        default:\n          Log.exx('unexpected field in parseDClass() |' + key + '|', json);\n          break;\n        case ECoreClass.eAnnotations:\n        case ECoreClass.instanceTypeName:\n        case ECoreClass.eSuperTypes:\n        case ECoreClass.xsitype:\n        case ECoreClass.eOperations:\n        case ECoreClass.eStructuralFeatures:\n        case ECoreClass.abstract:\n        case ECoreClass.interface:\n        case ECoreClass.namee:\n          break;\n      }\n    }\n    dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\n    dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\n    dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\n    let tmps = this.read(json, ECoreClass.eSuperTypes, '');\n    dObject.extends = tmps.split(' ');\n    const features = this.getChildren(json);\n    const functions = this.getChildren(json, false, true);\n    for (let child of functions) this.parseDOperation(dObject, child, generated, dObject.__fullname + \"/\");\n    for (let child of features) {\n      const xsiType = this.read(child, ECoreAttribute.xsitype);\n      switch (xsiType) {\n        default:\n          Log.exx('unexpected xsi:type: ', xsiType, ' in feature:', child);\n          break;\n        case 'ecore:EAttribute':\n          this.parseDAttribute(dObject, child, generated, dObject.__fullname + \"/\");\n          break;\n        case 'ecore:EReference':\n          this.parseDReference(dObject, child, generated, dObject.__fullname + \"/\");\n          break;\n      }\n    }\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDEnum(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DEnumerator.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.classifiers.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    for (let key in json) {\n      const value = json[key];\n      switch (key) {\n        default:\n          Log.exx('Enum.parse() unexpected key:', key, 'in json:', json);\n          break;\n        case ECoreEnum.eAnnotations:\n        case ECoreEnum.xsitype:\n        case ECoreNamed.namee:\n          break;\n        case ECoreEnum.eLiterals:\n          break;\n        case ECoreEnum.serializable:\n          dObject.serializable = value === 'true';\n          break;\n        case ECoreEnum.instanceTypeName:\n          dObject.instanceClassName = value + '';\n          break;\n      }\n    }\n    for (let child of childs) {\n      this.parseDEnumLiteral(dObject, child, generated, dObject.__fullname + \"/\");\n    }\n\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDEnumLiteral(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DEnumLiteral.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.literals.push(dObject.id);\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY); //vv4\n    dObject.literal = this.read(json, EcoreLiteral.literal, '');\n    dObject.name = this.read(json, ECoreNamed.namee, dObject.literal || 'literal_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDAttribute(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\n    let dObject = DAttribute.new(this.read(json, ECoreNamed.namee, 'attr_1'), this.read(json, ECoreAttribute.eType, AttribETypes.EString), parent.id);\n    generated.push(dObject); // dObject.father = parent.id;\n    // if (parent) parent.attributes.push(dObject.id);\n    //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDReference(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DReference.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.references.push(dObject.id);\n    dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.containment = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDParameter(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DParameter.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.parameters.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\n    dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\n    /// *** specific end *** ///\n    return generated;\n  }\n  static parseDOperation(parent, json, generated, fullnamePrefix) {\n    if (!generated) generated = [];\n    if (!json) {\n      json = {};\n    }\n    const childs = this.getChildren(json);\n    let dObject = DOperation.new();\n    generated.push(dObject);\n    dObject.father = parent.id;\n    if (parent) parent.operations.push(dObject.id);\n    dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\n    dObject.__fullname = fullnamePrefix + dObject.name;\n    const annotations = this.getAnnotations(json);\n    for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, dObject.__fullname + \"/\");\n    /// *** specific start *** ///\n    dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\n    dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\n    dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\n    dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\n    dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\n    dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\n    dObject.visibility = AccessModifier.package;\n    for (let child of childs) {\n      this.parseDParameter(dObject, child, generated, dObject.__fullname + \"/\");\n    }\n    /// *** specific end *** ///\n    return generated;\n  }\n\n  /*\r\n  static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n      if (!generated) generated = [];\r\n      if (!json) { json = {}; }\r\n      const childs = this.getChildren(json);\r\n      let dObject: DSomething = DSomething.new();\r\n      generated.push(dObject); dObject.father = parent.id;\r\n      if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n      dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n      (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n      const annotations: Json[] = this.getAnnotations(json);\r\n      for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n      /// *** specific start *** ///\r\n      for (let child of childs) {\r\n          this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n      }\r\n      /// *** specific end *** ///\r\n      return generated; }*/\n\n  /////////////////////////////////// generic\n  static getSubPackages(thiss) {\n    const ret = thiss[ECoreSubPackage.eSubpackages];\n    if (!ret || U.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static getAnnotations(thiss) {\n    const ret = thiss[ECorePackage.eAnnotations];\n    if (!ret || U.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static getDetails(thiss) {\n    const ret = thiss[ECoreAnnotation.details];\n    if (!ret || U.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static getChildren(thiss) {\n    let throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!thiss && !throwError) {\n      return [];\n    }\n    const mod = thiss[ECoreRoot.ecoreEPackage];\n    const pkg = thiss[ECorePackage.eClassifiers];\n    const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\n    const fun = thiss[ECoreOperation.eParameters];\n    const lit = thiss[ECoreEnum.eLiterals];\n    const ret = mod || pkg || cla || fun || lit;\n    /*if ( ret === undefined || ret === null ) {\r\n      if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n    }*/\n    Log.ex(throwError && !ret, 'getChildren() Failed: ', thiss, ret);\n    // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\n    if (!ret || U.isEmptyObject(ret)) {\n      return [];\n    }\n    if (Array.isArray(ret)) {\n      return ret;\n    } else {\n      return [ret];\n    }\n  }\n  static read(json, field) {\n    let valueIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'read<T>()CanThrowError';\n    let ret = json ? json[field] : null;\n    if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\n      Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\n      ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\n    }\n    if (ret === null || ret === undefined) {\n      Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<', '> failed: field[' + field + '], json: ', json);\n      return valueIfNotFound;\n    }\n    return ret;\n  }\n  static write(json, field, val) {\n    if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\n      Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\n      val = U.multiReplaceAll(val, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\n    } else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\n    json[field] = val;\n    return val;\n  }\n  static getEcoreTypeName(parent) {\n    if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\n    // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\n    return Log.ex(\"getEcoreTypeName failed\", parent);\n  }\n}\nEcoreParser.supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\nEcoreParser.prefix = '@';\nEcoreParser.XMLinlineMarker = '@';\nEcoreParser.classTypePrefix = '#//';\nexport let AccessModifier;\n(function (AccessModifier) {\n  AccessModifier[\"public\"] = \"public\";\n  AccessModifier[\"private\"] = \"private\";\n  AccessModifier[\"protected\"] = \"protected\";\n  AccessModifier[\"internal\"] = \"internal\";\n  AccessModifier[\"package\"] = \"package\";\n  AccessModifier[\"protectedinternal\"] = \"protected internal\";\n  AccessModifier[\"protectedprivate\"] = \"protected private\";\n})(AccessModifier || (AccessModifier = {}));\nexport class ECoreRoot {}\nECoreRoot.ecoreEPackage = void 0;\nexport class ECoreAnnotation {}\nECoreAnnotation.source = void 0;\nECoreAnnotation.references = void 0;\nECoreAnnotation.details = void 0;\nexport class ECoreNamed {}\nECoreNamed.namee = void 0;\nexport class ECoreDetail {}\nECoreDetail.key = void 0;\nECoreDetail.value = void 0;\nexport class ECoreSubPackage {}\nECoreSubPackage.eSubpackages = void 0;\nECoreSubPackage.eAnnotations = void 0;\nECoreSubPackage.eClassifiers = void 0;\nECoreSubPackage.nsURI = void 0;\nECoreSubPackage.nsPrefix = void 0;\nECoreSubPackage.namee = void 0;\nexport class ECorePackage extends ECoreSubPackage {}\nECorePackage.eAnnotations = void 0;\nECorePackage.eSubpackages = void 0;\nECorePackage.eClassifiers = void 0;\nECorePackage.xmlnsxmi = void 0;\nECorePackage.xmlnsxsi = void 0;\nECorePackage.xmiversion = void 0;\nECorePackage.xmlnsecore = void 0;\nECorePackage.nsURI = void 0;\nECorePackage.nsPrefix = void 0;\nECorePackage.namee = void 0;\nexport class ECoreClass {}\nECoreClass.eAnnotations = void 0;\nECoreClass.eStructuralFeatures = void 0;\nECoreClass.xsitype = void 0;\nECoreClass.namee = void 0;\nECoreClass.eOperations = void 0;\nECoreClass.instanceTypeName = void 0;\nECoreClass.eSuperTypes = void 0;\nECoreClass.abstract = void 0;\nECoreClass.interface = void 0;\nexport class ECoreEnum {}\nECoreEnum.eAnnotations = void 0;\nECoreEnum.xsitype = void 0;\nECoreEnum.namee = void 0;\nECoreEnum.instanceTypeName = void 0;\nECoreEnum.serializable = void 0;\nECoreEnum.eLiterals = void 0;\nexport class EcoreLiteral {}\nEcoreLiteral.eAnnotations = void 0;\nEcoreLiteral.namee = void 0;\nEcoreLiteral.value = void 0;\nEcoreLiteral.literal = void 0;\nexport class ECoreReference {}\nECoreReference.eAnnotations = void 0;\nECoreReference.xsitype = void 0;\nECoreReference.eType = void 0;\nECoreReference.containment = void 0;\nECoreReference.upperbound = void 0;\nECoreReference.lowerbound = void 0;\nECoreReference.namee = void 0;\nexport class ECoreAttribute {}\nECoreAttribute.eAnnotations = void 0;\nECoreAttribute.xsitype = void 0;\nECoreAttribute.eType = void 0;\nECoreAttribute.namee = void 0;\nECoreAttribute.lowerbound = void 0;\nECoreAttribute.upperbound = void 0;\nexport class ECoreOperation {}\nECoreOperation.eAnnotations = void 0;\nECoreOperation.eType = void 0;\nECoreOperation.eexceptions = void 0;\nECoreOperation.upperBound = void 0;\nECoreOperation.lowerBound = void 0;\nECoreOperation.unique = void 0;\nECoreOperation.ordered = void 0;\nECoreOperation.namee = void 0;\nECoreOperation.eParameters = void 0;\nexport class ECoreParameter {}\nECoreParameter.eAnnotations = void 0;\nECoreParameter.namee = void 0;\nECoreParameter.ordered = void 0;\nECoreParameter.unique = void 0;\nECoreParameter.lowerBound = void 0;\nECoreParameter.upperBound = void 0;\nECoreParameter.eType = void 0;\nexport class ECoreObject {}\nECoreObject.xmlns_xmi = void 0;\nECoreObject.xmlns_uri = void 0;\nECoreObject.xmi_version = void 0;\nexport class XMIModel {}\n\n///////////////\nXMIModel.type = void 0;\nXMIModel.namee = void 0;\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations = ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations = ECoreReference.eAnnotations = ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\nECoreAnnotation.details = 'details'; // arr\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\nECorePackage.eSubpackages = 'eSubpackages';\nECorePackage.eClassifiers = 'eClassifiers';\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreSubPackage.eSubpackages = 'eSubpackages';\nECoreSubPackage.eClassifiers = 'eClassifiers';\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\nECoreClass.eOperations = 'eOperations';\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\nECoreClass.namee = ECorePackage.namee;\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName'; // raw str\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\n\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\nECoreEnum.eLiterals = 'eLiterals';\nECoreEnum.namee = ECorePackage.namee;\nEcoreLiteral.literal = 'literal';\nEcoreLiteral.namee = ECorePackage.namee;\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\n\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\nECoreOperation.eParameters = 'eParameters';\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\n\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\n\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\n\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';","map":{"version":3,"names":["Log","DModel","DValue","DObject","DEnumerator","DEnumLiteral","DAttribute","DReference","DClass","DParameter","DOperation","DPackage","DAnnotation","AttribETypes","U","Selectors","PointedBy","LPointerTargetable","windoww","SetRootFieldAction","Constructors","store","SetFieldAction","DPointerTargetable","ShortAttribETypes","toLongEType","ShortDefaultEClasses","toLongEClass","SavePack","constructor","model","arguments","length","undefined","vertexpos","view","IStorage","get","exx","prefix","autosave","del","key","isOverwrite","set","parse","serialize","val","JSON","stringify","e","deserialize","set0","get0","LocalStorage","localStorage","getItem","getLastOpened","modelNumber","modelname","ret","KeyList","lastOpenedModel","lastOpenedView","lastOpenedPosition","deleteLastOpened","setLastOpened","vertex","EcoreParser","ecorejson","isMetamodel","filename","persist","parsedjson","temp","substring","console","log","paused","parsedElements","parseM2Model","parseM1Model","warn","LinkAllNamesToIDs","fixNamingConflicts","fixObjectPointers","tmpparse","wrapAll","tempfix_untilopennewtabisdone","dobjects","filter","className","cname","values","lobjects","fromArr","m1pointermap","o","ecorePointer","v","isMirage","modified","newvalues","map","from","to","id","elem","new","idMap","nameMap","replacePrimitiveMap","d_Estring","getAllPrimitiveTypes","EString","state","getState","typeprefix","shortkey","EVoid","shortetype","longetype","dClassType","getPrimitiveType","exDev","getDefaultEcoreClass","ecorename","replaceRules","dobj","name","__fullname","w","old","shortname","replacekey","valtmp","isArray","Array","value","target","indexOf","ww","ex","extendedBy","push","DfromPtr","fromPointer","getLiteral","ordinal","_LPointerTargetable$f","_LPointerTargetable$f2","fromD","ordinals","__raw","dval","meta","instanceof","type","mapper","l","ptrkey","list","pointedBy","Error","updateSuperClasses","todoGetPrimitiveTypenope","json","generated","ECoreNamed","namee","pos","dObject","parseRootPackage","parseM2Model_old","children","getChildren","annotations","getAnnotations","child","parseDAnnotation","_meta","allmodels","getAll","m","xmlns","XMLinlineMarker","ns","findns","outerloop","key0","val0","key1","_matchpkg$","allpkgs","matchpkg","d","uri","ECoreObject","xmi_version","xmlns_xmi","expected","namespacedclass","mmclass","getClassByNameSpace","roots_for_this_metaclass","rootjson","parseDObject","getobjectmetaclass","metaSuperClass","subclasses","subclasseshapes","sc","row","feat","lfeat","dfeat","findBestMatch","m2classes","parent","parentType","_meta2","_meta3","father","objects","metaname","metafeature","classmeta","parseDValue","jsonvalues","dValue","features","fullnamePrefix","read","ECoreAnnotation","details","references","source","childs","packages","version","supportedEcoreVersions","includes","subPackages","getSubPackages","ECorePackage","nsURI","nsPrefix","ECoreClass","xsitype","parseDClass","parseDEnum","parseSubPackage","subpackages","ECoreSubPackage","eAnnotations","instanceTypeName","eSuperTypes","eOperations","eStructuralFeatures","abstract","interface","instanceClassName","tmps","extends","split","functions","parseDOperation","xsiType","ECoreAttribute","parseDAttribute","parseDReference","classifiers","ECoreEnum","eLiterals","serializable","parseDEnumLiteral","literals","EcoreLiteral","Number","NEGATIVE_INFINITY","literal","eType","lowerBound","lowerbound","upperBound","upperbound","containment","fromBoolString","ECoreReference","getEcoreTypeName","parseDParameter","parameters","ordered","ECoreOperation","unique","operations","exceptions","eexceptions","visibility","AccessModifier","package","thiss","eSubpackages","isEmptyObject","getDetails","throwError","mod","ECoreRoot","ecoreEPackage","pkg","eClassifiers","cla","fun","eParameters","lit","field","valueIfNotFound","isObject","multiReplaceAll","write","classTypePrefix","ECoreDetail","xmlnsxmi","xmlnsxsi","xmiversion","xmlnsecore","ECoreParameter","xmlns_uri","XMIModel"],"sources":["C:/d/Programming/web/jodel-mde/src/api/data.ts"],"sourcesContent":["import type {\r\n    Json,\r\n    Pointer,\r\n    GObject,\r\n    Dictionary,\r\n    DocString} from \"../joiner\";\r\nimport {\r\n    Log,\r\n    DModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DClassifier,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    DOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    AttribETypes,\r\n    U,\r\n    CreateElementAction,\r\n    Selectors,\r\n    PointedBy,\r\n    LPointerTargetable,\r\n    windoww,\r\n    SetRootFieldAction,\r\n    Constructors,\r\n    store,\r\n    SetFieldAction,\r\n    DPointerTargetable, ShortAttribETypes, toLongEType, DState, Debug\r\n} from \"../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toLongEClass} from \"../common/U\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n        console.log(\"root parse\", {ecorejson, parsedjson});\r\n        // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.paused = true;\r\n        let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n        console.warn(\"parse.result D\", parsedElements);\r\n        this.LinkAllNamesToIDs(parsedElements);\r\n        this.fixNamingConflicts(parsedElements);\r\n        Constructors.paused = false;\r\n        // if (persist) CreateElementAction.newBatch(parsedElements);\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\r\n        Constructors.persist(parsedElements);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.cname) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.cname) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.values.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            //let lv: LValue = LPointerTargetable.from(v);\r\n            v.values = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.cname) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[1];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n        let state: DState = store.getState();\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in ShortAttribETypes) {\r\n            if (shortkey === ShortAttribETypes.EVoid) continue;\r\n            let shortetype: ShortAttribETypes = (ShortAttribETypes as GObject)[shortkey];\r\n            let longetype: AttribETypes = toLongEType(shortetype);\r\n            let dClassType: DClassifier = Selectors.getPrimitiveType(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n            // the correct one\r\n            replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\r\n        }\r\n        for (let shortkey in ShortDefaultEClasses) {\r\n            let shortetype: ShortDefaultEClasses = (ShortDefaultEClasses as GObject)[shortkey];\r\n            let longetype: DefaultEClasses = toLongEClass(shortetype);\r\n            let dClassType: DClassifier = Selectors.getDefaultEcoreClass(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n\r\n            // the correct one\r\n            replacePrimitiveMap[longetype] = dClassType;\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\r\n            if (idMap[replacePrimitiveMap[ecorename].id]) continue;\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\", \"values\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            idMap[dobj.id] = dobj;\r\n            if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\r\n            let name = (dobj as GObject).__fullname;\r\n            delete (dobj as GObject).__fullname;\r\n            if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\r\n                // operation overload, in this case i create N separate operations, but all references will point to the last operation.\r\n                // empty on purpose, just avoid naming check\r\n            }\r\n                // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\r\n            // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\r\n            else Log.w(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, new:dobj, old:nameMap[typeprefix + name], name, shortname: dobj.name, typeprefix});\r\n            nameMap[typeprefix + name] = dobj;\r\n            // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\r\n                        Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }\r\n                    /*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n                    // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fix from ordinals to Pointer<DEnumLiteral>\r\n        function DfromPtr<T extends DPointerTargetable>(id: Pointer<T>|null|undefined): T{ return !id ? undefined as any : (DPointerTargetable.fromPointer(id, state)); }\r\n        function getLiteral(id: Pointer<DEnumerator>, ordinal: number): DEnumLiteral { return LPointerTargetable.fromD(DfromPtr(id))?.ordinals[ordinal]?.__raw; }\r\n        for (let elem of parsedElements) {\r\n            if (elem.className !== DValue.cname) continue;\r\n            let dval: DValue = elem as DValue;\r\n            let meta: DAttribute | DReference = DfromPtr(dval.instanceof as Pointer<DAttribute|DReference>);\r\n            if (!meta) continue;\r\n            let type: DEnumerator = DfromPtr(meta.type) as DEnumerator;\r\n            if (!type || type.className !== DEnumLiteral.cname) continue;\r\n            let mapper = (v: unknown): Pointer<DEnumLiteral> => {\r\n                if (typeof v !== \"number\") { Log.e(\"found non-numeric value in a literal value.\", v, dval); return v as any; }\r\n                let l = getLiteral(type.id, v);\r\n                return l ? l.id : v as any;\r\n            }\r\n            dval.values = dval.values.map( mapper );\r\n        }\r\n\r\n        // finally: set all pointedby\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[];\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = DfromPtr(value);\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        // const annotations: Json[] = this.getAnnotations(json); i set them on root package\r\n        // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific  *** ///\r\n        // let defPackage: DPackage = DPackage.new(json)\r\n        EcoreParser.parseRootPackage(dObject, json, generated);\r\n        return generated;\r\n    }\r\n\r\n    static parseM2Model_old(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const children = EcoreParser.getChildren(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", children, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of children) {\r\n            EcoreParser.parseRootPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : [metaSuperClass];\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.children) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).values.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    let values: any[];\r\n                    if (Array.isArray(val)) values = val;\r\n                    else if (val as unknown === undefined) values = [];\r\n                    else values = [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.cname) { dValue.values = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.values.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        return []; // todo\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        (dObject as any).name = this.read(json, ECoreNamed.namee, undefined);\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        (dObject as GObject).__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) { //todo\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {key, value, json}); break;\r\n                // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseRootPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'default');\r\n        // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\r\n        (dObject as GObject).__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        console.warn(\"parseRootPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, ''); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, ''); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseSubPackage(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.subpackages.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        console.warn(\"parseSubPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\r\n        // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new(\r\n            this.read(json, ECoreNamed.namee, 'Concept 1'),\r\n            undefined as any, undefined as any, undefined as any, undefined as any, undefined, parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        //if (parent) parent.classifiers.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.eAnnotations:\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildren(json);\r\n        const functions: Json[] = this.getChildren(json, false, true);\r\n\r\n        for (let child of functions) this.parseDOperation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.eAnnotations:\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);//vv4\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\r\n        let dObject: DAttribute = DAttribute.new(\r\n            this.read(json, ECoreNamed.namee, 'attr_1'),\r\n            this.read(json, ECoreAttribute.eType, AttribETypes.EString),\r\n            parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        // if (parent) parent.attributes.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.containment = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getSubPackages(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreSubPackage.eSubpackages];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildren(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildren() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.ex(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\n\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECoreSubPackage { // <eSubpackages\r\n    static eSubpackages: string;\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECorePackage extends ECoreSubPackage {\r\n    static eAnnotations: string;\r\n    static eSubpackages: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations =\r\n    ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =  ECoreReference.eAnnotations =\r\n        ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eSubpackages = 'eSubpackages';\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreSubPackage.eSubpackages = 'eSubpackages';\r\nECoreSubPackage.eClassifiers = 'eClassifiers';\r\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}