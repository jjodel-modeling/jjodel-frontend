{"ast":null,"code":"var _dec, _class, _dec2, _class3, _class4, _dec3, _class5;\n// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\n// import {Mixin} from \"ts-mixer\";\nimport { Log } from \"../joiner\";\nimport { JsType, LModelElement, LNamedElement, RuntimeAccessible, store, windoww } from \"../joiner\";\nimport Swal from \"sweetalert2\";\nimport Storage from '../data/storage';\nimport { compressToUTF16, decompressFromUTF16 } from \"async-lz-string\";\nimport util from \"util\";\nimport Convert from \"ansi-to-html\";\n// var Convert = require('ansi-to-html');\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\n\nconsole.warn('loading ts U log');\nexport let Color = (_dec = RuntimeAccessible('Color'), _dec(_class = class Color {\n  constructor(r, g, b) {\n    this.r = void 0;\n    this.g = void 0;\n    this.b = void 0;\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  static fromHex(hex) {\n    return undefined;\n  }\n  static fromHLS(_ref) {\n    let {\n      h,\n      l,\n      s\n    } = _ref;\n    return undefined;\n  }\n  getHex() {\n    return undefined;\n  }\n  mixWith(c) {}\n  getHLS() {\n    return undefined;\n  }\n  duplicate() {\n    return undefined;\n  }\n}) || _class);\nexport let U = (_dec2 = RuntimeAccessible('U'), _dec2(_class3 = (_class4 = class U {\n  static async decompressState(state) {\n    return await decompressFromUTF16(state);\n  }\n  static async compressedState() {\n    return await compressToUTF16(JSON.stringify(store.getState()));\n  }\n  static isOffline() {\n    return Storage.read('offline') === 'true';\n  }\n  static refresh() {\n    window.location.reload();\n  }\n  static inspect(object, showHidden, depth, color) {\n    var _object;\n    let o0 = object;\n    object = ((_object = object) === null || _object === void 0 ? void 0 : _object.__raw) || object;\n    if (Array.isArray(object)) object = object.map(o => (o === null || o === void 0 ? void 0 : o.__raw) || o);\n    // todo: use lodash \"clonedeepwith\" to clean proxies\n    console.error(\"inspect\", {\n      o0,\n      object\n    });\n    return util.inspect(object, showHidden, depth, color);\n  }\n  static objectInspect(val) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    let color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let showHidden = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let ansiConvert = window.ansiConvert;\n    if (!ansiConvert) window.ansiconvert = ansiConvert = new Convert();\n    return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)), \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\n  }\n\n  // exponential: undefined = only if it's over digits. false = never, true = always.\n  static cropNum(num, digits, exponential) {\n    if (!digits || isNaN(num)) return '' + num;\n    if (exponential) return num.toExponential(digits);else if (exponential === undefined) {\n      let limit = 10 ** (digits - 1);\n      if (num >= limit || num <= -limit) return num.toExponential(digits);\n    }\n    let intpart = Math.trunc(num);\n    let s = '' + num;\n    if (intpart === num) return s;\n    let miss = s.length - digits;\n    if (miss > 0) s += '.' + Math.trunc(num % 1 * 10 ** (miss - 1));\n    return s;\n  }\n  static cropStr(msg) {\n    let linesStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    let linesEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    let stringRowStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 25;\n    let stringRowEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 25;\n    let arr = msg.split('\\n');\n    if (linesEnd + linesStart + 1 < arr.length) {\n      //arr = arr.slice(0, 10) + arr.slice(10, 0);\n      arr.splice(linesStart, arr.length - linesStart - linesEnd, '...');\n    }\n    let ret = '';\n    let i = 0;\n    for (let line of arr) {\n      if (stringRowEnd + stringRowStart + 1 < line.length) {\n        ret += line.substring(0, stringRowStart) + '...' + line.substring(line.length - stringRowEnd) + (i === arr.length - 1 ? '' : '\\n');\n      } else ret += line + (i === arr.length - 1 ? '' : '\\n');\n      i++;\n    }\n    return ret;\n  }\n  static extractByKey(dict, path) {\n    const keys = path.split('.');\n    const topic = keys[0];\n    const data = dict[topic];\n    const values = [];\n    if (!Array.isArray(data)) return undefined;\n    for (const d of data) {\n      let value = d;\n      for (const k of keys) if (value.hasOwnProperty(k)) value = value[k];\n      values.push(value);\n    }\n    return values;\n  }\n  static extractKeys(dict) {\n    const keys = [];\n    function traverse(obj, path) {\n      for (const key in obj) {\n        if (typeof obj[key] === 'object') traverse(obj[key], path ? `${path}.${key}` : key);else keys.push(path ? `${path}.${key}` : key);\n      }\n    }\n    for (const key in dict) {\n      traverse(dict[key][0], key);\n    }\n    return keys;\n  }\n\n  // damiano: eseguire una funzione costa in performance, anche se è brutto fare questi cast\n  static wrapper(obj) {\n    return obj;\n  }\n  // damiano: mi sa che c'era un metodo l.__serialize or something\n  static json(dElement) {\n    return JSON.parse(JSON.stringify(dElement.__raw));\n  }\n  static hexToPalette() {\n    for (var _len = arguments.length, hexs = new Array(_len), _key = 0; _key < _len; _key++) {\n      hexs[_key] = arguments[_key];\n    }\n    return {\n      type: \"color\",\n      value: hexs.map(hex => {\n        if (hex[0] === '#') hex = hex.substring(1);\n        let r,\n          g,\n          b,\n          a = 1;\n        if (hex.length === 4) {\n          a = Number.parseInt('0x' + hex[3] + hex[3]) / 255;\n          hex = hex.substring(0, 3);\n        }\n        if (hex.length === 7) {\n          a = Number.parseInt('0x' + hex[5] + hex[6]) / 255;\n          hex = hex.substring(0, 6);\n        }\n        Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {\n          hex,\n          a\n        });\n        let i = 0;\n        if (hex.length === 3) {\n          r = Number.parseInt('0x' + hex[i] + hex[i++]);\n          g = Number.parseInt('0x' + hex[i] + hex[i++]);\n          b = Number.parseInt('0x' + hex[i] + hex[i]);\n        } else {\n          r = Number.parseInt('0x' + hex[i++] + hex[i++]);\n          g = Number.parseInt('0x' + hex[i++] + hex[i++]);\n          b = Number.parseInt('0x' + hex[i++] + hex[i]);\n        }\n        return {\n          r,\n          g,\n          b,\n          a\n        };\n      })\n    };\n  }\n  static fatherChain(me) {\n    if (!me) return []; // without this line go through delete error\n    const fathers = [me.id];\n    const toCheck = [me];\n    while (toCheck.length > 0) {\n      const element = toCheck.pop();\n      if (element && element.father) {\n        fathers.push(element.father.id);\n        toCheck.push(element.father);\n      }\n    }\n    return fathers;\n  }\n\n  /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\n  static isShallowEqualWithProxies(obj1, obj2) {\n    let skipKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let out = arguments.length > 3 ? arguments[3] : undefined;\n    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n    let returnIfMaxDepth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let tobj1 = obj1 === null ? 'null' : typeof obj1;\n    let tobj2 = obj2 === null ? 'null' : typeof obj2;\n    if (obj1 === obj2) {\n      // if (out) { out.reason = \"identical objects\"; }\n      return true;\n    }\n    if (tobj1 !== tobj2) {\n      if (out) {\n        out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2;\n      }\n      return false;\n    }\n\n    // at this point: same type, but different values\n    switch (tobj1) {\n      default:\n        // primitive with different values\n        console.error(\"unexpected case in isshallowequal:\", {\n          tobj1,\n          obj1,\n          obj2\n        });\n        if (out) {\n          if (undefined === tobj1) out.reason = 'primitive value newly introduced';else if (undefined === tobj2) out.reason = 'primitive value got deleted';else out.reason = 'primitive value changedd';\n        }\n        return false;\n      case 'string':\n      case 'boolean':\n        // primitive with different values\n        if (out) {\n          if (undefined === tobj1) out.reason = 'primitive value newly introduced';else if (undefined === tobj2) out.reason = 'primitive value got deleted';else out.reason = 'primitive value changedd';\n        }\n        return false;\n      case \"number\":\n        // if both re nan it fails\n        // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\n        if (isNaN(obj1) && isNaN(obj2)) return true;\n        if (out) out.reason = 'number changed';\n        return false;\n      case \"function\":\n        if (obj1.toString() === obj2.toString()) break;\n        if (out) out.reason = 'function body changed';\n        return false;\n      case \"object\":\n        let o1Raw = obj1.__raw;\n        let o2Raw = obj2.__raw;\n        if (o1Raw) {\n          if (!o2Raw) {\n            if (out) out.reason = o1Raw.className + 'replaced by another object type:' + (o2Raw === null || o2Raw === void 0 ? void 0 : o2Raw.className);\n            return false;\n          }\n          obj1 = o1Raw;\n          obj2 = o2Raw;\n        }\n        // for proxies and DObjects\n        if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\n          if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter + ' != ' + obj2.clonedCounter;\n          return false;\n        } /*\r\n          if (obj1.className !== obj2.className) {\r\n          removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n          nd it's checked anyway in for(let key in obj1)\r\n             if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n             return false;\r\n          }*/\n        if (Array.isArray(obj1)) {\n          if (obj1.length !== obj2.length) {\n            if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\n            return false;\n          }\n          if (!Array.isArray(obj2)) {\n            if (out) out.reason = 'array became an object';\n            return false;\n          }\n        }\n        if (depth > maxDepth) {\n          // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\n          if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\n          return returnIfMaxDepth;\n        }\n        for (let key in obj1) {\n          if (key in skipKeys) continue;\n          let oldp = obj2[key];\n          let newp = obj1[key];\n          if (oldp === newp) continue;\n          if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth + 1, maxDepth, returnIfMaxDepth)) {\n            if (out) out.reason = '[' + key + ']' + out.reason;\n            return false;\n          }\n        }\n        // just check for keys that were in props and are not in nextProps\n        for (let key in obj2) {\n          if (key in skipKeys || key in obj1) continue;\n          if (out) out.reason = \"deleted subobject property: \" + key;\n          return false;\n        }\n      // else retIfMaxDepthReached; split the above if\n    }\n\n    return true;\n  }\n  static deepEqual(x, y) {\n    const tx = typeof x,\n      ty = typeof y;\n    return x && y && tx === 'object' && tx === ty ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key])) : x === y;\n  }\n  static sleep(s) {\n    return new Promise(resolve => setTimeout(resolve, s * 1000));\n  }\n  static getRandomString(length) {\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let randomString = '';\n    let index = 0;\n    while (index < length) {\n      const randomNumber = Math.floor(Math.random() * characters.length);\n      randomString += characters.charAt(randomNumber);\n      index += 1;\n    }\n    return randomString;\n  }\n  static alert(title, text) {\n    let color = 'text-';\n    switch (title.toLowerCase()) {\n      case 'error':\n        color += 'danger';\n        break;\n      default:\n        color += 'primary';\n    }\n    let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>';\n    html += `<div><b><label class='fs-5 mb-2 text-uppercase ${color}'>${title}</label></b><hr/>`;\n    html += `<label class='fs-6 mt-3'>${text}</label><br/>`;\n    const result = Swal.fire({\n      html: html,\n      backdrop: false,\n      showCloseButton: true,\n      showConfirmButton: false\n      //confirmButtonText: 'GOT IT'\n    });\n  }\n\n  static popup(element) {\n    let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>' + element;\n    const result = Swal.fire({\n      html: html,\n      backdrop: false,\n      showCloseButton: true,\n      showConfirmButton: false\n      //confirmButtonText: 'GOT IT'\n    });\n  }\n\n  static filteredPointedBy(data, label) {\n    const models = [];\n    for (let dict of data.pointedBy) {\n      const pointedBy = dict.source.split('.');\n      if (pointedBy.length === 3 && pointedBy[2] === label) {\n        models.push(LModelElement.fromPointer(pointedBy[1]));\n      }\n    }\n    return models;\n  }\n  static getFatherFieldToDelete(data) {\n    const father = data.father;\n    let field = '';\n    switch (father.className + '|' + data.className) {\n      // DPackage\n      case 'DModel|DPackage':\n        field = 'packages';\n        break;\n      case 'DPackage|DPackage':\n        field = 'subpackages';\n        break;\n      // DEnumerator and DClass\n      case 'DPackage|DEnumerator':\n      case 'DPackage|DClass':\n        field = 'classifiers';\n        break;\n      // DAttribute\n      case 'DClass|DAttribute':\n        field = 'attributes';\n        break;\n      // DReference\n      case 'DClass|DReference':\n        field = 'references';\n        break;\n      // DOperation\n      case 'DClass|DOperation':\n        field = 'operations';\n        break;\n      // DEnumLiteral\n      case 'DEnumerator|DEnumLiteral':\n        field = 'literals';\n        break;\n      // DObject\n      case 'DModel|DObject':\n        field = 'objects';\n        break;\n      // DParameter\n      case 'DOperation|DParameter':\n        field = 'parameters';\n        break;\n      // DValue\n      case 'DObject|DValue':\n        field = 'features';\n        break;\n      // Error\n      default:\n        return null;\n    }\n    return field;\n  }\n  static initializeValue(typeclassifier) {\n    // if(!classifier) return 'null';\n    const pointer = typeof typeclassifier === 'string' ? typeclassifier : typeclassifier === null || typeclassifier === void 0 ? void 0 : typeclassifier.id;\n    const me = LNamedElement.fromPointer(pointer);\n    switch (me === null || me === void 0 ? void 0 : me.name) {\n      default:\n      case 'EString':\n        return '';\n      case 'EChar':\n        return 'a';\n      case 'EInt':\n        return '0';\n      case 'ELong':\n        return '0';\n      case 'EShort':\n        return '0';\n      case 'Byte':\n        return '0';\n      case 'EFloat':\n        return '0';\n      case 'EDouble':\n        return '0';\n      case 'EBoolean':\n        return 'false';\n      case 'EDate':\n        return new Date().toJSON().slice(0, 10);\n    }\n    return 'null';\n  }\n  static orderChildrenByTimestamp(context) {\n    const children = context.proxyObject.children;\n    if (children && children.length > 0) {\n      let orderedChildren = new Map();\n      for (let child of children) {\n        let timestamp = child.id.slice(-13);\n        orderedChildren.set(+timestamp, child);\n      }\n      orderedChildren = new Map([...orderedChildren.entries()].sort());\n      return [...orderedChildren.values()];\n    } else return [];\n  }\n  static followPath(base, path) {\n    let patharr = path.split('.');\n    let base0 = base;\n    let ret = {};\n    ret.keys = patharr;\n    ret.chain = [base];\n    let lastObject = base;\n    for (let i = 0; i < patharr.length; i++) {\n      let path = ret.lastkey = patharr[i];\n      lastObject = base;\n      base = base[path];\n      ret.chain.push(base);\n      if (typeof base !== \"object\" || i + 1 === patharr.length) {\n        ret.failedRemainingPath = patharr.slice(i);\n        ret.lastval = base;\n        ret.lastObject = lastObject;\n        return ret;\n      }\n    }\n    throw new Error(\"followPath should never reach here\");\n    return ret;\n  }\n  static multiReplaceAllKV(a) {\n    let kv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const keys = [];\n    const vals = [];\n    let i;\n    for (i = 0; i < kv.length; i++) {\n      keys.push(kv[i][0]);\n      vals.push(kv[i][0]);\n    }\n    return U.multiReplaceAll(a, keys, vals);\n  }\n\n  // if replacement is empty, it will be filled with '';\n  // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\n  static multiReplaceAll(a) {\n    let searchText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\n    let i = -1;\n    while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\n    i = -1;\n    while (++i < searchText.length) {\n      a = U.replaceAll(a, searchText[i], replacement[i]);\n    }\n    return a;\n  }\n  static replaceAll(str, searchText, replacement) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let warn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    if (!str) {\n      return str;\n    }\n    return str.split(searchText).join(replacement || '');\n  }\n  static toFileName() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'nameless.txt';\n    if (!a) {\n      a = 'nameless.txt';\n    }\n    a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'], ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\n    return a;\n  }\n\n  // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\n  // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\n  // @ts-ignore\n  // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\n  static objectMergeInPlace(output) {\n    const out = output;\n    for (var _len2 = arguments.length, objarr = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      objarr[_key2 - 1] = arguments[_key2];\n    }\n    if (objarr) for (let o of objarr) {\n      if (o && typeof o === \"object\") for (let key in o) {\n        var _out$key;\n        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\n        (_out$key = out[key]) !== null && _out$key !== void 0 ? _out$key : out[key] = o[key];\n      }\n    }\n  }\n  static log(obj) {\n    let label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '###';\n    console.clear();\n    console.log(label, obj);\n  }\n  static removeEmptyObjectKeys(obj) {\n    for (let key of Object.keys(obj)) {\n      if (obj[key] === null || obj[key] === undefined) delete obj[key];\n    }\n  }\n\n  // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\n  // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\n  static objectMergeInPlace_conditional(output, condition) {\n    const out = output;\n    let i = 0;\n    for (var _len3 = arguments.length, objarr = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      objarr[_key3 - 2] = arguments[_key3];\n    }\n    for (let o of objarr) for (let key in o) {\n      if (condition(out, key, o, objarr, i++)) out[key] = o[key];\n    }\n    return out;\n  }\n  static buildFunctionDocumentation(f) {\n    Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\n    // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\n    let ret = {\n      parameters: [],\n      returns: undefined,\n      f: f,\n      fname: undefined,\n      isLambda: null,\n      signature: ''\n    };\n    let str = f.toString();\n    let starti = str.indexOf('(');\n    let endi;\n    let parcounter = 1;\n    for (endi = starti + 1; endi < str.length; endi++) {\n      if (str[endi] === ')' && --parcounter === 0) break;\n      if (str[endi] === '(') parcounter++;\n    }\n    let parameterStr = str.substring(starti + 1, endi);\n    // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\n    ret.fname = str.substr(0, starti).trim();\n    ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\n    // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\n    if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\n\n    let returnstarti = str.indexOf('/*', endi + 1);\n    let returnendi = -1;\n    let bodystarti = str.indexOf('{', endi + 1);\n    if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\n      // no return type or comment is past body\n      ret.returns = undefined;\n    } else {\n      returnendi = str.indexOf('*/', returnstarti + 2);\n      ret.returns = str.substring(returnstarti + 2, returnendi).trim();\n      bodystarti = str.indexOf('{', returnendi);\n    }\n    if (ret.returns === '') ret.returns = undefined;\n\n    // is lambda if do not have curly body or contains => between return comment and body\n    // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\n    ret.isLambda = bodystarti === -1 || str.substring(window.Math.max(endi, returnendi) + 1, bodystarti).trim() === '=>';\n    let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\n    let match;\n    while (match = regexp.exec(parameterStr + ',')) {\n      // match[0] is always the full match (not a capture group)\n      // match[2] can only be \"=\" or empty string\n      // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\n      let par = {\n        name: match[1],\n        defaultVal: match[3],\n        typedesc: match[4] && match[4].length > 1 ? match[4] : null\n      };\n      par.name = par.name.trim();\n      par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\n      par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\n      ret.parameters.push(par);\n    }\n    // set signature\n\n    ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\n    let i;\n    for (i = 0; i < ret.parameters.length; i++) {\n      let par = ret.parameters[i];\n      ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\n    }\n    ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\n    return ret;\n  }\n\n  // NB: need to use result.apply(context) to have a usable \"this\"\n  // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\n  //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\n  // rest values are declared with ellipsis in codestrParamNames\n  // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\n  // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\n  // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\n  static parseFunctionWithContextAndScope(codeStr0, context0, scope0, codestrParamNames) {\n    let protectShallowValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let doIdentifierValidation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    if (!codestrParamNames) codestrParamNames = [];\n    let codeStr = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\n    let scopeParams = '';\n    let scope;\n    let context;\n    if (protectShallowValues) {\n      if (scope0) {\n        //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\n        scope = {};\n        for (let k in scope0) scope[k] = scope0[k];\n      } else scope = undefined;\n      if (context0) {\n        // context = {...context0}; context.__proto__ = context0.__proto__;\n        context = {};\n        for (let k in context0) context[k] = context0[k];\n      } else context = undefined;\n    } else {\n      scope = scope0;\n      context = context0;\n    }\n    if (scope) {\n      let scopekeys = Object.keys(scope);\n      if (doIdentifierValidation) scopekeys.map(key => {\n        var _key4;\n        key = ((_key4 = key) === null || _key4 === void 0 ? void 0 : _key4.trim()) || '';\n        if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\n        return key;\n      }).filter(k => !!k);\n      scopeParams = '{' + scopekeys.join(',') + '}';\n    }\n    let innerFuncParams = codestrParamNames.join(',');\n    let _jevalfunc = undefined; // is set by eval\n    const evalmode = false;\n    console.log('parseFunctionWithContextAndScope', {\n      codeStr,\n      scope,\n      context,\n      params: {\n        scopeParams,\n        innerFuncParams\n      }\n    });\n    scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\n    if (evalmode) {\n      codeStr = \"_jevalfunc = function (\" + scopeParams + \") { return (\" + codeStr + \")(\" + innerFuncParams + \") }\";\n      eval(codeStr);\n    } else {\n      _jevalfunc = new Function(scopeParams, \" return (\" + codeStr + \")(\" + innerFuncParams + \")\");\n    }\n    console.log('parseFunctionWithContextAndScope', {\n      _jevalfunc,\n      params: {\n        scopeParams\n      }\n    });\n    if (context) return _jevalfunc.bind(context);else return _jevalfunc;\n  } /*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\n  static evalInContextAndScopeNew(codeStr, context0, injectScopeToo, protectShallowValues, doIdentifierValidation) {\n    return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\n  }\n\n  // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\n\n  // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\n  // can modify scope AND context\n  // warn: can access global scope (window)\n  // if the context (this) is missing it will take the scope as context.\n  // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\n  // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\n  // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\n  static evalInContextAndScope(codeStr, scope0, context0, protectShallowValues, doIdentifierValidation) {\n    // console.log('evalInContextAndScope', {codeStr, scope, context});\n    // scope per accedere a variabili direttamente \"x + y\"\n    // context per accedervi tramite this, possono essere impostati come diversi.\n    if (!scope0 && !context0) {\n      Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {\n        codeStr,\n        scope0,\n        context0\n      });\n    }\n\n    // scope.this = scope.this || context || scope; non funziona\n    // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\n    // eslint-disable-next-line no-restricted-syntax,no-with\n    // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\n    // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\n    let _ret = null;\n    let scope;\n    let context;\n    if (protectShallowValues) {\n      if (scope0) {\n        scope = {\n          ...scope0,\n          __proto__: scope0.__proto__\n        };\n        scope.__proto__ = scope0.__proto__;\n      } else scope = undefined;\n      if (context0) {\n        context = {\n          ...context0,\n          __proto__: context0.__proto__\n        };\n        context.__proto__ = context0.__proto__;\n      } else context = undefined;\n    } else {\n      scope = scope0;\n      context = context0;\n    }\n    Log.w(!!(!context && scope), \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" + \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" + \"Autofixed by assigning context = scope;\");\n    Log.eDev(!!(context && scope && context !== scope), \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" + \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\n    if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\n\n    /*\r\n    if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n    if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n    if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\n    //      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\n    let prefixDeclarations = \"\",\n      postfixDeclarations = '';\n    if (scope) {\n      if (U.isStrict) {\n        for (let key in scope) {\n          if (doIdentifierValidation) {\n            key = key.trim();\n            if (!key || !U.validIdentfierRegexp.test(key)) continue;\n          }\n          // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\n          prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\n          postfixDeclarations = \"\";\n        }\n      } else {\n        prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\n        postfixDeclarations = \" }\";\n      }\n    }\n    if (scope && context) {\n      if (typeof codeStr === \"function\") {\n        codeStr = codeStr.toString();\n      } // functions cannot change scope (with statement is deprecated)\n      context._eval = {\n        __codeStr: codeStr\n      }; // necessary to reach this._eval.codeStr inside the eval()\n      // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\n      _ret = new Function(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\n      delete context._eval;\n    } else if (!scope && context) {\n      if (typeof codeStr === \"function\") {\n        _ret = function () {\n          for (var _len4 = arguments.length, a = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n            a[_key5] = arguments[_key5];\n          }\n          return codeStr.call(context, ...a);\n        };\n        // _ret = (...a: any)=>codeStr.call(context, ...a);\n      } else {\n        // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\n        context._eval = {\n          __codeStr: codeStr\n        }; // necessary to reach this._eval.codeStr inside the eval()\n        _ret = new Function(\"return eval( this._eval.__codeStr );\").call(context);\n        delete context._eval;\n        // this below  is not good, as i need to quote the expanded result of codeStr,\n        // but since it might contain quotes as well i would need to escape them too.\n        // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\n      }\n    } else if (scope && !context) {\n      // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\n      // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\n      if (typeof codeStr === \"function\") {\n        codeStr = codeStr.toString();\n      } // functions cannot change scope (with statement is deprecated)\n      _ret = eval(prefixDeclarations + codeStr + postfixDeclarations);\n    }\n    return _ret;\n  }\n\n  //T extends ( ((...args: any[]) => any) | (() => any)\n  static execInContextAndScope(func, parameters, scope, context) {\n    Log.l(false, 'execInCtxScope', {\n      func,\n      parameters,\n      scope,\n      context\n    });\n    let ret;\n    const _eval = {\n      context,\n      scope,\n      func,\n      parameters: parameters || []\n    };\n    let prefixDeclarations = \"\",\n      postfixDeclarations = '';\n    if (scope) {\n      if (U.isStrict) {\n        for (let key in scope) {\n          // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\n          prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\n          postfixDeclarations = \"\";\n        }\n      } else {\n        prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\n        postfixDeclarations = \" }\";\n      }\n    }\n    if (!scope && !context) {\n      Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {\n        func,\n        scope,\n        context\n      });\n    }\n    if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\n    if (scope && context) {\n      context._eval = _eval;\n      // will the scope work with \"with\" outside the function body?\n      ret = new Function(prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\n      delete context._eval;\n    }\n    if (!scope && context) {\n      return _eval.func.apply(_eval.context, _eval.parameters);\n    }\n    if (scope && !context) {\n      // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\n      return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations);\n    }\n    return ret;\n  }\n\n  // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\n  // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\n  // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\n  // warn4: richiede un return per leggere il valore\n  // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\n  static execInScope_DO_NOT_USE(codeStr, scope) {\n    return new Function(...Object.keys(scope), codeStr)(...Object.values(scope));\n  }\n\n  // can modify context in-place, requires \"this\" before variable\n  static evalInContext(js, context) {\n    //# Return the results of the in-line anonymous function we .call with the passed context\n    return function () {\n      return eval(js);\n    }.call(context);\n  } /*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n       return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n     // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n    */\n  static highOrderFunctionExampleTyped(func) {\n    const funcName = func.cname || func.name;\n\n    // Return a new function that tracks how long the original took\n    return function () {\n      console.time(funcName);\n      const results = func(...arguments);\n      console.timeEnd(funcName);\n      return results;\n    };\n  }\n  static asClass(obj, classe) {\n    let elseReturn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return obj instanceof classe ? obj : elseReturn;\n  }\n  static asString(propKey) {\n    let elseReturn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return typeof propKey === 'string' ? propKey : elseReturn;\n  }\n  static isString(propKey) {\n    return typeof propKey === 'string';\n  }\n  static loadScript(path) {\n    let useEval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const script = document.createElement('script');\n    script.src = path;\n    script.type = 'text/javascript';\n    Log.eDev(useEval, 'loadScript', 'useEval', 'useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\n    document.body.append(script);\n  }\n  static ancestorArray(domelem, stopNode) {\n    let includeSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // [0]=element, [1]=father, [2]=grandfather... [n]=document\n    if (domelem === null || domelem === undefined) {\n      return [];\n    }\n    const arr = includeSelf ? [domelem] : [];\n    let tmp = domelem.parentNode;\n    while (tmp !== null && tmp !== stopNode) {\n      arr.push(tmp);\n      tmp = tmp.parentNode;\n    }\n    return arr;\n  }\n  static toHtml(html, container) {\n    let containerTag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'div';\n    if (!container) {\n      container = document.createElement(containerTag);\n    }\n    Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\n    container.innerHTML = html;\n    const ret = container.firstChild;\n    if (ret) container.removeChild(ret);\n    return ret;\n  }\n  static levenshtein(a, b) {\n    if (!a.length) return b.length;\n    if (!b.length) return a.length;\n    let cost = a.charAt(a.length - 1) === b.charAt(b.length - 1) ? 0 : 1;\n    return window.Math.min(U.levenshtein(a.substring(0, a.length - 1), b) + 1, U.levenshtein(a, b.substring(0, b.length - 1)) + 1, U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost);\n  }\n  static getClosestPropertyName(names, name) {\n    let lowest = Infinity;\n    return names.reduce(function (previous, current) {\n      let distance = U.levenshtein(current, name);\n      if (distance < lowest) {\n        lowest = distance;\n        return current;\n      }\n      return previous;\n    }, '');\n  }\n  static getClosestPropertyNames(names, name) {\n    let distances = names.map(value => {\n      return {\n        distance: U.levenshtein(value, name),\n        value\n      };\n    });\n    return distances.sort((a, b) => a.distance - b.distance).map(e => e.value);\n  }\n\n  //todo for console\n  static autoCorrectProxy(target, recursive, logger) {\n    return new Proxy(target, {\n      get: function (target, name) {\n        let namestr = U.asString(name, null);\n        if (!namestr) return undefined;\n        if (name in target) return target[namestr];\n        const suggestions = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\n        logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\n        return namestr && target[suggestions[0]];\n      }\n    });\n  }\n  static arrayRemoveAll(arr, elem) {\n    let debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let index;\n    if (!arr) return;\n    while (true) {\n      index = arr.indexOf(elem);\n      Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\n      if (index === -1) {\n        return;\n      }\n      arr.splice(index, 1);\n      Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\n    }\n  }\n  static arrayUnique(arr) {\n    return [...new Set(arr)];\n  }\n  static fileReadContent(file, callback) {\n    const textType = /text.*/;\n    try {\n      if (!file.type || file.type.match(textType)) {\n        let reader = new FileReader();\n        reader.onload = function (e) {\n          callback('' + reader.result);\n        };\n        reader.readAsText(file);\n        return;\n      }\n    } catch (e) {\n      Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file);\n    }\n    Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file);\n  }\n  static fileRead(onChange, extensions, readContent) {\n    // $(document).on('change', (e) => console.log(e));\n    console.log(\"importEcore: pre file reader\");\n    myFileReader.show(onChange, extensions, readContent);\n  }\n  static clear(htmlNode) {\n    if (htmlNode) while (htmlNode.firstChild) {\n      htmlNode.removeChild(htmlNode.firstChild);\n    }\n  }\n  static clearAllTimeouts() {\n    const highestTimeoutId = setTimeout(() => {}, 1);\n    for (let i = 0; i < highestTimeoutId; i++) {\n      clearTimeout(i);\n    }\n  }\n  static getStackTrace() {\n    let sliceCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    const ret = Error().stack;\n    // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\n    // if (Array.isArray(ret)) return ret;\n    if (!ret) return ['UnknownStackTrace'];\n    const arr = ret.split('\\n');\n    // first 2 entries are \"Erorr\" and \"getStackTrace()\"\n    return sliceCalls > 0 ? arr.slice(sliceCalls) : arr;\n  }\n\n  // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\n  static getCaller() {\n    let stacksToSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const stack = this.getStackTrace(4);\n    // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\n    return stack[stacksToSkip];\n  }\n  // todo: use in Log.once\n  // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\n  static isFirstTimeCalledByThisLine() {\n    let stacksToSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const caller = this.getCaller(stacksToSkip);\n    if (U.gotcalledby[caller]) return false;\n    return U.gotcalledby[caller] = true;\n  }\n  static lineKey() {\n    return this.getCaller(0);\n  }\n\n  // Prevent the backspace key from navigating back.\n  static preventBackSlashHistoryNavigation(event) {\n    if (!event || !event.key || event.key.toLowerCase() !== 'backspace') {\n      return true;\n    }\n    const types = ['text', 'password', 'file', 'search', 'email', 'number', 'date', 'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\n    const srcElement = $(event['srcElement'] || event.target);\n    const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\n    if (!disabled) {\n      if (srcElement[0].isContentEditable || srcElement.is('textarea')) {\n        return true;\n      }\n      if (srcElement.is('input')) {\n        const type = srcElement.attr('type');\n        if (!type || types.indexOf(type.toLowerCase()) > -1) {\n          return true;\n        }\n      }\n    }\n    event.preventDefault();\n    return false;\n  }\n  static SetMerge() {\n    let modifyFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    for (var _len5 = arguments.length, iterables = new Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {\n      iterables[_key6 - 1] = arguments[_key6];\n    }\n    const set = modifyFirst ? iterables[0] : new Set();\n    Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\n    for (let iterable of iterables) {\n      for (let item of iterable) {\n        set.add(item);\n      }\n    }\n    return set;\n  }\n\n  // merge with unique elements\n  static ArrayMergeU(arr1) {\n    for (var _len6 = arguments.length, arr2 = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {\n      arr2[_key7 - 1] = arguments[_key7];\n    }\n    U.ArrayMerge0(true, arr1, arr2);\n  }\n  // merge without unique check\n  static ArrayMerge(arr1) {\n    for (var _len7 = arguments.length, arr2 = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {\n      arr2[_key8 - 1] = arguments[_key8];\n    }\n    U.ArrayMerge0(false, arr1, arr2);\n  }\n  // implementation\n  static ArrayMerge0(unique, arrtarget) {\n    for (var _len8 = arguments.length, arrays = new Array(_len8 > 2 ? _len8 - 2 : 0), _key9 = 2; _key9 < _len8; _key9++) {\n      arrays[_key9 - 2] = arguments[_key9];\n    }\n    if (!arrtarget || !arrays) return;\n    if (unique) {\n      for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e);\n    } else {\n      for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri);\n    }\n  }\n  static ArrayAdd(arr, elem) {\n    let unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let throwIfContained = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\n    if (!unique) {\n      arr.push(elem);\n      return true;\n    }\n    if (arr.indexOf(elem) === -1) {\n      arr.push(elem);\n      return true;\n    }\n    Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\n    return false;\n  }\n\n  // static getID(): string { return U.idPrefix + U.maxID++; }\n\n  static getType(param) {\n    var _param$constructor;\n    switch (typeof param) {\n      default:\n        return typeof param;\n      case 'object':\n        return (param === null || param === void 0 ? void 0 : (_param$constructor = param.constructor) === null || _param$constructor === void 0 ? void 0 : _param$constructor.cname) || (param === null || param === void 0 ? void 0 : param.className) || \"{_rawobject_}\";\n      case 'function':\n        // and others\n        return \"geType for function todo: distinguish betweeen arrow and classic\";\n    }\n  }\n  static stringCompare(s1, s2) {\n    return s1 < s2 ? -1 : s1 > s2 ? 1 : 0;\n  }\n  static endsWith(str, suffix) {\n    if (Array.isArray(suffix)) {\n      for (let suf of suffix) {\n        if (U.endsWith(str, suf)) return true;\n      }\n      return false;\n    }\n    return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\n  }\n  static arrayMergeInPlace(arr1) {\n    for (var _len9 = arguments.length, otherArrs = new Array(_len9 > 1 ? _len9 - 1 : 0), _key10 = 1; _key10 < _len9; _key10++) {\n      otherArrs[_key10 - 1] = arguments[_key10];\n    }\n    for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\n    return arr1;\n  }\n  static getEndingNumber(s) {\n    let ignoreNonNumbers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowDecimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let i = s.length;\n    let numberEnd = -1;\n    while (--i > 0) {\n      if (!isNaN(+s[i])) {\n        if (numberEnd === -1) {\n          numberEnd = i;\n        }\n        continue;\n      }\n      if (s[i] === '.' && !allowDecimal) {\n        break;\n      }\n      if (s[i] === '.') {\n        allowDecimal = false;\n        continue;\n      }\n      if (!ignoreNonNumbers) {\n        break;\n      }\n      if (numberEnd !== -1) {\n        ignoreNonNumbers = false;\n      }\n    }\n    s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\n    return +parseFloat(s);\n  }\n  static increaseEndingNumber(s) {\n    let allowLastNonNumberChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowDecimal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let increaseWhile = arguments.length > 3 ? arguments[3] : undefined;\n    let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\n    const matches = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\n    // S flag removed for browser support (firefox), should work anyway.\n    let prefix;\n    let num;\n    if (!matches) {\n      prefix = s;\n      num = 2;\n    } else {\n      Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\n      let i = s.length - matches[0].length;\n      prefix = s.substring(0, i);\n      num = 1 + +matches[1];\n    }\n    if (increaseWhile) while (increaseWhile(prefix + num)) {\n      num++;\n    }\n    return prefix + num;\n  }\n  static shallowEqual(objA, objB) {\n    if (objA === objB) {\n      return true;\n    }\n    if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') {\n      return false;\n    }\n    var keysA = Object.keys(objA);\n    var keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n\n    // if (keysA.length !== keysB.length) { return false; }\n    // Test for A's keys different from B.\n    // var bHasOwnProperty = hasOwnProperty.bind(objB);\n    for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\n\n    // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\n    return true;\n  }\n\n  // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\n  static isNumber(o) {\n    return typeof o === \"number\" && !isNaN(o);\n  }\n  static getAllPrototypes(constructor) {\n    var _constructor$prototyp, _constructor$__proto_;\n    let chainoutoutrecursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let currentRecursion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let maxRecursion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n    let cache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\n    if (cache && constructor.__allprototypes) return constructor.__allprototypes;\n    let prototype = ((_constructor$prototyp = constructor.prototype) === null || _constructor$prototyp === void 0 ? void 0 : _constructor$prototyp.name) && constructor.prototype;\n    let __proto__ = ((_constructor$__proto_ = constructor.__proto__) === null || _constructor$__proto_ === void 0 ? void 0 : _constructor$__proto_.name) && constructor.__proto__;\n    if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\n    if (prototype) chainoutoutrecursive.push(prototype);\n    if (__proto__) chainoutoutrecursive.push(__proto__);\n    if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\n    if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\n    if (cache) constructor.__allprototypes = chainoutoutrecursive;\n    return chainoutoutrecursive;\n  }\n  static classIsExtending(subconstructor, superconstructor) {\n    var _extends;\n    return (superconstructor === null || superconstructor === void 0 ? void 0 : (_extends = superconstructor._extends) === null || _extends === void 0 ? void 0 : _extends.includes(subconstructor)) || false;\n    // return U.getAllPrototypes(subconstructor).includes(superconstructor);\n  }\n\n  static isObject(v) {\n    let returnIfNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let returnIfUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let retIfArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (v === null) {\n      return returnIfNull;\n    }\n    if (v === undefined) {\n      return returnIfUndefined;\n    }\n    if (Array.isArray(v)) {\n      return retIfArray;\n    }\n    // nb: mind that typeof [] === 'object'\n    return typeof v === 'object';\n  }\n  static objectFromArray(arr, getKey) {\n    // @ts-ignore\n    return arr.reduce((acc, val) => {\n      acc[getKey(val)] = val;\n      return acc;\n    }, {});\n  }\n  static objectFromArrayValues(arr) {\n    let val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // @ts-ignore\n    return arr.reduce((acc, val) => {\n      acc[val] = val;\n      return acc;\n    }, {});\n    /*let ret: Dictionary = {};\r\n    for (let val of arr) { ret[val] = true; }\r\n    return ret;*/\n  }\n\n  static toBoolString(bool) {\n    let ifNotBoolean = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return bool === true ? 'true' : bool === false ? 'false' : '' + ifNotBoolean;\n  }\n  static fromBoolString(str) {\n    let defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let allowNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let allowUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    str = ('' + str).toLowerCase();\n    if (allowNull && str === 'null') return null;\n    if (allowUndefined && str === 'undefined') return undefined;\n    if (str === \"true\" || str === 't' || str === '1') return true;\n    // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\n    if (str === \"false\" || str === 'f' || str === '0') return false;\n    return defaultVal;\n  }\n  static arrayDifference(starting, final) {\n    let ret = {};\n    ret.starting = starting;\n    ret.final = final;\n    if (!starting) starting = [];\n    if (!final) final = [];\n    ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\n    ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\n    return ret;\n  }\n\n  // returns <\"what changed from old to neww\"> and in nested objects recursively\n  // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\n  // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\n  static objectDelta(old, neww) {\n    let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let newwobj = neww;\n    let oldobj = old;\n    if (old === neww) return {};\n    let diff = U.objdiff(old, neww); // todo: optimize this, remove the 3 loops below and add those directly in U.objdiff(old, neww, ret); writing inside the obj in third parameter\n\n    let ret = {}; // {__isAdelta:true};\n    for (let key in diff.added) {\n      ret[key] = newwobj[key];\n    }\n    for (let key in diff.changed) {\n      let subold = oldobj[key];\n      let subnew = newwobj[key];\n      if (typeof subold === typeof subnew && typeof subold === \"object\") {\n        ret[key] = deep ? U.objectDelta(subold, subnew, true) : subnew;\n      } else ret[key] = subnew;\n    }\n    // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\n    let removedprefix = \"\"; // \"_-\";\n    for (let key in diff.removed) {\n      ret[removedprefix + key] = undefined;\n    } //newwobj[key]; }\n    // console.log(\"objdiff\", {old, neww, diff, ret});\n    return ret;\n  }\n\n  // difference react-style. lazy check by === equality field by field. parameters are readonly\n  static objdiff(old, neww) {\n    // let ret: GObject = {removed:{}, added:{}, changed:{}};\n    let ret = {\n      removed: {},\n      added: {},\n      changed: {},\n      unchanged: {}\n    };\n    if (!neww && !old) {\n      return ret;\n    }\n    if (!neww) {\n      ret.removed = old;\n      return ret;\n    }\n    if (!old) {\n      ret.added = neww;\n      return ret;\n    }\n    // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\n\n    let key;\n    for (key in old) {\n      // if (neww[key] === undefined){\n      // if neww have a key with undefined value, it counts (and should) as having that property key defined\n      if (!(key in neww)) {\n        ret.removed[key] = old[key];\n      } else if (neww[key] === old[key]) {\n        ret.unchanged[key] = old[key];\n      } else ret.changed[key] = old[key];\n    }\n    for (let key in neww) {\n      if (!(key in old)) {\n        ret.added[key] = neww[key];\n      }\n    }\n    return ret;\n  }\n  /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\n  static flattenObjectToRoot(obj) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let pathseparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    return Object.keys(obj).reduce((acc, k) => {\n      const pre = prefix.length ? prefix + pathseparator : '';\n      if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));else acc[pre + k] = obj[k];\n      return acc;\n    }, {});\n  }\n\n  // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\n  // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\n  // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\n  static ObjectToAssignementStrings(obj) {\n    let maxkeylength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    let maxsubpaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;\n    let maxvallength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n    let toolongreplacer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"…\";\n    let out = arguments.length > 5 ? arguments[5] : undefined;\n    let quotestrings = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n    const pathseparator = \".\";\n    const valueseparator = \" = \";\n    const filterrow = rowpaths => {\n      return !rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\");\n    };\n    let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\n    let i = -1;\n    let tmp;\n    let ret = [];\n    tmp = (maxkeylength - toolongreplacer.length) / 2;\n    let halfpath = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    tmp = (maxvallength - toolongreplacer.length) / 2;\n    let halfval = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    tmp = (maxsubpaths - toolongreplacer.length) / 2;\n    let halfsubpaths = {\n      start: window.Math.floor(tmp),\n      end: window.Math.ceil(tmp)\n    };\n    let bestpathsize = 0;\n    let best = null;\n    let countsize = (total, arrelem) => total + arrelem.length;\n    const filterbest = row => {\n      row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\n      if (!best || bestpathsize < row.pathlength && filterrow(row.fullpath)) {\n        best = row;\n        bestpathsize = row.pathlength;\n        if (out) out.best = best;\n        ret.best = best.str;\n      }\n    };\n    console.log(\"u get assignements\", {\n      flatten,\n      obj\n    });\n    for (let key in flatten) {\n      let row = {\n        fullpath: key.split(pathseparator),\n        fullstr: key\n      };\n      // if (!filterrow(row.fullpath)) continue;\n      // stringify(undefined) = undefined, so i add + \"\"\n      try {\n        if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\n      } catch (e) {\n        row.fullvalue = \"⁜not serializable⁜\";\n      }\n      // console.log(\"U get assignements loop\", {row, key, flatten, obj});\n      row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\n      if (row.fullpath.length > maxsubpaths) {\n        row.path = [...row.fullpath];\n        row.path.splice(halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\n      } else row.path = row.fullpath;\n\n      // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\n      row.path = row.path.map(p => p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end));\n      if (out) {\n        out.push(row);\n      }\n      row.str = row.path.join(pathseparator) + valueseparator + row.val;\n      ret.push(row.str);\n      filterbest(row);\n    }\n    return ret;\n  }\n  static download() {\n    let filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'nameless.txt';\n    let text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!text) {\n      return;\n    }\n    filename = U.toFileName(filename);\n    const htmla = document.createElement('a');\n    const blob = new Blob([text], {\n      type: 'text/plain',\n      endings: 'native'\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    Log.l(debug, text + '|\\r\\n| <-- rn, |\\n| <--n.');\n    htmla.style.display = 'none';\n    htmla.href = blobUrl;\n    htmla.download = filename;\n    document.body.appendChild(htmla);\n    htmla.click();\n    window.URL.revokeObjectURL(blobUrl);\n    document.body.removeChild(htmla);\n  }\n  static formatXml(xml) {\n    const reg = /(>)\\s*(<)(\\/*)/g;\n    const wsexp = / *(.*) +\\n/g;\n    const contexp = /(<.+>)(.+\\n)/g;\n    xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\n    const pad = '' || '\\t';\n    let formatted = '';\n    const lines = xml.split('\\n');\n    let indent = 0;\n    let lastType = 'other';\n    // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\n    const transitions = {\n      'single->single': 0,\n      'single->closing': -1,\n      'single->opening': 0,\n      'single->other': 0,\n      'closing->single': 0,\n      'closing->closing': -1,\n      'closing->opening': 0,\n      'closing->other': 0,\n      'opening->single': 1,\n      'opening->closing': 0,\n      'opening->opening': 1,\n      'opening->other': 1,\n      'other->single': 0,\n      'other->closing': -1,\n      'other->opening': 0,\n      'other->other': 0\n    };\n    let i = 0;\n    for (i = 0; i < lines.length; i++) {\n      const ln = lines[i];\n\n      // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\n      if (ln.match(/\\s*<\\?xml/)) {\n        formatted += ln + '\\n';\n        continue;\n      }\n      // ---\n\n      const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\n      const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\n      const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\n      const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\n      const fromTo = lastType + '->' + type;\n      lastType = type;\n      let padding = '';\n      indent += transitions[fromTo];\n      let j;\n      for (j = 0; j < indent; j++) {\n        padding += pad;\n      }\n      if (fromTo === 'opening->closing') {\n        formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\n      } else {\n        formatted += padding + ln + '\\n';\n      }\n    }\n    return formatted.trim();\n  }\n\n  // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\n  static circularStringify(obj, replacer, space) {\n    let maxDepth_unsupported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n    const cache = [];\n    return JSON.stringify(obj, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        // Duplicate reference found, discard key\n        if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\n        if (replacer) {\n          value = replacer(key, value);\n          if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\n        }\n        // Store value in our collection\n        cache.push(value);\n      }\n      return value;\n    }, space);\n  }\n  static getFirstNumber(s) {\n    let allowDecimalDot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allowDecimalComma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let valueifmismatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let commamode = allowDecimalComma ? allowDecimalDot ? \"(\\\\.|\\\\,)\" : \"\\\\,\" : allowDecimalDot ? \"\\\\.\" : \"will not use this regex\";\n    let floatregex = new RegExp(\"-?\" + commamode + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\n    let intregex = /-?\\d+/;\n    let ret;\n    if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);else ret = intregex.exec(s);\n    ret = ret && ret[0]; // first match\n    if (ret === null) return valueifmismatch;\n    let tmpindex;\n    if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\n    // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\n    while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex + 1); // ret.indexOf(.)\n    // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\n    return +ret;\n  }\n\n  // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\n  static isEmptyObject(obj) {\n    for (var i in obj) return false;\n    return true;\n  }\n  static pairArrayElementsRepeatFunc(val, index, arr) {\n    return [arr[index], arr[index + 1]];\n  }\n  static pairArrayElementsReducerFunc(accumulator, value, index, array) {\n    if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\n    return accumulator;\n  }\n\n  // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\n  // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\n  static pairArrayElements(arr) {\n    let withRepetitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (withRepetitions) {\n      return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length - 1);\n    }\n    return arr.reduce(U.pairArrayElementsReducerFunc, []);\n  }\n\n  // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\n  static decomment_all(str) {\n    return this.decomment_line(this.decomment_block(str));\n  }\n  // removes line comments //\n  static decomment_line(str) {\n    let trimLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return str.split(\"\\n\").map(s => {\n      let i = s.indexOf(\"//\");\n      s = i === -1 ? s : s.substring(i);\n      return trimLines ? s.trim() : s;\n    }).join(\"\\n\");\n  }\n  // removes block comments /**/\n  static decomment_block(str) {\n    // let maxcomments = 100;\n    while (true) {\n      // if (--maxcomments===0) break;\n      let s = str.indexOf(\"/*\");\n      if (s === -1) break;\n      let e = str.indexOf(\"*/\", s + 1);\n      if (e === -1) e = str.length;\n      str = str.substring(0, s) + str.substring(e + 2);\n    }\n    return str;\n  }\n  static uppercaseFirstLetter(str) {\n    if (typeof str !== \"string\") return str;\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  // CAREFUL! it's imperfect.\n  // Does not handle strings starting with ( that are not ()=> arrow functions\n  // or codes whose last chars are () but not in (function)() form\n  static wrapUserFunction(str) {\n    str = str.trim();\n    if (str[0] !== '(' || str.indexOf(\"function\") !== 0) {\n      str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\n    }\n\n    if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\n    return str;\n  }\n\n  // adds ellipsis in the middle of a string to truncate it when it's too long.\n  static stringMiddleCut(str, maxLength) {\n    let ellipsisChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '…';\n    let asArray = arguments.length > 3 ? arguments[3] : undefined;\n    if (!str || maxLength < 0 || str.length <= maxLength) return asArray ? [str] : str;\n    var midpoint = Math.ceil(str.length / 2);\n    var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\n    var lstrip = Math.ceil(toremove / 2); // left strip is the bigger one if odd chars\n    var rstrip = toremove - lstrip;\n    if (asArray) return [str.substring(0, midpoint - lstrip), ellipsisChar, str.substring(midpoint + rstrip)];else return str.substring(0, midpoint - lstrip) + ellipsisChar + str.substring(midpoint + rstrip);\n  }\n\n  // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\n  static invertHex(s) {\n    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';\n    let transformGrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\n    let r, g, b, h; // might be NaN if parseInt fails\n    if (s.length === 3 || s.length === 4) {\n      r = parseInt('0x' + s[0]); // works with hex numbers\n      g = parseInt('0x' + s[1]);\n      b = parseInt('0x' + s[2]);\n      h = s.length === 4 ? parseInt('0x' + s[4]) : undefined;\n    } else if (s.length === 6 || s.length === 8) {\n      r = parseInt('0x' + s.substring(0, 2));\n      g = parseInt('0x' + s.substring(2, 4));\n      b = parseInt('0x' + s.substring(4, 6));\n      h = s.length === 8 ? parseInt('0x' + s.substring(6, 8)) : undefined;\n    } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {\n      s\n    });\n    if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s + \", invalid red\", {\n      s\n    });\n    if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s + \", invalid green\", {\n      g\n    });\n    if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s + \", invalid blue\", {\n      b\n    });\n    transformGrays = transformGrays * 128;\n    r = Math.abs(r - 128) <= transformGrays ? r >= 128 ? 0 : 255 : 255 - r;\n    g = Math.abs(g - 128) <= transformGrays ? g >= 128 ? 0 : 255 : 255 - g;\n    b = Math.abs(b - 128) <= transformGrays ? b >= 128 ? 0 : 255 : 255 - b;\n    if (h || h === 0) h = 255 - h;\n    let rs = r.toString(16);\n    if (rs.length === 1) rs = '0' + rs;\n    let gs = g.toString(16);\n    if (gs.length === 1) gs = '0' + gs;\n    let bs = b.toString(16);\n    if (bs.length === 1) bs = '0' + bs;\n    let hs = h ? h.toString(16) : '';\n    if (hs.length === 1) hs = '0' + hs;\n    return prefix + rs + gs + bs + hs;\n  }\n  static parentUntil(tagName, p) {\n    while (p && p.tagName !== tagName) p = p.parentElement;\n    return p;\n  }\n  static paletteSplit(palette) {\n    let ret = {\n      color: {},\n      number: {},\n      text: {},\n      path: {}\n    };\n    for (let entry of Object.entries(palette)) {\n      let k = entry[0];\n      let v = entry[1];\n      ret[v.type][k] = v;\n    }\n    return ret;\n  }\n  static mergeNamedArray(ret, classes) {\n    for (let key of Object.getOwnPropertyNames(classes)) {\n      // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\n      if (key === \"length\") continue;\n      if (!isNaN(+key)) ret.push(classes[key]);\n      // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\n      if (!ret[key]) ret[key] = classes[key];\n    }\n  }\n  static async clipboardCopy(text, onSuccess, onFailure) {\n    let ret = false;\n    return navigator.clipboard.writeText(text).then(() => {\n      ret = true;\n      if (onSuccess) return onSuccess();\n    }, () => {\n      ret = U.clipboardCopy_old(text);\n      return ret ? onSuccess && onSuccess() : onFailure && onFailure();\n    });\n  }\n  static clipboardCopy_old(text) {\n    try {\n      if (!U.clipboardinput) {\n        U.clipboardinput = document.createElement('input');\n        U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\n        U.clipboardinput.type = 'text';\n        U.clipboardinput.style.display = 'block';\n        U.clipboardinput.style.position = 'absolute';\n        U.clipboardinput.style.top = '-100vh';\n      }\n      document.body.appendChild(U.clipboardinput);\n      U.clipboardinput.value = text;\n      U.clipboardinput.select();\n      if (!document.execCommand) return false;\n      let ret = document.execCommand('copy');\n      document.body.removeChild(U.clipboardinput);\n      U.clearSelection();\n      return ret;\n    } catch (e) {\n      return false;\n    }\n  }\n  static clearSelection() {}\n  static isError(obj) {\n    // obj istanceof Error // this is not iframe-safe, Errors from different iframes are considered different instances\n    // this is iframe-safe and catches all error types\n    return Object.prototype.toString.call(obj) === \"[object Error]\";\n    // or err.toString --> \"Error: message\" dunno if stack is printed too i tested with a fake error.\n  }\n\n  static toNamedArray(larr, darr) {\n    if (!darr || darr.length !== larr.length) darr = larr.map(l => l.__raw);\n    for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) larr[\"$\" + darr[i].name] = larr[i];\n    /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n        if (index === \"length\") continue;\r\n        let d = darr[index as any as number];\r\n        let l = larr[index as any as number];\r\n        if (!d || !l) continue;\r\n        (larr as any)[\"$\" + (d as any).name] = l;\r\n    }*/\n    return larr;\n  }\n  static cropDeepObject(o) {\n    let lines_start_crop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n    let lines_end_crop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    let string_start_crop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 45;\n    let string_end_crop = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 35;\n    let num_digit_crop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    if (!o) return o;\n    let replacer = o => {\n      switch (typeof o) {\n        default:\n          return o;\n        case \"string\":\n          return U.cropStr(o, lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\n        case \"function\":\n          return U.cropStr(o.toString(), lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\n        case \"number\":\n          return U.cropNum(num_digit_crop);\n        case \"object\":\n          if (o === null) return null;\n          if (U.isHtmlNode(o)) return '[HTMLElement]';\n          if (U.isError(o)) return {\n            stack: o.stack,\n            message: o.message\n          };\n          // if (U.isDate(o)) return \"[Date \"+o.getTime()+\"]\";\n          return o.__raw || o;\n      }\n    };\n    return U.deepReplace(o, replacer);\n  }\n  static deepCopy(obj, circularReferenceValue) {\n    return U.deepReplace(obj, undefined, circularReferenceValue);\n  }\n\n  // does make a deep copy too.\n  static deepReplace(obj, replacer) {\n    let circularReferenceValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : o => (o.__raw || o).id || '_circular_ref_';\n    const avoidloop = new WeakMap();\n    return U.deepReplace_rec(obj, avoidloop, replacer, circularReferenceValue);\n  }\n\n  /**\r\n   replacing always preserves same reference statuses. eg, when  {a:\"x\", b:\"x\"} -> {a:\"y\", b:\"y\"}\r\n   if the original x,y values are the same reference (not just value),\r\n   in the output object a,b will also be the same reference (replacer will not be called twice on the same string)\r\n     note that let arr = [\"a\", \"a\"] is an array with 2 equal values but different references.\r\n   while let a = \"a\"; let arr = [a, a] have equal references.\r\n     circularReferenceValue === \"__preserve\" causes any duplicate reference causing a loop to be replaced\r\n   with the target of the first reference instead of the \"__preserve\" string.\r\n     todo: add parameter eagerLoopReturn (current behaviour is eagerLoopReturn = true)\r\n   eagerLoopReturn = true returns as soon a duplicate objects is found, the returned structure is guaranteed to not have duplicates. [a,a] => [a,'loop','loop']\r\n   eagerLoopReturn = false returns 'loop' only if an object is already found AND have subobjects.\r\n   let a = {id:\"a1\", l:{b:1}};    [a,a] --> [{id:\"a1\", l:{b:1}, {id:\"a1\", l:'_loop_']\r\n   finaly eagerLoopReturn = 'inline' replaces with '_loop_' only when there is really a circular ref\r\n   (found an object already found in the current \"path\" from root to current obj)\r\n   so i need to copy the current map and pass a new copy every time i go deep on a new subobject, branching a tree.\r\n   let a = {id:\"a1\", l:{b:1}};    [a,a] will still return [a,a] with no '_loop_' tags\r\n   instead let a = {l:{b:1}, a:a};    [a,a] will return [{l:{b:1}, a:'_loop_'}, {l:{b:1}, a:'_loop_'}] with no '_loop_' tags\r\n   while\r\n   */\n  static deepReplace_rec(obj, avoidloop, replacer, circularReferenceValue, key) {\n    let curdept = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let eagerLoopReturn = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    if (typeof obj === \"symbol\") return replacer ? replacer(obj) : obj;\n    let old_obj = obj;\n    switch (typeof old_obj) {\n      case \"symbol\": // don't know what really do with symbols and funcs\n      case \"function\":\n        break;\n      default:\n        // because primitive types cannot be used as WeakMap.set(key), but can as Object keys\n        if (obj in avoidloop) return avoidloop[obj];else avoidloop[old_obj] = obj;\n        break;\n      case \"object\":\n        if (old_obj === null) {\n          if (avoidloop[old_obj]) return avoidloop[old_obj];else avoidloop[old_obj] = obj;\n          break;\n        }\n        if (avoidloop.has(obj)) {\n          // for objects\n          if (Array.isArray(obj) && obj.length === 0 || Object.keys(obj).length === 0) return obj;\n          if (circularReferenceValue === \"__preserve\" || typeof obj !== \"object\") return avoidloop.get(obj);else return typeof circularReferenceValue === \"function\" ? circularReferenceValue(obj) : circularReferenceValue;\n        } else avoidloop.set(old_obj, obj);\n        break;\n    }\n    if (replacer) obj = replacer(obj);\n    switch (typeof obj) {\n      default:\n        break;\n      // obj = obj; return obj; // for any leaf type\n      case \"object\":\n        if (U.isHtmlNode(obj)) return obj;\n        if (Array.isArray(obj)) {\n          obj = obj.map((o, i) => U.deepReplace_rec(o, avoidloop, replacer, circularReferenceValue, i, curdept + 1));\n          break;\n        }\n        let o = {};\n        for (let k in obj) {\n          o[k] = U.deepReplace_rec(obj[k], avoidloop, replacer, circularReferenceValue, k, curdept + 1);\n        }\n        obj = o;\n        break;\n    }\n    return obj;\n  }\n\n  // returns path to that object to find\n  static deepFindInObject(obj, subobject, compareFunc) {\n    let maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.POSITIVE_INFINITY;\n    const avoidloop = new WeakMap();\n    let ret = U.deepFindInObject_rec(obj, subobject, avoidloop, maxDepth, compareFunc);\n    if (ret === '') return 'this';else return ret;\n  }\n  static deepFindInObject_rec(obj, subobject, avoidloop, maxDepth, compareFunc) {\n    let curdepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    if (compareFunc ? compareFunc(obj, subobject) : obj === subobject) return '';\n    if (curdepth >= maxDepth) return undefined;\n    let old_obj = obj;\n    switch (typeof old_obj) {\n      default:\n        return undefined;\n      case \"object\":\n        if (old_obj === null) return undefined;\n        if (avoidloop.has(obj)) {\n          // for objects\n          return undefined;\n        } else avoidloop.set(old_obj, obj);\n        break;\n    }\n    switch (typeof obj) {\n      default:\n        return undefined;\n      case \"object\":\n        if (U.isHtmlNode(obj)) return undefined;\n        if (Array.isArray(obj)) {\n          for (let i = 0; i < obj.length; i++) {\n            let found = U.deepFindInObject_rec(obj[i], subobject, avoidloop, maxDepth, compareFunc, curdepth + 1);\n            if (found === '') return i + '';else if (found !== undefined) return i + '.' + found;\n          }\n          return undefined;\n        }\n        for (let k in obj) {\n          let found = U.deepFindInObject_rec(obj[k], subobject, avoidloop, maxDepth, compareFunc, curdepth + 1);\n          if (found === '') return k + '';\n          if (found !== undefined) return k + '.' + found;\n        }\n        return undefined;\n    }\n    return undefined;\n  }\n  static mailerror(recipients, title, msgbody_notencoded, canUseClipboard, clipboardSuccess, clipboardFailure) {\n    const msgbody = encodeURIComponent(msgbody_notencoded);\n    const mailtitle = encodeURIComponent(title);\n    // \"mailto:no-one@snai1mai1.com?subject=look at this website&body=Hi,I found this website and thought you might like it http://www.geocities.com/wowhtml\"\n    const gitissue = \"https://github.com/MDEGroup/jjodel/issues/new?title=\" + mailtitle + \"&body=\" + msgbody;\n    let mailto = \"mailto:\" + recipients.join(';') + \"?subject=\" + mailtitle + \"&body=\" + msgbody;\n    const mailtolimit = 2042 - 23 /*for safety*/;\n    /*\r\n        mailto: limits\r\n        2042 characters on Chrome 64.0.3282.186\r\n        2046 characters on Edge 16.16299\r\n        approximately 32700 characters on Firefox 58.0\r\n          max URI lengths:\r\n        chrome: 15613 chars\r\n        firefox: 15708\r\n    */\n    if (mailto.length > mailtolimit) {\n      if (canUseClipboard) {\n        const mailfallback = encodeURIComponent(\"mail body exceeded maximum mailto: link length.\\n\" + \"It has been copied to your clipboard, please past it here or use github issue report.\");\n        U.clipboardCopy(msgbody_notencoded, clipboardSuccess, clipboardFailure);\n        mailto = \"mailto:\" + recipients.join(';') + \"?subject=\" + mailtitle + \"&body=\" + mailfallback;\n      } else mailto = undefined;\n    }\n    return {\n      gitissue,\n      mailto\n    };\n  }\n\n  // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\n  static isHtmlNode(element) {\n    return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\n  }\n}, _class4.isStrict = function () {\n  return !this;\n}(), _class4.validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/, _class4.gotcalledby = {}, _class4.maxID = 0, _class4.idPrefix = '', _class4.getID = function* idgenerator() {\n  let i = 0;\n  while (true) yield i++;\n}(), _class4.prefix = 'ULibrary_', _class4.clipboardinput = void 0, _class4)) || _class3);\nexport class DDate {\n  static addDay(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setDate(date.getDate() + offset);\n    return ret;\n  }\n  static addMonth(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setMonth(date.getMonth() + offset);\n    return ret;\n  }\n  static addYear(date, offset, inplace) {\n    const ret = inplace ? date : new Date(date);\n    ret.setFullYear(date.getFullYear() + offset);\n    return ret;\n  }\n}\nDDate.cname = \"DDate\";\nexport class myFileReader {\n  // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\n  static setinfos(fileTypes, onchange, readcontent) {\n    myFileReader.fileTypes = fileTypes || myFileReader.fileTypes;\n    const debug = false;\n    debug && console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\n    myFileReader.input = document.createElement('input');\n    const input = myFileReader.input;\n    myFileReader.onchange = function (e) {\n      if (!readcontent) {\n        onchange(e, input.files, undefined);\n        return;\n      }\n      let contentObj = {};\n      let fileLetti = 0;\n      for (let i = 0; input.files && i < input.files.length; i++) {\n        const f = input.files[i];\n        debug && console.log('filereadContent[' + i + ']( file:', f, ')');\n        U.fileReadContent(f, content => {\n          var _input$files;\n          debug && console.log('file[' + i + '] read complete. done: ' + (1 + fileLetti) + ' / ' + ((_input$files = input.files) === null || _input$files === void 0 ? void 0 : _input$files.length), 'contentObj:', contentObj);\n          contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\n          // this is last file to read.\n          if (input.files && ++fileLetti === input.files.length) {\n            const contentArr = [];\n            for (let j = 0; j < input.files.length; j++) {\n              contentArr.push(contentObj[j]);\n            }\n            onchange(e, input.files, contentArr);\n          }\n        });\n      }\n    } || myFileReader.onchange;\n  }\n  static reset() {\n    myFileReader.fileTypes = undefined;\n    myFileReader.onchange = undefined;\n    myFileReader.input = undefined;\n  }\n  static show(onChange) {\n    let extensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let readContent = arguments.length > 2 ? arguments[2] : undefined;\n    console.log(\"importEcore: pre file reader\", myFileReader.input);\n    myFileReader.setinfos(extensions, onChange, readContent);\n    //if (!myFileReader.input) return;\n    myFileReader.input.setAttribute('type', 'file');\n    if (myFileReader.fileTypes) {\n      myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\n    }\n    //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\n    $(myFileReader.input).on('change.custom', myFileReader.onchange).trigger('click');\n    myFileReader.reset();\n  }\n}\nmyFileReader.input = null;\nmyFileReader.fileTypes = null;\nmyFileReader.onchange = null;\nexport let Uarr = (_dec3 = RuntimeAccessible('Uarr'), _dec3(_class5 = class Uarr {\n  static arrayIntersection(arr1, arr2) {\n    if (!arr1 || !arr2) return null;\n    return arr1.filter(e => arr2.indexOf(e) >= 0);\n  }\n  static arraySubtract(arr1, arr2, inPlace) {\n    let i;\n    const ret = inPlace ? arr1 : [...arr1];\n    for (i = 0; i < arr2.length; i++) {\n      U.arrayRemoveAll(ret, arr2[i]);\n    }\n    return ret;\n  }\n  static equals(a1, a2, deep) {\n    Log.ex(deep, \"deep array comparison is not supported yet\");\n    if (!a1 || !a2) return false;\n    if (a1.length !== a2.length) return false;\n    for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\n    return true;\n  }\n}) || _class5);\nexport class FocusHistoryEntry {\n  constructor(e, element, time) {\n    this.time = void 0;\n    this.evt = void 0;\n    this.element = void 0;\n    this.evt = e;\n    this.element = element || e.target;\n    this.time = time || new Date();\n  }\n}\nFocusHistoryEntry.cname = \"FocusHistoryEntry\";\nexport let ShortDefaultEClasses;\n(function (ShortDefaultEClasses) {\n  ShortDefaultEClasses[\"EObject\"] = \"EObject\";\n  ShortDefaultEClasses[\"EAnnotation\"] = \"EAnnotation\";\n  ShortDefaultEClasses[\"EClass\"] = \"EClass\";\n  ShortDefaultEClasses[\"EPackage\"] = \"EPackage\";\n  ShortDefaultEClasses[\"ENamedElement\"] = \"ENamedElement\";\n})(ShortDefaultEClasses || (ShortDefaultEClasses = {}));\nexport let ShortAttribETypes; // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\n/*\r\nECharObj  = 'ECharObj',\r\nEStringObj  = 'EStringObj',\r\nEDateObj  = 'EDateObj',\r\nEFloatObj  = 'EFloatObj',\r\nEDoubleObj  = 'EDoubleObj',\r\nEBooleanObj = 'EBooleanObj',\r\nEByteObj  = 'EByteObj',\r\nEShortObj  = 'EShortObj',\r\nEIntObj  = 'EIntObj',\r\nELongObj  = 'ELongObj',\r\nEELIST  = 'EELIST',*/\n(function (ShortAttribETypes) {\n  ShortAttribETypes[\"EVoid\"] = \"EVoid\";\n  ShortAttribETypes[\"EChar\"] = \"EChar\";\n  ShortAttribETypes[\"EString\"] = \"EString\";\n  ShortAttribETypes[\"EDate\"] = \"EDate\";\n  ShortAttribETypes[\"EBoolean\"] = \"EBoolean\";\n  ShortAttribETypes[\"EByte\"] = \"EByte\";\n  ShortAttribETypes[\"EShort\"] = \"EShort\";\n  ShortAttribETypes[\"EInt\"] = \"EInt\";\n  ShortAttribETypes[\"ELong\"] = \"ELong\";\n  ShortAttribETypes[\"EFloat\"] = \"EFloat\";\n  ShortAttribETypes[\"EDouble\"] = \"EDouble\";\n})(ShortAttribETypes || (ShortAttribETypes = {}));\nwindoww.ShortAttribETypes = ShortAttribETypes;\nexport const ShortAttribSuperTypes = {\n  \"EVoid\": [],\n  \"EChar\": [ShortAttribETypes.EString],\n  \"EString\": [],\n  \"EDate\": [],\n  \"EBoolean\": [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EByte\": [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EShort\": [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EInt\": [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"ELong\": [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\n  \"EFloat\": [ShortAttribETypes.EDouble],\n  \"EDouble\": []\n};\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\nexport function toShortEType(a) {\n  return a.substring(ecoreprefix.length);\n}\nexport function toLongEType(a) {\n  return AttribETypes[a];\n  // return ecoreprefix + a as any;\n}\n\nexport function toShortEClass(a) {\n  return a.substring(ecoreclasprefix.length);\n}\nexport function toLongEClass(a) {\n  return DefaultEClasses[a];\n}\nexport class SelectorOutput {\n  constructor() {\n    this.jqselector = void 0;\n    this.attrselector = void 0;\n    this.attrRegex = void 0;\n    this.exception = void 0;\n    this.resultSetAttr = void 0;\n    this.resultSetElem = void 0;\n  }\n}\n// compare it with event.key\nexport let Keystrokes; // not even triggering event?\n(function (Keystrokes) {\n  Keystrokes[Keystrokes[\"clickLeft\"] = 0] = \"clickLeft\";\n  Keystrokes[Keystrokes[\"clickWheel\"] = 1] = \"clickWheel\";\n  Keystrokes[Keystrokes[\"clickRight\"] = 2] = \"clickRight\";\n  Keystrokes[Keystrokes[\"clickBackMouseButton\"] = 3] = \"clickBackMouseButton\";\n  Keystrokes[Keystrokes[\"clickForwardMouseButton\"] = 4] = \"clickForwardMouseButton\";\n  Keystrokes[\"escape\"] = \"Escape\";\n  Keystrokes[\"capsLock\"] = \"CapsLock\";\n  Keystrokes[\"shift\"] = \"Shift\";\n  Keystrokes[\"tab\"] = \"Tab\";\n  Keystrokes[\"alt\"] = \"Alt\";\n  Keystrokes[\"control\"] = \"Control\";\n  Keystrokes[\"end\"] = \"End\";\n  Keystrokes[\"home\"] = \"Home\";\n  Keystrokes[\"pageUp\"] = \"PageUp\";\n  Keystrokes[\"pageDown\"] = \"PageDown\";\n  Keystrokes[\"enter\"] = \"Enter\";\n  Keystrokes[\"numpadEnter\"] = \"NumpadEnter\";\n  Keystrokes[\"audioVolumeMute\"] = \"AudioVolumeMute\";\n  Keystrokes[\"audioVolumeUp\"] = \"AudioVolumeUp\";\n  Keystrokes[\"audioVolumeDown\"] = \"AudioVolumeDown\";\n  Keystrokes[\"mediaTrackPrevious\"] = \"MediaTrackPrevious\";\n  Keystrokes[\"delete\"] = \"Delete\";\n  Keystrokes[\"backspace\"] = \"Backspace\";\n  Keystrokes[\"space\"] = \" \";\n  Keystrokes[\"altGraph\"] = \"AltGraph\";\n  Keystrokes[\"arrowLeft\"] = \"ArrowLeft\";\n  Keystrokes[\"arrowRight\"] = \"ArrowRight\";\n  Keystrokes[\"arrowUp\"] = \"ArrowUp\";\n  Keystrokes[\"arrowDown\"] = \"ArrowDown\";\n  Keystrokes[\"insert\"] = \"Insert\";\n  Keystrokes[\"f1\"] = \"F1\";\n  Keystrokes[\"meta\"] = \"Meta\";\n  Keystrokes[\"unidentified\"] = \"Unidentified\";\n  Keystrokes[\"__NotReacting__\"] = \"fn, print, maybe others\";\n})(Keystrokes || (Keystrokes = {}));\nexport let DefaultEClasses;\n(function (DefaultEClasses) {\n  DefaultEClasses[\"EObject\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\";\n  DefaultEClasses[\"EAnnotation\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\";\n  DefaultEClasses[\"EClass\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\";\n  DefaultEClasses[\"EPackage\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\";\n  DefaultEClasses[\"ENamedElement\"] = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\";\n})(DefaultEClasses || (DefaultEClasses = {}));\nexport let AttribETypes; // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\n// EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\n/*\r\nECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\nEStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\nEDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\nEFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\nEDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\nEBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\nEByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\nEShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\nEIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\nELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\n// EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\n\n// export type Json = object;\n(function (AttribETypes) {\n  AttribETypes[\"EVoid\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid\";\n  AttribETypes[\"EChar\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar\";\n  AttribETypes[\"EString\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\";\n  AttribETypes[\"EDate\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate\";\n  AttribETypes[\"EFloat\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat\";\n  AttribETypes[\"EDouble\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble\";\n  AttribETypes[\"EBoolean\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean\";\n  AttribETypes[\"EByte\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte\";\n  AttribETypes[\"EShort\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort\";\n  AttribETypes[\"EInt\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\";\n  AttribETypes[\"ELong\"] = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong\";\n})(AttribETypes || (AttribETypes = {}));\nexport class ParseNumberOrBooleanOptions {\n  constructor() {\n    let defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let allowNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let nullValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let allowUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let undefinedValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    let allowedNan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let nanValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : NaN;\n    let allowBooleans = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n    let trueValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n    let falseValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    this.defaultValue = void 0;\n    this.allowNull = void 0;\n    this.nullValue = void 0;\n    this.allowUndefined = void 0;\n    this.undefinedValue = void 0;\n    this.allowedNan = void 0;\n    this.nanValue = void 0;\n    this.allowBooleans = void 0;\n    this.trueValue = void 0;\n    this.falseValue = void 0;\n    this.defaultValue = defaultValue;\n    this.allowNull = allowNull;\n    this.nullValue = nullValue;\n    this.allowUndefined = allowUndefined;\n    this.undefinedValue = undefinedValue;\n    this.allowedNan = allowedNan;\n    this.nanValue = nanValue;\n    this.allowBooleans = allowBooleans;\n    this.trueValue = trueValue;\n    this.falseValue = falseValue;\n  }\n}\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\n\nexport class FileReadTypeEnum {}\n\n// console.info('loaded ts U');\nFileReadTypeEnum.image = \"image/*\";\nFileReadTypeEnum.audio = \"audio/*\";\nFileReadTypeEnum.video = \"video/*\";\nFileReadTypeEnum.AndManyOthersButThereAreTooMuch = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\nFileReadTypeEnum.OrJustPutFileExtension = \"OrJustPutFileExtension\";","map":{"version":3,"names":["Log","JsType","LModelElement","LNamedElement","RuntimeAccessible","store","windoww","Swal","Storage","compressToUTF16","decompressFromUTF16","util","Convert","console","warn","Color","_dec","_class","constructor","r","g","b","fromHex","hex","undefined","fromHLS","_ref","h","l","s","getHex","mixWith","c","getHLS","duplicate","U","_dec2","_class3","_class4","decompressState","state","compressedState","JSON","stringify","getState","isOffline","read","refresh","window","location","reload","inspect","object","showHidden","depth","color","_object","o0","__raw","Array","isArray","map","o","error","objectInspect","val","arguments","length","ansiConvert","ansiconvert","replaceAll","toHtml","cropNum","num","digits","exponential","isNaN","toExponential","limit","intpart","Math","trunc","miss","cropStr","msg","linesStart","linesEnd","stringRowStart","stringRowEnd","arr","split","splice","ret","i","line","substring","extractByKey","dict","path","keys","topic","data","values","d","value","k","hasOwnProperty","push","extractKeys","traverse","obj","key","wrapper","json","dElement","parse","hexToPalette","_len","hexs","_key","type","a","Number","parseInt","exDev","fatherChain","me","fathers","id","toCheck","element","pop","father","isShallowEqualWithProxies","obj1","obj2","skipKeys","out","maxDepth","returnIfMaxDepth","tobj1","tobj2","reason","toString","o1Raw","o2Raw","className","clonedCounter","oldp","newp","deepEqual","x","y","tx","ty","Object","every","sleep","Promise","resolve","setTimeout","getRandomString","characters","randomString","index","randomNumber","floor","random","charAt","alert","title","text","toLowerCase","html","result","fire","backdrop","showCloseButton","showConfirmButton","popup","filteredPointedBy","label","models","pointedBy","source","fromPointer","getFatherFieldToDelete","field","initializeValue","typeclassifier","pointer","name","Date","toJSON","slice","orderChildrenByTimestamp","context","children","proxyObject","orderedChildren","Map","child","timestamp","set","entries","sort","followPath","base","patharr","base0","chain","lastObject","lastkey","failedRemainingPath","lastval","Error","multiReplaceAllKV","kv","vals","multiReplaceAll","searchText","replacement","str","debug","join","toFileName","trim","objectMergeInPlace","output","_len2","objarr","_key2","_out$key","log","clear","removeEmptyObjectKeys","objectMergeInPlace_conditional","condition","_len3","_key3","buildFunctionDocumentation","f","e","isFunction","parameters","returns","fname","isLambda","signature","starti","indexOf","endi","parcounter","parameterStr","substr","returnstarti","returnendi","bodystarti","max","regexp","match","exec","par","defaultVal","typedesc","parseFunctionWithContextAndScope","codeStr0","context0","scope0","codestrParamNames","protectShallowValues","doIdentifierValidation","codeStr","scopeParams","scope","scopekeys","_key4","validIdentfierRegexp","test","filter","innerFuncParams","_jevalfunc","evalmode","params","eval","Function","bind","evalInContextAndScopeNew","injectScopeToo","evalInContextAndScope","ex","_ret","__proto__","w","eDev","prefixDeclarations","postfixDeclarations","isStrict","_eval","__codeStr","call","_len4","_key5","execInContextAndScope","func","apply","execInScope_DO_NOT_USE","evalInContext","js","highOrderFunctionExampleTyped","funcName","cname","time","results","timeEnd","asClass","classe","elseReturn","asString","propKey","isString","loadScript","useEval","script","document","createElement","src","body","append","ancestorArray","domelem","stopNode","includeSelf","tmp","parentNode","container","containerTag","innerHTML","firstChild","removeChild","levenshtein","cost","min","getClosestPropertyName","names","lowest","Infinity","reduce","previous","current","distance","getClosestPropertyNames","distances","autoCorrectProxy","target","recursive","logger","Proxy","get","namestr","suggestions","getOwnPropertyNames","arrayRemoveAll","elem","arrayUnique","Set","fileReadContent","file","callback","textType","reader","FileReader","onload","readAsText","fileRead","onChange","extensions","readContent","myFileReader","show","htmlNode","clearAllTimeouts","highestTimeoutId","clearTimeout","getStackTrace","sliceCalls","stack","getCaller","stacksToSkip","isFirstTimeCalledByThisLine","caller","gotcalledby","lineKey","preventBackSlashHistoryNavigation","event","types","srcElement","$","disabled","prop","isContentEditable","is","attr","preventDefault","SetMerge","modifyFirst","_len5","iterables","_key6","iterable","item","add","ArrayMergeU","arr1","_len6","arr2","_key7","ArrayMerge0","ArrayMerge","_len7","_key8","unique","arrtarget","_len8","arrays","_key9","arri","ArrayAdd","prototype","throwIfContained","getType","param","_param$constructor","stringCompare","s1","s2","endsWith","suffix","suf","lastIndexOf","arrayMergeInPlace","_len9","otherArrs","_key10","getEndingNumber","ignoreNonNumbers","allowDecimal","numberEnd","parseFloat","increaseEndingNumber","allowLastNonNumberChars","increaseWhile","regexpstr","matches","RegExp","prefix","shallowEqual","objA","objB","keysA","keysB","keya","isNumber","getAllPrototypes","_constructor$prototyp","_constructor$__proto_","chainoutoutrecursive","currentRecursion","maxRecursion","cache","__allprototypes","classIsExtending","subconstructor","superconstructor","_extends","includes","isObject","v","returnIfNull","returnIfUndefined","retIfArray","objectFromArray","getKey","acc","objectFromArrayValues","toBoolString","bool","ifNotBoolean","fromBoolString","allowNull","allowUndefined","arrayDifference","starting","final","removed","Uarr","arraySubtract","added","objectDelta","old","neww","deep","newwobj","oldobj","diff","objdiff","changed","subold","subnew","removedprefix","unchanged","flattenObjectToRoot","pathseparator","pre","assign","ObjectToAssignementStrings","maxkeylength","maxsubpaths","maxvallength","toolongreplacer","quotestrings","valueseparator","filterrow","rowpaths","flatten","halfpath","start","end","ceil","halfval","halfsubpaths","bestpathsize","best","countsize","total","arrelem","filterbest","row","pathlength","fullstr","fullpath","fullvalue","p","download","filename","htmla","blob","Blob","endings","blobUrl","URL","createObjectURL","style","display","href","appendChild","click","revokeObjectURL","formatXml","xml","reg","wsexp","contexp","replace","pad","formatted","lines","indent","lastType","transitions","ln","single","Boolean","closing","opening","fromTo","padding","j","circularStringify","replacer","space","maxDepth_unsupported","getFirstNumber","allowDecimalDot","allowDecimalComma","valueifmismatch","commamode","floatregex","intregex","tmpindex","isEmptyObject","pairArrayElementsRepeatFunc","pairArrayElementsReducerFunc","accumulator","array","pairArrayElements","withRepetitions","decomment_all","decomment_line","decomment_block","trimLines","uppercaseFirstLetter","toUpperCase","wrapUserFunction","stringMiddleCut","maxLength","ellipsisChar","asArray","midpoint","toremove","lstrip","rstrip","invertHex","transformGrays","ee","abs","rs","gs","bs","hs","parentUntil","tagName","parentElement","paletteSplit","palette","number","entry","mergeNamedArray","classes","clipboardCopy","onSuccess","onFailure","navigator","clipboard","writeText","then","clipboardCopy_old","clipboardinput","position","top","select","execCommand","clearSelection","isError","toNamedArray","larr","darr","cropDeepObject","lines_start_crop","lines_end_crop","string_start_crop","string_end_crop","num_digit_crop","isHtmlNode","message","deepReplace","deepCopy","circularReferenceValue","avoidloop","WeakMap","deepReplace_rec","curdept","eagerLoopReturn","old_obj","has","deepFindInObject","subobject","compareFunc","POSITIVE_INFINITY","deepFindInObject_rec","curdepth","found","mailerror","recipients","msgbody_notencoded","canUseClipboard","clipboardSuccess","clipboardFailure","msgbody","encodeURIComponent","mailtitle","gitissue","mailto","mailtolimit","mailfallback","Element","HTMLDocument","SVGElement","maxID","idPrefix","getID","idgenerator","DDate","addDay","date","offset","inplace","setDate","getDate","addMonth","setMonth","getMonth","addYear","setFullYear","getFullYear","setinfos","fileTypes","onchange","readcontent","input","files","contentObj","fileLetti","content","_input$files","contentArr","reset","setAttribute","on","trigger","_dec3","_class5","arrayIntersection","inPlace","equals","a1","a2","FocusHistoryEntry","evt","ShortDefaultEClasses","ShortAttribETypes","ShortAttribSuperTypes","EString","EByte","EShort","EInt","ELong","EFloat","EDouble","ecoreprefix","ecoreclasprefix","toShortEType","toLongEType","AttribETypes","toShortEClass","toLongEClass","DefaultEClasses","SelectorOutput","jqselector","attrselector","attrRegex","exception","resultSetAttr","resultSetElem","Keystrokes","ParseNumberOrBooleanOptions","defaultValue","nullValue","undefinedValue","allowedNan","nanValue","NaN","allowBooleans","trueValue","falseValue","FileReadTypeEnum","image","audio","video","AndManyOthersButThereAreTooMuch","OrJustPutFileExtension"],"sources":["C:/d/Programming/web/jodel-mde/src/common/U.ts"],"sourcesContent":["// import * as detectzoooom from 'detect-zoom'; alternative: https://www.npmjs.com/package/zoom-level\r\n// import {Mixin} from \"ts-mixer\";\r\nimport {\r\n    AbstractConstructor,\r\n    Constructor,\r\n    Dictionary,\r\n    DocString,\r\n    GObject,\r\n    Pointer,\r\n    PrimitiveType,\r\n    Temporary,\r\n    LPointerTargetable,\r\n    DPointerTargetable,\r\n    Log,\r\n} from \"../joiner\";\r\nimport {\r\n    DClassifier,\r\n    DModelElement, DState,\r\n    Json,\r\n    JsType,\r\n    LClassifier,\r\n    LModelElement,\r\n    LNamedElement,\r\n    LogicContext,\r\n    MyError,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass, store,\r\n    windoww\r\n} from \"../joiner\";\r\nimport Swal from \"sweetalert2\";\r\nimport Storage from '../data/storage';\r\nimport {compressToUTF16, decompressFromUTF16} from \"async-lz-string\";\r\nimport {NumberControl, PaletteControl, PaletteType, PathControl, StringControl} from \"../view/viewElement/view\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport util from \"util\";\r\nimport Convert from \"ansi-to-html\";\r\n// var Convert = require('ansi-to-html');\r\n// import KeyDownEvent = JQuery.KeyDownEvent; // https://github.com/tombigel/detect-zoom broken 2013? but works\r\n\r\nconsole.warn('loading ts U log');\r\n\r\n@RuntimeAccessible('Color')\r\nexport class Color {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n\r\n    constructor(r: number, g: number, b: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n\r\n    static fromHex(hex:string): Color {\r\n        return undefined as any;\r\n    }\r\n    static fromHLS({h, l, s}:{h: number, l:number, s: number}): Color {\r\n        return undefined as any;\r\n    }\r\n    getHex(): string {\r\n        return undefined as any;\r\n    }\r\n    mixWith(c: Color): void {\r\n\r\n    }\r\n    getHLS(): {h: number, l:number, s: number} {\r\n        return undefined as any;\r\n    }\r\n    duplicate(): Color {\r\n        return undefined as any;\r\n    }\r\n}\r\n\r\n\r\n@RuntimeAccessible('U')\r\nexport class U {\r\n\r\n    static async decompressState(state: string): Promise<string> {\r\n        return await decompressFromUTF16(state);\r\n    }\r\n    static async compressedState(): Promise<string> {\r\n        return await compressToUTF16(JSON.stringify(store.getState()));\r\n    }\r\n    static isOffline(): boolean {\r\n        return Storage.read('offline') === 'true';\r\n    }\r\n    static refresh(): void {\r\n        window.location.reload();\r\n    }\r\n\r\n    public static inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string {\r\n        let o0 = object;\r\n        object = object?.__raw || object;\r\n        if (Array.isArray(object)) object = object.map(o => o?.__raw || o);\r\n        // todo: use lodash \"clonedeepwith\" to clean proxies\r\n        console.error(\"inspect\", {o0, object});\r\n        return util.inspect(object, showHidden, depth, color);\r\n    }\r\n\r\n    public static objectInspect(val: GObject, depth: number = 2, color: boolean = true, showHidden = true): string{\r\n        let ansiConvert = (window as any).ansiConvert;\r\n        if (!ansiConvert) (window as any).ansiconvert = ansiConvert = new Convert();\r\n        return U.replaceAll(ansiConvert.toHtml(U.inspect(val, showHidden, depth, color)),\r\n            \"style=\\\"color:#FFF\\\"\", \"style=\\\"color:#000\\\"\");\r\n    }\r\n\r\n    // exponential: undefined = only if it's over digits. false = never, true = always.\r\n    public static cropNum(num: number, digits?: number, exponential?: boolean): string{\r\n        if (!digits || isNaN(num)) return ''+num;\r\n        if (exponential) return num.toExponential(digits);\r\n        else if (exponential === undefined) {\r\n            let limit = 10**(digits - 1);\r\n            if (num >= limit || num <= -limit) return num.toExponential(digits);\r\n        }\r\n        let intpart = Math.trunc(num);\r\n        let s = ''+num;\r\n        if (intpart === num) return s;\r\n        let miss = (s.length - digits);\r\n        if (miss > 0) s+='.'+Math.trunc((num % 1)*(10**(miss-1)))\r\n        return s;\r\n    }\r\n    public static cropStr(msg: string, linesStart: number = 5, linesEnd: number = 5, stringRowStart: number = 25, stringRowEnd: number = 25): string{\r\n        let arr = msg.split('\\n');\r\n        if (linesEnd + linesStart + 1 < arr.length) {\r\n            //arr = arr.slice(0, 10) + arr.slice(10, 0);\r\n            arr.splice(linesStart, arr.length - linesStart - linesEnd, '...')\r\n        }\r\n        let ret: string = '';\r\n        let i = 0;\r\n        for (let line of arr){\r\n            if (stringRowEnd + stringRowStart + 1 < line.length) {\r\n                ret += line.substring(0, stringRowStart) + '...' + line.substring(line.length - stringRowEnd) + (i === arr.length-1 ?'':'\\n');\r\n            }\r\n            else ret += line + (i === arr.length-1 ?'':'\\n');\r\n            i++;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static extractByKey(dict: Dictionary, path: string): PrimitiveType[]|undefined {\r\n        const keys = path.split('.');\r\n        const topic = keys[0];\r\n        const data = dict[topic];\r\n        const values: PrimitiveType[] = [];\r\n        if(!Array.isArray(data)) return undefined;\r\n        for(const d of data) {\r\n            let value = d;\r\n            for (const k of keys) if (value.hasOwnProperty(k)) value = value[k];\r\n            values.push(value);\r\n        }\r\n        return values;\r\n\r\n    }\r\n\r\n    static extractKeys(dict: Dictionary): string[] {\r\n        const keys: string[] = [];\r\n        function traverse(obj: any, path: string) {\r\n            for (const key in obj) {\r\n                if (typeof obj[key] === 'object') traverse(obj[key], path ? `${path}.${key}` : key);\r\n                else keys.push(path ? `${path}.${key}` : key);\r\n            }\r\n        }\r\n        for (const key in dict) {\r\n            traverse(dict[key][0], key);\r\n        }\r\n        return keys;\r\n    }\r\n\r\n    // damiano: eseguire una funzione costa in performance, anche se è brutto fare questi cast\r\n    static wrapper<T>(obj: any): T {\r\n        return obj as unknown as T;\r\n    }\r\n    // damiano: mi sa che c'era un metodo l.__serialize or something\r\n    static json(dElement: GObject): Json {\r\n        return JSON.parse(JSON.stringify(dElement.__raw));\r\n    }\r\n\r\n    static hexToPalette(...hexs: string[]): PaletteControl{\r\n        return {type: \"color\", value: hexs.map( hex => {\r\n                if (hex[0] === '#') hex = hex.substring(1);\r\n                let r: number, g: number, b: number, a: number = 1;\r\n                if (hex.length === 4) {\r\n                    a = Number.parseInt('0x' + hex[3] + hex[3])/255;\r\n                    hex = hex.substring(0, 3);\r\n                }\r\n                if (hex.length === 7) {\r\n                    a = Number.parseInt('0x' + hex[5] + hex[6])/255;\r\n                    hex = hex.substring(0, 6);\r\n                }\r\n                Log.exDev(hex.length !== 3 && hex.length !== 6, \"invalid hex length\", {hex, a});\r\n                let i: number = 0;\r\n                if (hex.length === 3) {\r\n                    r =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i] + hex[i]);\r\n                }\r\n                else {\r\n                    r =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    g =  Number.parseInt('0x' + hex[i++] + hex[i++]);\r\n                    b =  Number.parseInt('0x' + hex[i++] + hex[i]);\r\n                }\r\n                return {r,g,b,a} as tinycolor.ColorFormats.RGBA;\r\n            })};\r\n    }\r\n    public static fatherChain(me: LModelElement): Pointer<DModelElement, 0, 'N', LModelElement> {\r\n        if(!me) return [];  // without this line go through delete error\r\n        const fathers: Pointer<DModelElement, 0, 'N', LModelElement>= [me.id];\r\n        const toCheck: LModelElement[] = [me];\r\n        while(toCheck.length > 0) {\r\n            const element = toCheck.pop();\r\n            if(element && element.father) {\r\n                fathers.push(element.father.id);\r\n                toCheck.push(element.father);\r\n            }\r\n        }\r\n        return fathers;\r\n    }\r\n\r\n    /// maxDepth = 2 is the minimum to check the content of objects inside usageDeclarations or node state. like node.errors.naming\r\n    static isShallowEqualWithProxies(obj1: GObject, obj2: GObject, skipKeys: Dictionary<string, any>={}, out?: {reason?: string},\r\n                                     depth: number = 0, maxDepth: number = 2, returnIfMaxDepth:boolean = false): boolean {\r\n        let tobj1 = obj1 === null ? 'null' : typeof obj1;\r\n        let tobj2 = obj2 === null ? 'null' : typeof obj2;\r\n        if (obj1 === obj2) {\r\n            // if (out) { out.reason = \"identical objects\"; }\r\n            return true; }\r\n        if (tobj1 !== tobj2) { if (out) { out.reason = \"type changed: \" + tobj1 + \" --> \" + tobj2; } return false; }\r\n\r\n        // at this point: same type, but different values\r\n        switch (tobj1) {\r\n            default: // primitive with different values\r\n                console.error(\"unexpected case in isshallowequal:\", {tobj1, obj1, obj2});\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case 'string': case 'boolean': // primitive with different values\r\n                if (out) {\r\n                    if (undefined === tobj1) out.reason = 'primitive value newly introduced';\r\n                    else if (undefined === tobj2) out.reason = 'primitive value got deleted';\r\n                    else out.reason = 'primitive value changedd';\r\n                }\r\n                return false;\r\n            case \"number\": // if both re nan it fails\r\n                // NB: infinities are not nan, and they compare with === like normal numbers. weird js...\r\n                if (isNaN(obj1 as any) && isNaN(obj2 as any)) return true;\r\n                if (out) out.reason = 'number changed';\r\n                return false;\r\n\r\n            case \"function\":\r\n                if (obj1.toString() === obj2.toString()) break;\r\n                if (out) out.reason = 'function body changed';\r\n                return false;\r\n\r\n            case \"object\":\r\n                let o1Raw = obj1.__raw;\r\n                let o2Raw = obj2.__raw;\r\n                if (o1Raw) {\r\n                    if (!o2Raw) {\r\n                        if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                        return false;\r\n                    }\r\n                    obj1 = o1Raw;\r\n                    obj2 = o2Raw;\r\n                }\r\n                // for proxies and DObjects\r\n                if (obj1.clonedCounter !== undefined && obj2.clonedCounter !== obj1.clonedCounter) {\r\n                    if (out) out.reason = 'clonedCounter difference ' + obj1.clonedCounter+ ' != ' + obj2.clonedCounter;\r\n                    return false;\r\n                }/*\r\n                if (obj1.className !== obj2.className) {\r\n                 removed: too unlikely to happen that a DObject is raplaced in the same path with another type of DObject with same clonedCounter\r\n                 nd it's checked anyway in for(let key in obj1)\r\n                    if (out) out.reason = o1Raw.className + 'replaced by another object type:' + o2Raw?.className;\r\n                    return false;\r\n                }*/\r\n                if (Array.isArray(obj1)) {\r\n                    if (obj1.length !== obj2.length) {\r\n                        if (out) out.reason = 'array length different: ' + obj1.length + \" !== \" + obj2.length;\r\n                        return false;\r\n                    }\r\n                    if (!Array.isArray(obj2)){\r\n                        if (out) out.reason = 'array became an object';\r\n                        return false;\r\n                    }\r\n                }\r\n                if (depth > maxDepth) {\r\n                    // to debug and see where is too deep, make returnIfMaxDepth = false, so the path is displayed in out.reason\r\n                    if (out) out.reason = 'max depth reached, assumed ' + returnIfMaxDepth;\r\n                    return returnIfMaxDepth;\r\n                }\r\n                for (let key in obj1) {\r\n                    if (key in skipKeys) continue;\r\n                    let oldp: any = obj2[key];\r\n                    let newp: any = obj1[key];\r\n                    if (oldp === newp) continue;\r\n                    if (!U.isShallowEqualWithProxies(newp, oldp, skipKeys, out, depth +1, maxDepth, returnIfMaxDepth)) {\r\n                        if (out) out.reason = '['+key+']'+out.reason;\r\n                        return false;\r\n                    }\r\n                }\r\n                // just check for keys that were in props and are not in nextProps\r\n                for (let key in obj2) {\r\n                    if ((key in skipKeys) || (key in obj1)) continue;\r\n                    if (out) out.reason = \"deleted subobject property: \" + key;\r\n                    return false;\r\n                }\r\n            // else retIfMaxDepthReached; split the above if\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n    public static deepEqual (x: GObject, y: GObject): boolean {\r\n        const tx = typeof x, ty = typeof y;\r\n        return x && y && tx === 'object' && tx === ty ? (\r\n            Object.keys(x).length === Object.keys(y).length && Object.keys(x).every(key => U.deepEqual(x[key], y[key]))\r\n        ) : (x === y);\r\n    }\r\n\r\n    public static sleep(s: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, s * 1000));\r\n    }\r\n\r\n    public static getRandomString(length: number): string {\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\r\n        let randomString = '';\r\n        let index = 0;\r\n        while(index < length) {\r\n            const randomNumber = Math.floor(Math.random() * characters.length);\r\n            randomString += characters.charAt(randomNumber);\r\n            index += 1;\r\n        }\r\n        return randomString;\r\n    }\r\n\r\n    public static alert(title: string, text: string) {\r\n        let color = 'text-';\r\n        switch(title.toLowerCase()) {\r\n            case 'error': color += 'danger'; break;\r\n            default: color += 'primary'\r\n        }\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>';\r\n        html += `<div><b><label class='fs-5 mb-2 text-uppercase ${color}'>${title}</label></b><hr/>`;\r\n        html += `<label class='fs-6 mt-3'>${text}</label><br/>`;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n\r\n    public static popup(element: any) {\r\n        let html = '<style>body.swal2-no-backdrop .swal2-container {background-color: rgb(0 0 0 / 60%) !important}</style>'+ element;\r\n        const result = Swal.fire({\r\n            html: html,\r\n            backdrop: false,\r\n            showCloseButton: true,\r\n            showConfirmButton: false\r\n            //confirmButtonText: 'GOT IT'\r\n        })\r\n    }\r\n    public static filteredPointedBy(data: LModelElement, label: string): LModelElement[] {\r\n        const models: LModelElement[] = [];\r\n        for(let dict of data.pointedBy) {\r\n            const pointedBy = dict.source.split('.');\r\n            if(pointedBy.length === 3 && pointedBy[2] === label) {\r\n                models.push(LModelElement.fromPointer(pointedBy[1]));\r\n            }\r\n        }\r\n        return models;\r\n    }\r\n\r\n    public static getFatherFieldToDelete(data: LModelElement): keyof DModelElement|null {\r\n        const father = data.father;\r\n        let field = '';\r\n        switch(father.className + '|' + data.className) {\r\n            // DPackage\r\n            case 'DModel|DPackage': field = 'packages'; break;\r\n            case 'DPackage|DPackage': field = 'subpackages'; break;\r\n            // DEnumerator and DClass\r\n            case 'DPackage|DEnumerator':\r\n            case 'DPackage|DClass': field = 'classifiers'; break;\r\n            // DAttribute\r\n            case 'DClass|DAttribute': field = 'attributes'; break;\r\n            // DReference\r\n            case 'DClass|DReference': field = 'references'; break;\r\n            // DOperation\r\n            case 'DClass|DOperation': field = 'operations'; break;\r\n            // DEnumLiteral\r\n            case 'DEnumerator|DEnumLiteral': field = 'literals'; break;\r\n            // DObject\r\n            case 'DModel|DObject': field = 'objects'; break;\r\n            // DParameter\r\n            case 'DOperation|DParameter': field = 'parameters'; break;\r\n            // DValue\r\n            case 'DObject|DValue': field = 'features'; break;\r\n            // Error\r\n            default: return null;\r\n        }\r\n        return field as keyof DModelElement;\r\n    }\r\n\r\n    public static initializeValue(typeclassifier: undefined|DClassifier|LClassifier|Pointer<DClassifier, 1, 1, LClassifier>): string {\r\n        // if(!classifier) return 'null';\r\n        const pointer: Pointer = typeof typeclassifier === 'string' ? typeclassifier : (typeclassifier as DClassifier)?.id;\r\n        const me: LNamedElement = LNamedElement.fromPointer(pointer);\r\n        switch(me?.name) {\r\n            default:\r\n            case 'EString': return '';\r\n            case 'EChar':  return 'a';\r\n            case 'EInt': return '0';\r\n            case 'ELong': return '0';\r\n            case 'EShort': return '0';\r\n            case 'Byte': return '0';\r\n            case 'EFloat': return '0';\r\n            case 'EDouble': return '0';\r\n            case 'EBoolean': return 'false';\r\n            case 'EDate': return new Date().toJSON().slice(0,10);\r\n        }\r\n        return 'null';\r\n    }\r\n\r\n    public static orderChildrenByTimestamp(context: LogicContext): LModelElement[] {\r\n        const children = context.proxyObject.children;\r\n        if(children && children.length > 0) {\r\n            let orderedChildren = new Map<number, LModelElement>();\r\n            for(let child of children) {\r\n                let timestamp = child.id.slice(-13);\r\n                orderedChildren.set(+timestamp, child);\r\n            }\r\n            orderedChildren = new Map([...orderedChildren.entries()].sort());\r\n            return [...orderedChildren.values()];\r\n        } else return [];\r\n    }\r\n\r\n\r\n    public static followPath(base: GObject, path: string): {chain: GObject[], lastObject: GObject, keys:string[], lastkey: string, lastval: any, failedRemainingPath: string[]} {\r\n        let patharr = path.split('.');\r\n        let base0 = base;\r\n        let ret: {chain: GObject[], lastObject: GObject, keys: string[], lastkey: string, lastval: any, failedRemainingPath: string[]}  = {} as any;\r\n        ret.keys = patharr;\r\n        ret.chain = [base];\r\n        let lastObject = base;\r\n\r\n        for (let i = 0; i < patharr.length; i++) {\r\n            let path = ret.lastkey = patharr[i];\r\n            lastObject = base;\r\n            base = base[path];\r\n            ret.chain.push(base);\r\n            if (typeof base !== \"object\" || i + 1 === patharr.length) {\r\n                ret.failedRemainingPath = patharr.slice(i);\r\n                ret.lastval = base;\r\n                ret.lastObject = lastObject;\r\n                return ret;\r\n            }\r\n        }\r\n        throw new Error(\"followPath should never reach here\");\r\n        return ret;\r\n    }\r\n\r\n    static multiReplaceAllKV(a: string, kv: string[][] = []): string {\r\n        const keys: string[] = [];\r\n        const vals: string[] = [];\r\n        let i: number;\r\n        for (i = 0; i < kv.length; i++) { keys.push(kv[i][0]); vals.push(kv[i][0]); }\r\n        return U.multiReplaceAll(a, keys, vals); }\r\n\r\n    // if replacement is empty, it will be filled with '';\r\n    // if replacement length < searchText, replacement will be filled with copies of his elements cycling from 0 to his length until his length matches searchText.length\r\n    static multiReplaceAll(a: string, searchText: string[] = [], replacement: string[] = []): string {\r\n        // Log.ex(searchText.length !== replacement.length, 'search and replacement must be have same length: ' + searchText.length + \"vs\" + replacement.length + \" \" +JSON.stringify(searchText) + \"   \" + JSON.stringify(replacement));\r\n        let i = -1;\r\n        while (replacement.length !== 0 && replacement.length < searchText.length) replacement.push(replacement[++i]);\r\n        i = -1;\r\n        while (++i < searchText.length) { a = U.replaceAll(a, searchText[i], replacement[i]); }\r\n        return a; }\r\n\r\n    static replaceAll(str: string, searchText: string, replacement: string | undefined, debug: boolean = false, warn: boolean = true): string {\r\n        if (!str) { return str; }\r\n        return str.split(searchText).join(replacement||''); }\r\n\r\n    static toFileName(a: string = 'nameless.txt'): string {\r\n        if (!a) { a = 'nameless.txt'; }\r\n        a = U.multiReplaceAll(a.trim(), ['\\\\', '//', ':', '*', '?', '<', '>', '\"', '|'],\r\n            ['[lslash]', '[rslash]', ';', '°', '_', '{', '}', '\\'', '!']);\r\n        return a;\r\n    }\r\n\r\n\r\n    // warn: this check if the scope containing the function is strict, to check if a specific external scope-file is strict\r\n    // you have to write inline the code:        var isStrict = true; eval(\"var isStrict = false\"); if (isStrict)...\r\n    // @ts-ignore\r\n    public static isStrict: boolean = ( function() { return !this; })();\r\n\r\n    // merge properties with first found first kept (first parameters have priority on override). only override null|undefined values, not (false|0|'') values\r\n    static objectMergeInPlace<A extends object, B extends object>(output: A, ...objarr: B[]): void {\r\n        const out: GObject = output;\r\n        if (objarr)\r\n            for (let o of objarr) {\r\n                if (o && typeof o === \"object\")\r\n                    for (let key in o) {\r\n                        // noinspection BadExpressionStatementJS,JSUnfilteredForInLoop\r\n                        out[key] ?? (out[key] = o[key]);\r\n                    }\r\n            }\r\n    }\r\n\r\n    public static log(obj: unknown, label: string = '###') {\r\n        console.clear();\r\n        console.log(label, obj);\r\n    }\r\n\r\n    static removeEmptyObjectKeys(obj: GObject): void{\r\n        for (let key of Object.keys(obj)) {\r\n            if (obj[key] === null || obj[key] === undefined) delete obj[key];\r\n        }\r\n    }\r\n\r\n    // usage example: objectMergeInPlace_conditional(baseobj, (out, key, current) => !out[key] && current[key];\r\n    // culprit of \"couldn't find intersection\" problem: condition type: (out:A&B, key: string | number, current:B, objarr?: B[], indexOfCurrent?: number) => boolean\r\n    static objectMergeInPlace_conditional<A extends GObject, B extends GObject>(output: A, condition: (...a:any)=>any, ...objarr: B[]): A & B {\r\n        const out: GObject<\"A & B\"> = output;\r\n        let i: number = 0;\r\n        for (let o of objarr) for (let key in o) { if (condition(out, key, o, objarr, i++)) out[key] = o[key]; }\r\n        return out as  A & B; }\r\n\r\n    static buildFunctionDocumentation(f: Function): {parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string} {\r\n        Log.e(!JsType.isFunction(f), 'getFunctionSignature() parameter must be a function', f);\r\n        // let parameters: {name: string, defaultVal: string, typedesc: string}[] = []; //{name: '', defaultVal: undefined, typedesc: ''};\r\n        let ret: {parameters: {name: string, defaultVal: string | undefined, typedesc: string | null}[], returns: string | undefined, f: Function, fname: string | undefined, isLambda: boolean, signature: string}\r\n            = {parameters: [], returns: undefined, f: f, fname: undefined, isLambda: null as Temporary, signature: ''};\r\n        let str: string = f.toString();\r\n        let starti: number = str.indexOf('(');\r\n        let endi: number;\r\n        let parcounter: number = 1;\r\n        for (endi = starti + 1; endi < str.length; endi++) {\r\n            if (str[endi] === ')' && --parcounter === 0) break;\r\n            if (str[endi] === '(') parcounter++; }\r\n\r\n        let parameterStr = str.substring(starti + 1, endi);\r\n        // console.log('getfuncsignature starti:', starti, 'endi', endi, 'fname:', str.substr(0, starti), 'parameterStr:', parameterStr);\r\n        ret.fname = str.substr(0, starti).trim();\r\n        ret.fname = ret.fname.substr(0, ret.fname.indexOf(' ')).trim();\r\n        // 2 casi: anonimo \"function (par1...){}\" e \"() => {}\", oppure nominato: \"function a1(){}\"\r\n        if (ret.fname === '' || ret.fname === 'function') ret.fname = undefined; // 'anonymous function';\r\n\r\n\r\n\r\n        let returnstarti: number = str.indexOf('/*', endi + 1);\r\n        let returnendi: number = -1;\r\n        let bodystarti: number = str.indexOf('{', endi + 1);\r\n        if (returnstarti === -1 || bodystarti !== -1 && bodystarti < returnstarti) {\r\n            // no return type or comment is past body\r\n            ret.returns = undefined;\r\n        } else {\r\n            returnendi = str.indexOf('*/', returnstarti + 2);\r\n            ret.returns = str.substring(returnstarti + 2, returnendi).trim();\r\n            bodystarti = str.indexOf('{', returnendi); }\r\n        if (ret.returns === '') ret.returns = undefined;\r\n\r\n        // is lambda if do not have curly body or contains => between return comment and body\r\n        // console.log('isLambda:', bodystarti, str.substring(Math.max(endi, returnendi)+1, bodystarti));\r\n        ret.isLambda =  bodystarti === -1 || str.substring((window as any).Math.max(endi, returnendi)+1, bodystarti).trim() === '=>';\r\n\r\n        let regexp = /([^=\\/\\,]+)(=?)([^,]*?)(\\/\\*[^,]*?\\*\\/)?,/g; // only problem: the last parameter won't match because it does not end with \",\", so i will append it everytime.\r\n        let match;\r\n        while ((match = regexp.exec(parameterStr + ','))) {\r\n            // match[0] is always the full match (not a capture group)\r\n            // match[2] can only be \"=\" or empty string\r\n            // nb: match[4] can be \"/*something*/\" or \",\" a single , without spaces.\r\n            let par: {name: string, defaultVal: string | undefined, typedesc: string | null} = {name: match[1], defaultVal: match[3], typedesc: match[4] && match[4].length > 1 ? match[4] : null};\r\n            par.name = par.name.trim();\r\n            par.defaultVal = par.defaultVal ? par.defaultVal.trim() : undefined;\r\n            par.typedesc = par.typedesc && par.typedesc && par.typedesc.length > 1 ? par.typedesc.substring(2, par.typedesc.length - 2).trim() || null : null;\r\n            ret.parameters.push(par); }\r\n        // set signature\r\n\r\n        ret.signature = '' + (ret.fname ? '/*' + ret.fname + '*/' : '') + '(';\r\n        let i: number;\r\n        for (i = 0; i < ret.parameters.length; i++) {\r\n            let par = ret.parameters[i];\r\n            ret.signature += (i === 0 ? '' : ', ') + par.name + (par.typedesc ? '/*' + par.typedesc + '*/' : '') + (par.defaultVal ? ' = ' + par.defaultVal : '');\r\n        }\r\n        ret.signature += ')' + (ret.returns ? '/*' + ret.returns + '*/' : '');\r\n        return ret; }\r\n\r\n\r\n\r\n    // NB: need to use result.apply(context) to have a usable \"this\"\r\n    // if you want to pass a parameter to the function, pass it through scope insteand !! AND UNDECLARE the parameter in function string signature !!\r\n    //if inner funcstr have parameters, need to declare them as codestrParamNames arr, and pass them in that order, after the scope which is fixed as first argument.\r\n    // rest values are declared with ellipsis in codestrParamNames\r\n    // !!! scope passed here, is only used for keys. values are not bound. scope is set as first parameter when you call the function.\r\n    // context is bound, but can be re-assigned by calling .bind(), .call() or .apply(), so neither context nor scope assigned in parsing phase are final.\r\n    // innerfunc params do not have to match the name on the string function, but only the correct amount. they can have any name i think, but i list them correctly to documentate.\r\n    public static parseFunctionWithContextAndScope<ParamNames extends string[], T extends Function = Function, TT extends GObject | undefined = GObject>(\r\n        codeStr0: string | Function, context0: GObject | undefined, scope0: TT, codestrParamNames?: ParamNames, protectShallowValues: boolean = false, doIdentifierValidation: boolean = false):\r\n        (TT extends undefined ? (...params: any)=>any : (scopee:TT, ...paramss: { [K in keyof ParamNames]: any;})=>any){\r\n        if (!codestrParamNames) codestrParamNames = [] as any;\r\n\r\n        let codeStr: string = typeof codeStr0 === \"function\" ? codeStr0.toString() : codeStr0;\r\n        let scopeParams: string = '';\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { //scope = {...scope0}; scope.__proto__ = scope0.__proto__; // for...in gets values in __proto__ too, {...o} instead gets only hasOwnProperty copied\r\n                scope = {};\r\n                for (let k in scope0) scope[k] = scope0[k];\r\n            } else scope = undefined;\r\n            if (context0) { // context = {...context0}; context.__proto__ = context0.__proto__;\r\n                context = {};\r\n                for (let k in context0) context[k] = context0[k];\r\n            } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n\r\n        if (scope) {\r\n            let scopekeys: string[] = Object.keys(scope);\r\n            if (doIdentifierValidation) scopekeys.map((key)=>{\r\n                key = key?.trim() || '';\r\n                if (!key || !U.validIdentfierRegexp.test(key)) return undefined;\r\n                return key;\r\n            }).filter(k=>!!k);\r\n            scopeParams = '{'+scopekeys.join(',')+'}';\r\n        }\r\n\r\n        let innerFuncParams = (codestrParamNames as string[]).join(',');\r\n        let _jevalfunc = undefined as any; // is set by eval\r\n        const evalmode = false;\r\n        console.log('parseFunctionWithContextAndScope', {codeStr, scope, context, params:{scopeParams, innerFuncParams}});\r\n        scopeParams = scopeParams && innerFuncParams ? scopeParams + ',' + innerFuncParams : scopeParams + innerFuncParams;\r\n        if (evalmode) {\r\n            codeStr = \"_jevalfunc = function (\"+scopeParams+\") { return (\"+codeStr+\")(\"+innerFuncParams+\") }\";\r\n            eval(codeStr);\r\n        } else {\r\n            _jevalfunc = new Function(scopeParams, \" return (\"+codeStr+\")(\"+innerFuncParams+\")\");\r\n        }\r\n\r\n        console.log('parseFunctionWithContextAndScope', {_jevalfunc, params:{scopeParams}});\r\n\r\n        if (context) return _jevalfunc.bind(context);\r\n        else return _jevalfunc;\r\n    }/*\r\n    public static evalInContextAndScope<T = any>(...a:any):any {return undefined}\r\n    public static evalInContextAndScopeNew<T = any>(...a:any):any {return undefined}*/\r\n    public static evalInContextAndScopeNew<T = any>(codeStr: string | ((...a:any)=>any), context0: GObject, injectScopeToo: boolean,\r\n                                                    protectShallowValues?: boolean, doIdentifierValidation?: boolean): T {\r\n        return U.evalInContextAndScope(codeStr, context0, injectScopeToo ? context0 : undefined, protectShallowValues, doIdentifierValidation);\r\n    }\r\n\r\n    // important! this is a simplified version. the correct one allows unicode chars and is 11kb long of regex expression\r\n    public static validIdentfierRegexp = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;\r\n\r\n    // warn: if return is not explicitly inserted (if that's the case set imlicitReturn = false) with a scope and the code have multiple statemepts it will fail.\r\n    // can modify scope AND context\r\n    // warn: can access global scope (window)\r\n    // if the context (this) is missing it will take the scope as context.\r\n    // warn: cannot set different scope and context, \"this\" della funzione sovrascrive anche il \"this\" interno allo scope come chiave dell'oggetto\r\n    // warn: !context && scope is impossible, so it gets autofixed by assigning context = scope; check Log messages inside function for details.\r\n    // warn: context && scope is impossible if context !== scope and cannot be hotfixed, that will cause a crash.\r\n    public static evalInContextAndScope<T = any>(codeStr: string | ((...a:any)=>any), scope0: GObject | undefined, context0?: GObject,\r\n                                                 protectShallowValues?: boolean, doIdentifierValidation?:boolean): T {\r\n        // console.log('evalInContextAndScope', {codeStr, scope, context});\r\n        // scope per accedere a variabili direttamente \"x + y\"\r\n        // context per accedervi tramite this, possono essere impostati come diversi.\r\n        if (!scope0 && !context0) { Log.ex(true, 'evalInContextAndScope: must specify at least one of scope || context', {codeStr, scope0, context0}); }\r\n\r\n        // scope.this = scope.this || context || scope; non funziona\r\n        // console.log('\"with(this){ return eval( \\'\" + codeStr + \"\\' ); }\"', \"with(this){ return eval( '\" + codeStr + \"' ); }\");\r\n        // eslint-disable-next-line no-restricted-syntax,no-with\r\n        // if (allowScope && allowContext) { return function(){ with(this){ return eval( '\" + codeStr + \"' ); }}.call(scopeAndContext); }\r\n        // if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr + \"' ); }\").call(scopeAndContext); }\r\n        let _ret: T = null as any;\r\n        let scope: GObject | undefined;\r\n        let context: GObject | undefined;\r\n        if (protectShallowValues) {\r\n            if (scope0) { scope = {...scope0, __proto__: scope0.__proto__}; scope.__proto__ = scope0.__proto__; } else scope = undefined;\r\n            if (context0) { context = {...context0, __proto__: context0.__proto__}; context.__proto__ = context0.__proto__; } else context = undefined;\r\n        } else { scope = scope0; context = context0; }\r\n\r\n        Log.w(!!(!context && scope),\r\n            \"evalInContextAndScope() Context is mandatory, as scope && !context case is not working properly \\n\" +\r\n            \"because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\\n\" +\r\n            \"Autofixed by assigning context = scope;\");\r\n        Log.eDev(!!((context && scope) && (context !== scope)),\r\n            \"evalInContextAndScope() Context and scope cannot be different if both present.\\n\" +\r\n            \"Because scope is simulated by declaring variables pointing to \\\"this\\\" objects instead of doing a full deep copy.\");\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n\r\n\r\n        /*\r\n        if (allowScope && allowContext) { return new Function( \"with(this){ return eval( '\" + codeStr.replace(/'/g, \"\\\\'\") + \"' ); }\").call(scopeAndContext); }\r\n        if (!allowScope && allowContext) { return new Function( \"return eval( '\" + codeStr + \"' );\").call(scopeAndContext); }\r\n        if (allowScope && !allowContext) { return eval(\"with(scopeAndContext){ \" + codeStr + \" }\"); }*/\r\n//      U.pe(!!scope && U.isStrict(), 'cannot change scope while in strict mode (\"use strict\")');\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    if (doIdentifierValidation) {\r\n                        key = key.trim();\r\n                        if (!key || !U.validIdentfierRegexp.test(key)) continue;\r\n                    }\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \"=this.\" + key + \";\";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n\r\n        if (scope && context) {\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n            // console.log(\"evalincontextandscope: \", {fullCodeStr: prefixDeclarations + \"return eval( this._eval._codeStr );\" + postfixDeclarations, codeStr});\r\n            _ret = new (Function as any)(prefixDeclarations + \"; return eval( this._eval.__codeStr );\" + postfixDeclarations).call(context);\r\n            delete (context as any)._eval;\r\n        } else\r\n        if (!scope && context) {\r\n            if (typeof codeStr === \"function\") {\r\n                _ret = (function(...a: any){ return (codeStr as Function).call(context, ...a)}) as any;\r\n                // _ret = (...a: any)=>codeStr.call(context, ...a);\r\n            } else {\r\n                // cannot just eval(codeStr).call(context) because the result might not be a function but only a piece of code or an expression\r\n                (context as any)._eval = {__codeStr: codeStr}; // necessary to reach this._eval.codeStr inside the eval()\r\n                _ret = new (Function as any)(\"return eval( this._eval.__codeStr );\").call(context);\r\n                delete (context as any)._eval;\r\n                // this below  is not good, as i need to quote the expanded result of codeStr,\r\n                // but since it might contain quotes as well i would need to escape them too.\r\n                // _ret = new (Function as any)(\"return eval( \" + codeStr + \" );\").call(context);\r\n            }\r\n        } else\r\n        if (scope && !context) {\r\n            // NB: potrei creare lo scope con \"let key = value;\" per ogni chiave, ma dovrei fare json stringify e non è una serializzazione perfetta e può dare eccezioni(circolarità)\r\n            // console.log({isStrict: U.isStrict, eval: \"eval(\" + prefixDeclarations + codeStr + postfixDeclarations + \")\"});\r\n            if (typeof codeStr === \"function\") { codeStr = codeStr.toString(); } // functions cannot change scope (with statement is deprecated)\r\n            _ret = eval(prefixDeclarations + codeStr + postfixDeclarations); }\r\n\r\n        return _ret; }\r\n\r\n    //T extends ( ((...args: any[]) => any) | (() => any)\r\n    public static execInContextAndScope<T extends (...args: any) => any>(func: T, parameters: Parameters<T>, scope?: GObject, context?: GObject): ReturnType<T>{\r\n        Log.l(false, 'execInCtxScope', {func, parameters, scope, context});\r\n        let ret: any;\r\n        const _eval = {context, scope, func, parameters: parameters || []};\r\n        let prefixDeclarations: string = \"\", postfixDeclarations: string = '';\r\n        if (scope) {\r\n            if (U.isStrict) {\r\n                for (let key in scope) {\r\n                    // anche se li assegno non cambiano i loro valori nel contesto fuori dall'eval, quindi lancio eccezioni con const.\r\n                    prefixDeclarations += \"const \" + key + \" = this.\" + key + \"; \";\r\n                    postfixDeclarations = \"\";\r\n                }\r\n            } else {\r\n                prefixDeclarations = \"with(\" + (context ? \"this._eval.\" : \"\") + \"scope){ \";\r\n                postfixDeclarations = \" }\";\r\n            }\r\n        }\r\n        if (!scope && !context) { Log.ex(true, 'execInContextAndScope: must specify at least one of scope || context', {func, scope, context}); }\r\n        if (!context) context = scope; // se creo un nuovo contesto pulisco anche lo scope dalle variabili locali di questa funzione.\r\n        if (scope && context) {\r\n            context._eval = _eval;\r\n            // will the scope work with \"with\" outside the function body?\r\n            ret = new Function( prefixDeclarations + \"return this._eval.func.apply(this._eval.context, this._eval.parameters);\" + postfixDeclarations).call(context);\r\n            delete context._eval;\r\n        }\r\n        if (!scope && context) { return _eval.func.apply(_eval.context, _eval.parameters); }\r\n        if (scope && !context) {\r\n            // todo: non credo funzioni, _eval non dovrebbe essere accessibile dopo la \"with\" forse devo fare scope._eval = _eval;\r\n            return eval(prefixDeclarations + \"return _eval.func(..._eval.parameters);\" + postfixDeclarations); }\r\n        return ret; }\r\n\r\n    // warn: aggiunge un layer di scope ma ha accesso anche agli scope precedenti (del chiamante della funzione e superiori)\r\n    // warn2: può modificare lo scope internamente all'eval ma ogni cambiamento è perso all'uscita dell'esecuzione (modifica copie)\r\n    // warn3: gli oggetti nested variabili dentro oggetti dello scope) sono modificabili con modifiche persistenti perchè vengono pasate per puntatore.\r\n    // warn4: richiede un return per leggere il valore\r\n    // insomma: sta funzione fa schifo ma non c'è di meglio e non puoi nè permettere nè vietare completamente le modifiche allo scope.\r\n    private static execInScope_DO_NOT_USE(codeStr: string, scope: GObject) {\r\n        return (new Function(...Object.keys(scope), codeStr))(...Object.values(scope));\r\n    }\r\n\r\n    // can modify context in-place, requires \"this\" before variable\r\n    private static evalInContext(js: string, context: GObject): unknown {\r\n        //# Return the results of the in-line anonymous function we .call with the passed context\r\n        return function() { return eval(js); }.call(context);\r\n    }/*\r\n    / *\r\n    // NO: ha 2 problemi: il contesto non è persistente e puoi accedere al contesto solo con \"this\" ma non direttamente usando i nomi delle variabili\r\n    public static evalInContext(contextObj: GObject, code: string): any{\r\n        return U.evalContextFunction.call(contextObj || {}, code);\r\n    }\r\n\r\n    // only create a context for \"this\", wich is bound by .call(), should never be called without .call()\r\n    private static evalContextFunction(code: string): any { eval(code); }\r\n*/\r\n    public static highOrderFunctionExampleTyped<T extends (...args: any[]) => ReturnType<T>>(func: T): (...funcArgs: Parameters<T>) => ReturnType<T> {\r\n        const funcName = (func as any).cname || func.name;\r\n\r\n        // Return a new function that tracks how long the original took\r\n        return (...args: Parameters<T>): ReturnType<T> => {\r\n            console.time(funcName);\r\n            const results = func(...args);\r\n            console.timeEnd(funcName);\r\n            return results; };\r\n    }\r\n\r\n    static asClass<T extends Function>(obj: any, classe: T, elseReturn: T | null = null): null | T { return obj instanceof classe ? obj as any as T: elseReturn; }\r\n    static asString<T>(propKey: unknown, elseReturn: T | null = null): string | null | T { return typeof propKey === 'string' ? propKey : elseReturn; }\r\n    static isString(propKey: unknown): boolean { return typeof propKey === 'string'; }\r\n\r\n    static loadScript(path: string, useEval: boolean = false): void {\r\n        const script = document.createElement('script');\r\n        script.src = path;\r\n        script.type = 'text/javascript';\r\n        Log.eDev(useEval, 'loadScript', 'useEval','useEval todo. potrebbe essere utile per avviare codice fuori dalle funzioni in futuro.');\r\n        document.body.append(script); }\r\n\r\n    static ancestorArray<T extends Element>(domelem: T, stopNode?: Node, includeSelf: boolean = true): Array<T> {\r\n        // [0]=element, [1]=father, [2]=grandfather... [n]=document\r\n        if (domelem === null || domelem === undefined) { return []; }\r\n        const arr = includeSelf ? [domelem] : [];\r\n        let tmp: T = domelem.parentNode as T;\r\n        while (tmp !== null && tmp !== stopNode) {\r\n            arr.push(tmp);\r\n            tmp = tmp.parentNode as T; }\r\n        return arr; }\r\n\r\n    static toHtml<T extends Element>(html: string, container?: Element, containerTag: string = 'div'): T {\r\n        if (!container) { container = document.createElement(containerTag); }\r\n        Log.e(!html || html === '', 'toHtml', 'require a non-empty string', html);\r\n        container.innerHTML = html;\r\n        const ret: T = container.firstChild as any;\r\n        if (ret) container.removeChild(ret);\r\n        return ret; }\r\n\r\n    public static levenshtein(a: string, b: string): number {\r\n        if (!a.length) return b.length;\r\n        if (!b.length) return a.length;\r\n        let cost = (a.charAt(a.length - 1) === b.charAt(b.length - 1)) ? 0 : 1;\r\n        return (window as any).Math.min(\r\n            U.levenshtein(a.substring(0, a.length - 1), b) + 1,\r\n            U.levenshtein(a, b.substring(0, b.length - 1)) + 1,\r\n            U.levenshtein(a.substring(0, a.length - 1), b.substring(0, b.length - 1)) + cost,\r\n        );\r\n    }\r\n\r\n    public static getClosestPropertyName(names: string[], name: string): string {\r\n        let lowest = Infinity;\r\n        return names.reduce(function(previous, current) {\r\n            let distance = U.levenshtein(current, name);\r\n            if (distance < lowest) {\r\n                lowest = distance;\r\n                return current;\r\n            }\r\n            return previous;\r\n        }, '');\r\n    }\r\n    public static getClosestPropertyNames(names: string[], name: string): string[] {\r\n        let distances: {distance: number, value: string}[] = names.map( value => { return {distance: U.levenshtein(value, name), value}; });\r\n        return distances.sort( (a, b) => a.distance - b.distance).map( e => e.value);\r\n    }\r\n\r\n    //todo for console\r\n    public static autoCorrectProxy<T extends GObject>(target: T, recursive: boolean, logger: Console): ProxyHandler<T> {\r\n        return new Proxy(target, {\r\n            get: function(target, name) {\r\n                let namestr = U.asString(name, null);\r\n                if (!namestr) return undefined;\r\n                if (name in target) return target[namestr];\r\n                const suggestions: string[] = U.getClosestPropertyNames(Object.getOwnPropertyNames(target), namestr);\r\n                logger.warn(`${namestr} is not defined, did you meant ${suggestions[0]}?\\t\\nother suggestions:`, suggestions);\r\n                return namestr && target[suggestions[0]];\r\n            },\r\n        });\r\n    }\r\n\r\n    static arrayRemoveAll<T>(arr: Array<T>, elem: T, debug: boolean = false): void {\r\n        let index;\r\n        if (!arr) return;\r\n        while (true) {\r\n            index = arr.indexOf(elem);\r\n            Log.l(debug, 'ArrayRemoveAll: index: ', index, '; arr:', arr, '; elem:', elem);\r\n            if (index === -1) { return; }\r\n            arr.splice(index, 1);\r\n            Log.l(debug, 'ArrayRemoveAll RemovedOne:', arr);\r\n        }\r\n    }\r\n\r\n    static arrayUnique<T>(arr: T[]): Array<T> { return [ ...new Set<T>(arr)]; }\r\n\r\n    static fileReadContent(file: File, callback: (content :string) => void): void {\r\n        const textType = /text.*/;\r\n        try { if (!file.type || file.type.match(textType)) {\r\n            let reader = new FileReader();\r\n            reader.onload = function(e) { callback( '' + reader.result ); };\r\n            reader.readAsText(file);\r\n            return;\r\n        } } catch(e) { Log.e(true, \"Exception while trying to read file as text. Error: |\", e, \"|\", file); }\r\n        Log.e(true, \"Wrong file type found: |\", file ? file.type : null, \"|\", file); }\r\n\r\n    static fileRead(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: string[] | FileReadTypeEnum[], readContent: boolean): void {\r\n        // $(document).on('change', (e) => console.log(e));\r\n        console.log(\"importEcore: pre file reader\");\r\n        myFileReader.show(onChange, extensions, readContent);\r\n    }\r\n\r\n    public static clear(htmlNode: Element): void {\r\n        if (htmlNode) while (htmlNode.firstChild) { htmlNode.removeChild(htmlNode.firstChild); }\r\n    }\r\n\r\n    static clearAllTimeouts(): void {\r\n        const highestTimeoutId: number = setTimeout(() => {}, 1) as any;\r\n        for (let i = 0 ; i < highestTimeoutId ; i++) { clearTimeout(i); }\r\n    }\r\n\r\n    static getStackTrace(sliceCalls: number = 2): string[] {\r\n        const ret: string | undefined = Error().stack;\r\n        // try { var a = {}; a.debug(); } catch(ex) { ret = ex.stack; }\r\n        // if (Array.isArray(ret)) return ret;\r\n        if (!ret) return ['UnknownStackTrace'];\r\n        const arr: string[] = ret.split('\\n');\r\n        // first 2 entries are \"Erorr\" and \"getStackTrace()\"\r\n        return sliceCalls > 0 ? arr.slice( sliceCalls ) : arr; }\r\n\r\n    // 0 for caller, 1 for caller of caller, -1 for current function, up to -4 to see internal layers (useless)\r\n    public static getCaller(stacksToSkip: number = 0): string {\r\n        const stack: string[] = this.getStackTrace(4);\r\n        // erase getStackTrace() and isFirstTimeCalled() + Error() first stack + n° of layer the caller wants.\r\n        return stack[stacksToSkip]; }\r\n\r\n    private static gotcalledby: Dictionary<string, boolean> = {};\r\n\r\n    // todo: use in Log.once\r\n    // returns true only the first time this line is reached, false in loops >1 loop, false in recursion >1 recursion, false even days after the first execution unless the page is reloaded\r\n    public static isFirstTimeCalledByThisLine(stacksToSkip: number = 0): boolean {\r\n        const caller: string = this.getCaller(stacksToSkip);\r\n        if (U.gotcalledby[caller]) return false;\r\n        return U.gotcalledby[caller] = true; }\r\n\r\n    public static lineKey(): string { return this.getCaller(0); }\r\n\r\n    // Prevent the backspace key from navigating back.\r\n    static preventBackSlashHistoryNavigation(event: JQuery.KeyDownEvent): boolean {\r\n        if (!event || !event.key || event.key.toLowerCase() !== 'backspace') { return true; }\r\n        const types: string[] = ['text', 'password', 'file', 'search', 'email', 'number', 'date',\r\n            'color', 'datetime', 'datetime-local', 'month', 'range', 'search', 'tel', 'time', 'url', 'week'];\r\n        const srcElement: JQuery<any> = $((event as any)['srcElement'] || event.target);\r\n        const disabled = srcElement.prop('readonly') || srcElement.prop('disabled');\r\n        if (!disabled) {\r\n            if (srcElement[0].isContentEditable || srcElement.is('textarea')) { return true; }\r\n            if (srcElement.is('input')) {\r\n                const type = srcElement.attr('type');\r\n                if (!type || types.indexOf(type.toLowerCase()) > -1) { return true; }\r\n            }\r\n        }\r\n        event.preventDefault();\r\n        return false; }\r\n\r\n    static SetMerge<T>(modifyFirst: boolean = true, ...iterables: Iterable<T>[]): Set<T> {\r\n        const set: Set<T> = modifyFirst ? iterables[0] as Set<T>: new Set<T>();\r\n        Log.e(!(set instanceof Set), 'U.SetMerge() used with modifyFirst = true requires the first argument to be a set');\r\n        for (let iterable of iterables) { for (let item of iterable) { set.add(item); } }\r\n        return set; }\r\n\r\n    // merge with unique elements\r\n    static ArrayMergeU(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(true, arr1, arr2); }\r\n    // merge without unique check\r\n    static ArrayMerge(arr1: any[], ...arr2: any[]): void { U.ArrayMerge0(false, arr1, arr2); }\r\n    // implementation\r\n    static ArrayMerge0(unique: boolean, arrtarget: any[], ...arrays: any[]): void {\r\n        if (!arrtarget || !arrays) return;\r\n\r\n        if (unique) { for (let arri of arrays) for (let e of arri) U.ArrayAdd(arrtarget, e); }\r\n        else { for (let arri of arrays) Array.prototype.push.apply(arrtarget, arri); }\r\n    }\r\n\r\n    static ArrayAdd<T>(arr: Array<T>, elem: T, unique: boolean = true, throwIfContained: boolean = false): boolean {\r\n        Log.ex(!arr || !Array.isArray(arr), 'ArrayAdd arr null or not array:', arr);\r\n        if (!unique) { arr.push(elem); return true; }\r\n        if (arr.indexOf(elem) === -1) { arr.push(elem); return true; }\r\n        Log.ex(throwIfContained, 'ArrayAdd element already contained:', arr, elem);\r\n        return false; }\r\n\r\n\r\n    private static maxID: number = 0;\r\n    public static idPrefix: string = '';\r\n    // static getID(): string { return U.idPrefix + U.maxID++; }\r\n    static getID: Generator<number> = function* idgenerator(): Generator<number> { let i: number = 0; while(true) yield i++; }();\r\n\r\n\r\n    static getType(param: any): string {\r\n        switch (typeof param) {\r\n            default: return typeof param;\r\n            case 'object':\r\n                return (param?.constructor as typeof RuntimeAccessibleClass)?.cname || param?.className || \"{_rawobject_}\";\r\n            case 'function': // and others\r\n                return \"geType for function todo: distinguish betweeen arrow and classic\";\r\n        }\r\n    }\r\n\r\n    static stringCompare(s1: string, s2: string): -1 | 0 | 1 { return (s1 < s2) ? -1 : (s1 > s2) ? 1 : 0; }\r\n\r\n    static endsWith(str: string, suffix: string | string[]): boolean {\r\n        if (Array.isArray(suffix)) {\r\n            for (let suf of suffix) {\r\n                if (U.endsWith(str, suf)) return true;\r\n            }\r\n            return false;\r\n        }\r\n        return str.length >= suffix.length && str.lastIndexOf(suffix) === str.length - suffix.length;\r\n    }\r\n\r\n\r\n    static arrayMergeInPlace<T>(arr1: T[], ...otherArrs: T[][]): T[] {\r\n        for (const arr of otherArrs) arr1.push.apply(arr1, arr || []);\r\n        return arr1; }\r\n\r\n    static getEndingNumber(s: string, ignoreNonNumbers: boolean = false, allowDecimal: boolean = false): number {\r\n        let i = s.length;\r\n        let numberEnd = -1;\r\n        while (--i > 0) {\r\n            if (!isNaN(+s[i])) { if (numberEnd === -1) { numberEnd = i; } continue; }\r\n            if (s[i] === '.' && !allowDecimal) { break; }\r\n            if (s[i] === '.') { allowDecimal = false; continue; }\r\n            if (!ignoreNonNumbers) { break; }\r\n            if (numberEnd !== -1) { ignoreNonNumbers = false; }\r\n        }\r\n        s = numberEnd === -1 ? '1' : s.substring(i, numberEnd);\r\n        return +parseFloat(s); }\r\n\r\n    static increaseEndingNumber(s: string, allowLastNonNumberChars: boolean = false, allowDecimal: boolean = false, increaseWhile?: ((x: string) => boolean)): string {\r\n        let regexpstr = '([0-9]+' + (allowDecimal ? '|[0-9]+\\\\.[0-9]+' : '') + ')' + (allowLastNonNumberChars ? '[^0-9]*' : '') + '$';\r\n        const matches: RegExpExecArray | null = new RegExp(regexpstr, 'g').exec(s); // Global (return multi-match) Single line (. matches \\n).\r\n        // S flag removed for browser support (firefox), should work anyway.\r\n        let prefix: string;\r\n        let num: number;\r\n        if (!matches) {\r\n            prefix = s;\r\n            num = 2;\r\n        } else {\r\n            Log.ex(matches.length > 2, 'parsing error: /' + regexpstr + '/gs.match(' + s + ')');\r\n            let i = s.length - matches[0].length;\r\n            prefix = s.substring(0, i);\r\n            num = 1 + (+matches[1]);\r\n        }\r\n        if (increaseWhile) while (increaseWhile(prefix + num)) { num++; }\r\n        return prefix + num; }\r\n\r\n\r\n    public static shallowEqual(objA: GObject, objB: GObject): boolean {\r\n        if (objA === objB) { return true; }\r\n\r\n        if (!objA || !objB || typeof objA !== 'object' || typeof objB !== 'object') { return false; }\r\n\r\n        var keysA = Object.keys(objA);\r\n        var keysB = Object.keys(objB);\r\n        if (keysA.length !== keysB.length) return false;\r\n\r\n        // if (keysA.length !== keysB.length) { return false; }\r\n        // Test for A's keys different from B.\r\n        // var bHasOwnProperty = hasOwnProperty.bind(objB);\r\n        for (let keya in objA) if (!Object.is(objA[keya], objB[keya])) return false;\r\n\r\n        // for (var i = 0; i < keysA.length; i++) if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) { return false; }\r\n        return true;\r\n    }\r\n\r\n    // returns true only if parameter is already a number by type. UU.isNumber('3') will return false\r\n    static isNumber(o: any): o is number { return typeof o === \"number\" && !isNaN(o); }\r\n\r\n    public static getAllPrototypes(constructor: Constructor, chainoutoutrecursive: GObject[] = [], currentRecursion = 0, maxRecursion = 20, cache: boolean = true): GObject[] {\r\n        // console.log('getAllPrototypes:', {name: constructor.name, currentRecursion, constructor, chainoutoutrecursive});\r\n        if (cache && (constructor as any).__allprototypes) return (constructor as any).__allprototypes;\r\n        let prototype = (constructor.prototype?.name) && constructor.prototype;\r\n        let __proto__ = (constructor.__proto__?.name) && constructor.__proto__;\r\n        if (!prototype && !__proto__ || currentRecursion >= maxRecursion) return chainoutoutrecursive;\r\n        if (prototype) chainoutoutrecursive.push(prototype);\r\n        if (__proto__) chainoutoutrecursive.push(__proto__);\r\n        if (prototype) U.getAllPrototypes(prototype, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (__proto__) U.getAllPrototypes(__proto__, chainoutoutrecursive, currentRecursion + 1, maxRecursion);\r\n        if (cache) (constructor as any).__allprototypes = chainoutoutrecursive;\r\n        return chainoutoutrecursive;\r\n    }\r\n\r\n    public static classIsExtending(subconstructor: Constructor | AbstractConstructor, superconstructor: Constructor | AbstractConstructor): boolean {\r\n        return (superconstructor as typeof DPointerTargetable)?._extends?.includes(subconstructor as any) || false;\r\n        // return U.getAllPrototypes(subconstructor).includes(superconstructor);\r\n    }\r\n\r\n    static isObject(v: GObject|any, returnIfNull: boolean = true, returnIfUndefined: boolean = false, retIfArray: boolean = false): boolean {\r\n        if (v === null) { return returnIfNull; }\r\n        if (v === undefined) { return returnIfUndefined; }\r\n        if (Array.isArray(v)) { return retIfArray; }\r\n        // nb: mind that typeof [] === 'object'\r\n        return typeof v === 'object'; }\r\n\r\n    static objectFromArray<V extends any>(arr: V[], getKey: (entry:V) => string): Dictionary<string, V>{\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => { acc[getKey(val)] = val; return acc; }, {});\r\n    }\r\n\r\n    static objectFromArrayValues<T extends any>(arr: (string | number)[], val: T = true as T): Dictionary<string | number, T> {\r\n        // @ts-ignore\r\n        return arr.reduce((acc, val) => { acc[val] = val; return acc; }, {});\r\n        /*let ret: Dictionary = {};\r\n        for (let val of arr) { ret[val] = true; }\r\n        return ret;*/\r\n    }\r\n\r\n    static toBoolString(bool: boolean, ifNotBoolean: boolean = false): string { return bool === true ? 'true' : (bool === false ? 'false' : '' + ifNotBoolean); }\r\n    static fromBoolString<T extends any>(str: string | boolean): boolean;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T): boolean | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal?: T, allowNull?: boolean): boolean | null | T;\r\n    static fromBoolString<T extends any>(str: string | boolean, defaultVal: T = false as any, allowNull: boolean = false, allowUndefined: boolean = false): boolean | null | undefined | T {\r\n        str = ('' + str).toLowerCase();\r\n        if (allowNull && (str === 'null')) return null;\r\n        if (allowUndefined && (str === 'undefined')) return undefined;\r\n\r\n        if (str === \"true\" || str === 't' || str === '1') return true;\r\n        // if (defaultVal === true) return str === \"false\" || str === 'f' || str === '0'; // false solo se è esplicitamente false, true se ambiguo.\r\n        if (str === \"false\" || str === 'f' || str === '0') return false;\r\n        return defaultVal;\r\n    }\r\n\r\n    static arrayDifference<T>(starting: T[], final: T[]): {added: T[], removed: T[], starting: T[], final: T[]} {\r\n        let ret: {added: T[], removed: T[], starting: T[], final: T[]} = {} as any;\r\n        ret.starting = starting;\r\n        ret.final = final;\r\n        if (!starting) starting = [];\r\n        if (!final) final = [];\r\n        ret.removed = Uarr.arraySubtract(starting, final, false); // start & !end\r\n        ret.added = Uarr.arraySubtract(final, starting, false); // end & !start\r\n        return ret;\r\n    }\r\n\r\n    // returns <\"what changed from old to neww\"> and in nested objects recursively\r\n    // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\r\n    // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\r\n    public static objectDelta<T extends object>(old: T, neww: T, deep: boolean = true): Partial<T>{\r\n        let newwobj: GObject = neww;\r\n        let oldobj: GObject = old;\r\n        if (old === neww) return {};\r\n        let diff = U.objdiff(old, neww); // todo: optimize this, remove the 3 loops below and add those directly in U.objdiff(old, neww, ret); writing inside the obj in third parameter\r\n\r\n        let ret: GObject = {}; // {__isAdelta:true};\r\n        for (let key in diff.added) { ret[key] = newwobj[key]; }\r\n        for (let key in diff.changed) {\r\n            let subold = oldobj[key];\r\n            let subnew = newwobj[key];\r\n            if (typeof subold === typeof subnew && typeof subold === \"object\") { ret[key] = deep ? U.objectDelta(subold, subnew, true) : subnew; }\r\n            else ret[key] = subnew;\r\n        }\r\n        // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\r\n        let removedprefix = \"\"; // \"_-\";\r\n        for (let key in diff.removed) { ret[removedprefix + key] = undefined; } //newwobj[key]; }\r\n        // console.log(\"objdiff\", {old, neww, diff, ret});\r\n        return ret as Partial<T>;\r\n    }\r\n\r\n    // difference react-style. lazy check by === equality field by field. parameters are readonly\r\n    public static objdiff<T extends GObject>(old:T, neww: T): {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>} {\r\n        // let ret: GObject = {removed:{}, added:{}, changed:{}};\r\n        let ret: {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>}  = {removed:{}, added:{}, changed:{}, unchanged: {}};\r\n        if (!neww && !old) { return ret; }\r\n        if (!neww) { ret.removed = old; return ret; }\r\n        if (!old) { ret.added = neww; return ret; }\r\n        // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\r\n\r\n        let key: any;\r\n        for (key in old) {\r\n            // if (neww[key] === undefined){\r\n            // if neww have a key with undefined value, it counts (and should) as having that property key defined\r\n            if (!(key in neww)){ (ret.removed as GObject)[key] = old[key]; }\r\n            else if (neww[key] === old[key]) { (ret.unchanged as GObject)[key] = old[key] }\r\n            else (ret.changed as GObject)[key] = old[key];\r\n        }\r\n        for (let key in neww) {\r\n            if (!(key in old)){ (ret.added as GObject)[key] = neww[key]; }\r\n        }\r\n        return ret;\r\n    }\r\n    /*  {a: { b: { c1: 1, c2:2, c3:3 } }, d: 1 }     ---->  {\"a.b.c1\":1, \"a.b.c2\":2, \"a.b.c3\":3. \"d\":1}*/\r\n    public static flattenObjectToRoot(obj: GObject, prefix: string = '', pathseparator: string = '.'): GObject{\r\n        return Object.keys(obj).reduce((acc: GObject, k: string) => {\r\n            const pre = prefix.length ? prefix + pathseparator : '';\r\n            if (typeof obj[k] === 'object') Object.assign(acc, U.flattenObjectToRoot(obj[k], pre + k, pathseparator));\r\n            else acc[pre + k] = obj[k];\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    // from {a:{aa:true, ab:\"ab\"}, b:4} to [\"a.aa = true\", \"a.ab = \\\"ab\\\"\", \"a.b = 4\"]\r\n    // maxkeylength is max length of any individual key, after it it will become: superlongpath --> supe...path\r\n    // maxsubpaths is how many subpaths are displayed at most. after it it will be: super.rea.lly.long.pa.th --> super.rea.pa.th\r\n    public static ObjectToAssignementStrings<R extends {str: string, fullstr: string, path:string[], fullpath:string[], val: string, fullvalue: string, pathlength?: number}>\r\n    (obj: GObject, maxkeylength: number = 10, maxsubpaths: number = 6, maxvallength: number = 20, toolongreplacer: string = \"…\", out?:{best: R}&R[], quotestrings: boolean = true): {best: string}&string[] {\r\n        const pathseparator = \".\";\r\n        const valueseparator = \" = \";\r\n        const filterrow = (rowpaths: string[]) => { return (!rowpaths.includes(\"clonedCounter\") && !rowpaths.includes(\"pointedBy\")); };\r\n        let flatten = U.flattenObjectToRoot(obj, '', pathseparator);\r\n        let i = -1;\r\n        let tmp;\r\n        let ret: {best: string} & string[] = [] as GObject as {best: string} & string[];\r\n        tmp = (maxkeylength - toolongreplacer.length)/2;\r\n        let halfpath = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxvallength - toolongreplacer.length)/2;\r\n        let halfval = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n        tmp = (maxsubpaths - toolongreplacer.length)/2;\r\n        let halfsubpaths = { start: (window as any).Math.floor(tmp), end: (window as any).Math.ceil(tmp) };\r\n\r\n\r\n        let bestpathsize = 0;\r\n        let best: R | null = null;\r\n        let countsize = (total: number, arrelem: string): number => total + arrelem.length;\r\n        const filterbest = (row: R) => {\r\n            row.pathlength = row.fullstr.length; // row.fullpath.reduce<number>(countsize, 0);\r\n            if (!best || bestpathsize < row.pathlength && filterrow(row.fullpath)) {\r\n                best = row; bestpathsize = row.pathlength;\r\n                if (out) out.best = best;\r\n                ret.best = best.str;\r\n            }\r\n        }\r\n        console.log(\"u get assignements\", {flatten, obj});\r\n\r\n        for (let key in flatten) {\r\n            let row: R = {fullpath: key.split(pathseparator), fullstr: key} as R;\r\n            // if (!filterrow(row.fullpath)) continue;\r\n            // stringify(undefined) = undefined, so i add + \"\"\r\n            try {\r\n                if (!quotestrings && typeof flatten[key] === \"string\") row.fullvalue = flatten[key];\r\n                else row.fullvalue = JSON.stringify(flatten[key]) + \"\";\r\n            } catch(e) { row.fullvalue = \"⁜not serializable⁜\"; }\r\n            // console.log(\"U get assignements loop\", {row, key, flatten, obj});\r\n            row.val = row.fullvalue.length <= maxvallength ? row.fullvalue : row.fullvalue.substring(0, halfval.start) + toolongreplacer + row.fullvalue.substring(halfval.start);\r\n            if (row.fullpath.length > maxsubpaths) {\r\n                row.path = [...row.fullpath];\r\n                row.path.splice( halfsubpaths.start, row.fullpath.length - halfsubpaths.start - halfsubpaths.end, toolongreplacer);\r\n            } else row.path = row.fullpath;\r\n\r\n            // row.path = row.fullpath.length <= maxsubpaths ? row.fullpath : [...row.fullpath.slice(0, halfsubpaths.start), ...row.fullpath.toomanyarraycopies];\r\n            row.path = row.path.map((p: string) => (p.length <= maxkeylength ? p : p.substring(0, halfpath.start) + toolongreplacer + p.substring(p.length - halfpath.end)));\r\n            if (out) { out.push(row); }\r\n            row.str = row.path.join(pathseparator) + valueseparator + row.val;\r\n            ret.push( row.str );\r\n            filterbest(row);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    static download(filename: string = 'nameless.txt', text: string = '', debug: boolean = true): void {\r\n        if (!text) { return; }\r\n        filename = U.toFileName(filename);\r\n        const htmla: HTMLAnchorElement = document.createElement('a');\r\n        const blob: Blob = new Blob([text], {type: 'text/plain', endings: 'native'});\r\n        const blobUrl: string = URL.createObjectURL(blob);\r\n        Log.l(debug, text + '|\\r\\n| <-- rn, |\\n| <--n.');\r\n        htmla.style.display = 'none';\r\n        htmla.href = blobUrl;\r\n        htmla.download = filename;\r\n        document.body.appendChild(htmla);\r\n        htmla.click();\r\n        window.URL.revokeObjectURL(blobUrl);\r\n        document.body.removeChild(htmla); }\r\n\r\n    static formatXml(xml: string): string {\r\n        const reg = /(>)\\s*(<)(\\/*)/g;\r\n        const wsexp = / *(.*) +\\n/g;\r\n        const contexp = /(<.+>)(.+\\n)/g;\r\n        xml = xml.replace(reg, '$1\\n$2$3').replace(wsexp, '$1\\n').replace(contexp, '$1\\n$2');\r\n        const pad: string = '' || '\\t';\r\n        let formatted = '';\r\n        const lines = xml.split('\\n');\r\n        let indent = 0;\r\n        let lastType = 'other';\r\n        // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions\r\n        const transitions: GObject = {\r\n            'single->single': 0,\r\n            'single->closing': -1,\r\n            'single->opening': 0,\r\n            'single->other': 0,\r\n            'closing->single': 0,\r\n            'closing->closing': -1,\r\n            'closing->opening': 0,\r\n            'closing->other': 0,\r\n            'opening->single': 1,\r\n            'opening->closing': 0,\r\n            'opening->opening': 1,\r\n            'opening->other': 1,\r\n            'other->single': 0,\r\n            'other->closing': -1,\r\n            'other->opening': 0,\r\n            'other->other': 0\r\n        };\r\n        let i = 0;\r\n        for (i = 0; i < lines.length; i++) {\r\n            const ln = lines[i];\r\n\r\n            // Luca Viggiani 2017-07-03: handle optional <?xml ... ?> declaration\r\n            if (ln.match(/\\s*<\\?xml/)) {\r\n                formatted += ln + '\\n';\r\n                continue;\r\n            }\r\n            // ---\r\n\r\n            const single = Boolean(ln.match(/<.+\\/>/)); // is this line a single tag? ex. <br />\r\n            const closing = Boolean(ln.match(/<\\/.+>/)); // is this a closing tag? ex. </a>\r\n            const opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)\r\n            const type = single ? 'single' : closing ? 'closing' : opening ? 'opening' : 'other';\r\n            const fromTo = lastType + '->' + type;\r\n            lastType = type;\r\n            let padding = '';\r\n\r\n            indent += transitions[fromTo];\r\n            let j: number;\r\n            for (j = 0; j < indent; j++) {\r\n                padding += pad;\r\n            }\r\n            if (fromTo === 'opening->closing') {\r\n                formatted = formatted.substr(0, formatted.length - 1) + ln + '\\n'; // substr removes line break (\\n) from prev loop\r\n            } else {\r\n                formatted += padding + ln + '\\n';\r\n            }\r\n        }\r\n\r\n        return formatted.trim(); }\r\n\r\n\r\n    // https://stackoverflow.com/questions/13861254/json-stringify-deep-objects  implementation with depth\r\n    static circularStringify(obj: GObject, replacer?: null | ((key: string, value: any) => any), space?: string | number, maxDepth_unsupported: number = 100): string {\r\n        const cache: any[] = [];\r\n        return JSON.stringify(obj, (key, value: any) => {\r\n            if (typeof value === 'object' && value !== null) {\r\n                // Duplicate reference found, discard key\r\n                if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                if (replacer){\r\n                    value = replacer(key, value);\r\n                    if (cache.includes(value)) return \"[Circular Reference]\"; // might happen both before and after the replacer func\r\n                }\r\n                // Store value in our collection\r\n                cache.push(value);\r\n            }\r\n            return value;\r\n        }, space);\r\n    }\r\n\r\n    static getFirstNumber(s: string, allowDecimalDot: boolean = true, allowDecimalComma: boolean = true, valueifmismatch: any = null): number {\r\n        let commamode = (allowDecimalComma ? (allowDecimalDot ?\"(\\\\.|\\\\,)\" : \"\\\\,\") : (allowDecimalDot ? \"\\\\.\" : \"will not use this regex\"));\r\n        let floatregex = new RegExp(\"-?\" + commamode  + \"?\\\\d+(\" + commamode + \"\\\\d{1,2})?\");\r\n        let intregex = /-?\\d+/;\r\n        let ret: any;\r\n        if (allowDecimalDot || allowDecimalComma) ret = floatregex.exec(s);\r\n        else ret = intregex.exec(s);\r\n        ret = ret && ret[0]; // first match\r\n        if (ret === null) return valueifmismatch;\r\n\r\n        let tmpindex:number;\r\n        if (allowDecimalComma) ret = U.replaceAll(ret, \",\", \".\");\r\n        // while (allowDecimalComma && (tmpindex = ret.indexOf(\",\")) !== ret.lastIndexOf(\",\")) ret.substring(tmp+1) // ret.indexOf(.)\r\n        while ((allowDecimalDot || allowDecimalComma) && (tmpindex = ret.indexOf(\".\")) !== ret.lastIndexOf(\".\")) ret = ret.substring(tmpindex+1) // ret.indexOf(.)\r\n        // if (ret[0]===\"-\" && (ret[1]===\",\" || ret[1]===\".\")) ret = \"-0.\"+ret.substring(2); automatically done bu js.    +\"-.5\" = -0.5\r\n        return +ret;\r\n    }\r\n\r\n    // faster than jquery, underscore and many native methods checked https://stackoverflow.com/a/59787784\r\n    public static isEmptyObject(obj: GObject | undefined): boolean {\r\n        for(var i in obj) return false;\r\n        return true;\r\n    }\r\n\r\n    private static pairArrayElementsRepeatFunc<T>(val: T, index: number, arr:T[]): T[]{ return [arr[index], arr[index+1]] }\r\n    private static pairArrayElementsReducerFunc<T>(accumulator: T[][], value: T, index: number, array: T[]):T[][] {\r\n        if (index % 2 === 0) accumulator.push(array.slice(index, index + 2));\r\n        return accumulator; }\r\n\r\n    // from arr[] to arr[][]. if is with repetitions is: [1,2], [2,3], [3,4]... (ret.length = source.length-1)\r\n    // if without repetitions is: [1,2], [3,4].... (ret.length = Math.ceil(source.length/2);\r\n    public static pairArrayElements<T>(arr:T[], withRepetitions:boolean = false):T[][] {\r\n        if (withRepetitions) { return arr.map(U.pairArrayElementsRepeatFunc).slice(0, arr.length-1); }\r\n        return arr.reduce( U.pairArrayElementsReducerFunc as ((accumulator: T[][], value: T, index: number, array: T[]) => T[][]), []); }\r\n\r\n    // removes line // and block /**/ comments  todo: can likely be improved by a regular expression\r\n    public static decomment_all(str: string): string { return this.decomment_line(this.decomment_block(str)); }\r\n    // removes line comments //\r\n    public static decomment_line(str: string, trimLines: boolean = true): string {\r\n        return str\r\n            .split(\"\\n\")\r\n            .map(s=> { let i = s.indexOf(\"//\"); s = (i === -1 ? s : s.substring(i)); return trimLines ? s.trim() : s; } )\r\n            .join(\"\\n\");\r\n    }\r\n    // removes block comments /**/\r\n    public static decomment_block(str: string): string {\r\n        // let maxcomments = 100;\r\n        while(true){\r\n            // if (--maxcomments===0) break;\r\n            let s: number = str.indexOf(\"/*\");\r\n            if (s === -1) break;\r\n            let e: number = str.indexOf(\"*/\", s+1);\r\n            if (e === -1) e = str.length;\r\n            str = str.substring(0, s) + str.substring(e+2);\r\n        }\r\n        return str; }\r\n\r\n    static uppercaseFirstLetter<T extends (string | GObject<\"jsx\">)>(str: T): T {\r\n        if (typeof str !== \"string\") return str;\r\n        return str.charAt(0).toUpperCase() + str.slice(1) as T;\r\n    }\r\n\r\n    // CAREFUL! it's imperfect.\r\n    // Does not handle strings starting with ( that are not ()=> arrow functions\r\n    // or codes whose last chars are () but not in (function)() form\r\n    static wrapUserFunction(str: string): string {\r\n        str = str.trim();\r\n        if (str[0]!=='(' || str.indexOf(\"function\") !== 0) {\r\n            str = \"()=>{\" + str + \"\\n}\"; // last \\n important for line comments //\r\n        }\r\n        if (str[str.length - 2] !== \"(\" || str[str.length - 1] !== \")\") str = \"(\" + str + \")()\";\r\n        return str;\r\n    }\r\n\r\n    // adds ellipsis in the middle of a string to truncate it when it's too long.\r\n    public static stringMiddleCut<T extends boolean | undefined, RET extends string | string[] = T extends true ? string[] : string>\r\n    (str: string, maxLength: number, ellipsisChar: string = '…', asArray?: T): RET{\r\n        if (!str as unknown || maxLength < 0 || str.length <= maxLength) return (asArray ? [str] : str) as RET;\r\n        var midpoint = Math.ceil(str.length / 2);\r\n        var toremove = str.length - maxLength + ellipsisChar.length; // makes room for the additional ellipsis too\r\n        var lstrip = Math.ceil(toremove/2); // left strip is the bigger one if odd chars\r\n        var rstrip = toremove - lstrip;\r\n        if (asArray) return [str.substring(0, midpoint-lstrip), ellipsisChar, str.substring(midpoint+rstrip)] as RET;\r\n        else return str.substring(0, midpoint-lstrip) + ellipsisChar + str.substring(midpoint+rstrip) as RET;\r\n    }\r\n\r\n    // transform grays: if the color is <20% different from gray, transform it instead in black or white, 0 = don't, 1 = always black or white\r\n    public static invertHex(s: string, prefix: string='#', transformGrays: number = 0.2): string {\r\n        if (s.indexOf(prefix) === 0) s = s.substring(prefix.length);\r\n        let r: number, g: number, b: number, h: number | undefined; // might be NaN if parseInt fails\r\n        if (s.length === 3 || s.length === 4) {\r\n            r = parseInt('0x'+s[0]);// works with hex numbers\r\n            g = parseInt('0x'+s[1]);\r\n            b = parseInt('0x'+s[2]);\r\n            h = s.length === 4 ? parseInt('0x'+s[4]) : undefined;\r\n        } else if (s.length === 6 || s.length === 8){\r\n            r = parseInt('0x'+s.substring(0, 2));\r\n            g = parseInt('0x'+s.substring(2, 4));\r\n            b = parseInt('0x'+s.substring(4, 6));\r\n            h = s.length === 8 ? parseInt('0x'+s.substring(6, 8)) : undefined;\r\n        } else return Log.ee(\"cannot invert hex color \" + s + \", invalid length\", {s});\r\n        if (isNaN(r)) return Log.ee(\"cannot invert hex color \" + s +\", invalid red\", {s});\r\n        if (isNaN(g)) return Log.ee(\"cannot invert hex color \" + s +\", invalid green\", {g});\r\n        if (isNaN(b)) return Log.ee(\"cannot invert hex color \" + s +\", invalid blue\", {b});\r\n\r\n        transformGrays = transformGrays * 128;\r\n        r = Math.abs(r-128) <= transformGrays ? (r >= 128 ? 0 : 255) : 255 - r;\r\n        g = Math.abs(g-128) <= transformGrays ? (g >= 128 ? 0 : 255) : 255 - g;\r\n        b = Math.abs(b-128) <= transformGrays ? (b >= 128 ? 0 : 255) : 255 - b;\r\n        if (h || h === 0) h = 255 - h;\r\n\r\n        let rs = r.toString(16);\r\n        if (rs.length === 1) rs = '0'+rs;\r\n        let gs = g.toString(16);\r\n        if (gs.length === 1) gs = '0'+gs;\r\n        let bs = b.toString(16);\r\n        if (bs.length === 1) bs = '0'+bs;\r\n        let hs = h ? h.toString(16) : '';\r\n        if (hs.length === 1) hs = '0'+hs;\r\n\r\n        return (prefix) + rs+gs+bs+hs;\r\n    }\r\n\r\n    public static parentUntil(tagName: string, p: Element | null): Element | null {\r\n        while (p && p.tagName !== tagName) p = p.parentElement;\r\n        return p;\r\n    }\r\n\r\n    static paletteSplit(palette: Readonly<PaletteType>): {\r\n        color: Dictionary<string, PaletteControl>,\r\n        number: Dictionary<string, NumberControl>,\r\n        text: Dictionary<string, StringControl>,\r\n        path: Dictionary<string, PathControl>,\r\n    } {\r\n        type clist = PaletteControl | NumberControl | StringControl | PathControl;\r\n        let ret = {\r\n            color: {} as Dictionary<string, PaletteControl>,\r\n            number: {} as Dictionary<string, NumberControl>,\r\n            text: {} as Dictionary<string, StringControl>,\r\n            path: {} as Dictionary<string, PathControl>,\r\n        } as Dictionary<(clist)[\"type\"], Dictionary<string, any>>;\r\n        for (let entry of Object.entries(palette)) {\r\n            let k = entry[0];\r\n            let v = entry[1];\r\n            ret[(v as clist).type][k] = v;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    static mergeNamedArray<T extends GObject>(ret: T[] & Dictionary<DocString<\"$name\">, T>, classes: T[] & Dictionary<DocString<\"$name\">, T>) {\r\n        for (let key of Object.getOwnPropertyNames(classes)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (key === \"length\") continue;\r\n            if (!isNaN(+key)) ret.push(classes[key]);\r\n            // not else, if a class is named like a number it can be accessed by name until is overwrite by index being reached.\r\n            if (!ret[key]) ret[key] = classes[key];\r\n        }\r\n    }\r\n\r\n    private static prefix = 'ULibrary_';\r\n    private static clipboardinput: HTMLInputElement;\r\n    static async clipboardCopy<T>(text: string, onSuccess?:()=>T, onFailure?:()=>T): Promise<T | undefined> {\r\n        let ret: boolean = false;\r\n        return navigator.clipboard.writeText(text).then(() => {\r\n            ret = true;\r\n            if (onSuccess) return onSuccess();\r\n        },() => {\r\n            ret = U.clipboardCopy_old(text);\r\n            return ret ? onSuccess && onSuccess() : onFailure && onFailure();\r\n        });\r\n    }\r\n    static clipboardCopy_old(text: string): boolean {\r\n        try{\r\n        if (!U.clipboardinput) {\r\n            U.clipboardinput = document.createElement('input');\r\n            U.clipboardinput.id = U.prefix + 'CopyDataToClipboard';\r\n            U.clipboardinput.type = 'text';\r\n            U.clipboardinput.style.display = 'block';\r\n            U.clipboardinput.style.position = 'absolute';\r\n            U.clipboardinput.style.top = '-100vh'; }\r\n        document.body.appendChild(U.clipboardinput);\r\n        U.clipboardinput.value = text;\r\n        U.clipboardinput.select();\r\n        if (!document.execCommand) return false;\r\n        let ret = document.execCommand('copy');\r\n        document.body.removeChild(U.clipboardinput);\r\n        U.clearSelection();\r\n        return ret;\r\n        }\r\n        catch(e){ return false; }\r\n    }\r\n\r\n    static clearSelection() {}\r\n\r\n    static isError(obj: unknown): obj is Error{\r\n        // obj istanceof Error // this is not iframe-safe, Errors from different iframes are considered different instances\r\n        // this is iframe-safe and catches all error types\r\n        return Object.prototype.toString.call(obj) === \"[object Error]\";\r\n        // or err.toString --> \"Error: message\" dunno if stack is printed too i tested with a fake error.\r\n    }\r\n\r\n    static toNamedArray<D extends DPointerTargetable, L extends LPointerTargetable>(larr:L[], darr?:D[]): L[] & Dictionary<DocString<\"$name\">, L>{\r\n        if (!darr || darr.length !== larr.length) darr = larr.map(l=>l.__raw as D);\r\n\r\n        for (let i = 0; i < larr.length; i++) if (darr[i] && larr[i]) (larr as GObject)[\"$\"+(darr[i] as GObject).name] = larr[i];\r\n        /*for (let index of Object.getOwnPropertyNames(larr)) { // ownPropertyNames skips \"first, last, separator\" created by extending array prototype\r\n            if (index === \"length\") continue;\r\n            let d = darr[index as any as number];\r\n            let l = larr[index as any as number];\r\n            if (!d || !l) continue;\r\n            (larr as any)[\"$\" + (d as any).name] = l;\r\n        }*/\r\n        return larr as any;\r\n    }\r\n\r\n    public static cropDeepObject(o: any, lines_start_crop: number=20, lines_end_crop: number=10, string_start_crop: number=45, string_end_crop: number=35, num_digit_crop: number=5): any{\r\n        if (!o) return o;\r\n        let replacer = (o: GObject) => {\r\n            switch (typeof o) {\r\n                default:\r\n                    return o;\r\n                case \"string\":\r\n                    return U.cropStr(o, lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"function\":\r\n                    return U.cropStr(o.toString(), lines_start_crop, lines_end_crop, string_start_crop, string_end_crop);\r\n                case \"number\":\r\n                    return U.cropNum(num_digit_crop);\r\n                case \"object\":\r\n                    if (o === null) return null;\r\n                    if (U.isHtmlNode(o)) return '[HTMLElement]';\r\n                    if (U.isError(o)) return {stack: o.stack, message: o.message};\r\n                    // if (U.isDate(o)) return \"[Date \"+o.getTime()+\"]\";\r\n                    return o.__raw || o;\r\n            }\r\n        }\r\n        return U.deepReplace(o, replacer);\r\n    }\r\n\r\n    static deepCopy(obj: any, circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any)): any {\r\n        return U.deepReplace(obj, undefined, circularReferenceValue);\r\n    }\r\n\r\n    // does make a deep copy too.\r\n    static deepReplace(obj: any, replacer?: ((o: any) => any),\r\n                       circularReferenceValue: any | ((obj_alreadymet: GObject)=>any) = (o: GObject)=>((o.__raw || o).id || '_circular_ref_')): any {\r\n\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        return U.deepReplace_rec(obj, avoidloop, replacer, circularReferenceValue);\r\n    }\r\n\r\n    /**\r\n     replacing always preserves same reference statuses. eg, when  {a:\"x\", b:\"x\"} -> {a:\"y\", b:\"y\"}\r\n     if the original x,y values are the same reference (not just value),\r\n     in the output object a,b will also be the same reference (replacer will not be called twice on the same string)\r\n\r\n     note that let arr = [\"a\", \"a\"] is an array with 2 equal values but different references.\r\n     while let a = \"a\"; let arr = [a, a] have equal references.\r\n\r\n     circularReferenceValue === \"__preserve\" causes any duplicate reference causing a loop to be replaced\r\n     with the target of the first reference instead of the \"__preserve\" string.\r\n\r\n     todo: add parameter eagerLoopReturn (current behaviour is eagerLoopReturn = true)\r\n     eagerLoopReturn = true returns as soon a duplicate objects is found, the returned structure is guaranteed to not have duplicates. [a,a] => [a,'loop','loop']\r\n     eagerLoopReturn = false returns 'loop' only if an object is already found AND have subobjects.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] --> [{id:\"a1\", l:{b:1}, {id:\"a1\", l:'_loop_']\r\n     finaly eagerLoopReturn = 'inline' replaces with '_loop_' only when there is really a circular ref\r\n     (found an object already found in the current \"path\" from root to current obj)\r\n     so i need to copy the current map and pass a new copy every time i go deep on a new subobject, branching a tree.\r\n     let a = {id:\"a1\", l:{b:1}};    [a,a] will still return [a,a] with no '_loop_' tags\r\n     instead let a = {l:{b:1}, a:a};    [a,a] will return [{l:{b:1}, a:'_loop_'}, {l:{b:1}, a:'_loop_'}] with no '_loop_' tags\r\n     while\r\n     */\r\n    static deepReplace_rec(obj: any, avoidloop: GObject & WeakMap<any, true>, replacer?: ((o: any) => any),\r\n                           circularReferenceValue?: any | ((obj_alreadymet: GObject)=>any), key: number | string, curdept:number=0, eagerLoopReturn: boolean = false): any {\r\n        if (typeof obj === \"symbol\") return replacer ? replacer(obj) : obj;\r\n\r\n        let old_obj = obj;\r\n        switch (typeof old_obj) {\r\n            case \"symbol\": // don't know what really do with symbols and funcs\r\n            case \"function\":\r\n                break;\r\n            default: // because primitive types cannot be used as WeakMap.set(key), but can as Object keys\r\n                if (obj in avoidloop) return avoidloop[obj];\r\n                else avoidloop[old_obj] = obj;\r\n                break;\r\n            case \"object\":\r\n                if (old_obj === null) {\r\n                    if (avoidloop[old_obj]) return avoidloop[old_obj];\r\n                    else avoidloop[old_obj] = obj;\r\n                    break;\r\n                }\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    if (Array.isArray(obj) && obj.length === 0 || Object.keys(obj).length === 0) return obj;\r\n\r\n                    if (circularReferenceValue === \"__preserve\" || typeof obj !== \"object\") return avoidloop.get(obj);\r\n                    else return typeof circularReferenceValue === \"function\" ? circularReferenceValue(obj) : circularReferenceValue;\r\n                } else avoidloop.set(old_obj, obj);\r\n                break;\r\n        }\r\n\r\n\r\n        if (replacer) obj = replacer(obj);\r\n        switch (typeof obj){\r\n            default: break; // obj = obj; return obj; // for any leaf type\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return obj;\r\n                if (Array.isArray(obj)) {\r\n                    obj = obj.map((o, i) => U.deepReplace_rec(o, avoidloop, replacer, circularReferenceValue, i,curdept+1));\r\n                    break;\r\n                }\r\n                let o: GObject = {};\r\n                for (let k in obj) {\r\n                    o[k] = U.deepReplace_rec(obj[k], avoidloop, replacer, circularReferenceValue, k, curdept+1);\r\n                }\r\n                obj = o;\r\n                break;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n\r\n\r\n    // returns path to that object to find\r\n    public static deepFindInObject(obj: any, subobject: any, compareFunc?:(a:any,b:any)=>boolean, maxDepth: number = Number.POSITIVE_INFINITY): string | undefined {\r\n        const avoidloop: WeakMap<any, true> = new WeakMap();\r\n        let ret = U.deepFindInObject_rec(obj, subobject, avoidloop, maxDepth, compareFunc);\r\n        if (ret === '') return 'this';\r\n        else return ret;\r\n    }\r\n    private static deepFindInObject_rec(obj: any, subobject: any, avoidloop: GObject & WeakMap<any, true>, maxDepth: number, compareFunc?:((a:any,b:any)=>boolean), curdepth:number=0): string | undefined {\r\n        if (compareFunc ? compareFunc(obj, subobject) : obj === subobject) return ''\r\n        if (curdepth >= maxDepth) return undefined;\r\n\r\n        let old_obj = obj;\r\n        switch (typeof old_obj) {\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (old_obj === null) return undefined;\r\n                if (avoidloop.has(obj)) { // for objects\r\n                    return undefined;\r\n                } else avoidloop.set(old_obj, obj);\r\n                break;\r\n        }\r\n\r\n        switch (typeof obj){\r\n            default: return undefined;\r\n            case \"object\":\r\n                if (U.isHtmlNode(obj)) return undefined;\r\n                if (Array.isArray(obj)) {\r\n                    for (let i = 0; i < obj.length; i++) {\r\n                        let found = U.deepFindInObject_rec(obj[i], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                        if (found === '') return i+'';\r\n                        else if (found !== undefined) return i+'.'+found;\r\n                    }\r\n                    return undefined;\r\n                }\r\n                for (let k in obj) {\r\n                    let found = U.deepFindInObject_rec(obj[k], subobject, avoidloop, maxDepth, compareFunc, curdepth+1);\r\n                    if (found === '') return k+'';\r\n                    if (found !== undefined) return k+'.'+found;\r\n                }\r\n                return undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n\r\n    public static mailerror(recipients: string[], title: string, msgbody_notencoded: string, canUseClipboard: boolean, clipboardSuccess?: ()=>any, clipboardFailure?: ()=>any) {\r\n\r\n        const msgbody: string = encodeURIComponent(msgbody_notencoded);\r\n        const mailtitle: string =  encodeURIComponent(title);\r\n        // \"mailto:no-one@snai1mai1.com?subject=look at this website&body=Hi,I found this website and thought you might like it http://www.geocities.com/wowhtml\"\r\n        const gitissue = \"https://github.com/MDEGroup/jjodel/issues/new?title=\"+mailtitle+\"&body=\"+msgbody;\r\n        let mailto: string | undefined = \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\"+msgbody;\r\n        const mailtolimit = 2042 - 23/*for safety*/;\r\n        /*\r\n            mailto: limits\r\n            2042 characters on Chrome 64.0.3282.186\r\n            2046 characters on Edge 16.16299\r\n            approximately 32700 characters on Firefox 58.0\r\n\r\n            max URI lengths:\r\n            chrome: 15613 chars\r\n            firefox: 15708\r\n        */\r\n        if (mailto.length > mailtolimit){\r\n            if (canUseClipboard) {\r\n                const mailfallback = encodeURIComponent(\"mail body exceeded maximum mailto: link length.\\n\" +\r\n                    \"It has been copied to your clipboard, please past it here or use github issue report.\");\r\n                U.clipboardCopy(msgbody_notencoded, clipboardSuccess, clipboardFailure);\r\n                mailto =  \"mailto:\"+recipients.join(';')+\"?subject=\"+mailtitle+\"&body=\" + mailfallback;\r\n            }\r\n            else mailto = undefined;\r\n        }\r\n        return {gitissue, mailto};\r\n    }\r\n\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    private static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n}\r\nexport class DDate{\r\n    static cname: string = \"DDate\";\r\n\r\n    public static addDay(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setDate(date.getDate() + offset);\r\n        return ret;\r\n    }\r\n    public static addMonth(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setMonth(date.getMonth() + offset);\r\n        return ret;\r\n    }\r\n    public static addYear(date: Date, offset: number, inplace: boolean): Date {\r\n        const ret: Date = inplace ? date : new Date(date);\r\n        ret.setFullYear(date.getFullYear() + offset);\r\n        return ret;\r\n    }\r\n}\r\n\r\nexport class myFileReader {\r\n    private static input: HTMLInputElement = null as any;\r\n    private static fileTypes: string[] = null as any;\r\n    private static onchange: (e: Event) => void = null as any;\r\n    // constructor(onchange: (e: ChangeEvent) => void = null, fileTypes: FileReadTypeEnum[] | string[] = null) { myFileReader.setinfos(fileTypes, onchange); }\r\n    private static setinfos(fileTypes: undefined | FileReadTypeEnum[] | string[], onchange: (e: Event, files: FileList | null, contents: string[] | undefined ) => void, readcontent: boolean) {\r\n        myFileReader.fileTypes = (fileTypes || myFileReader.fileTypes) as string[];\r\n        const debug: boolean = false;\r\n        debug&&console.log('fileTypes:', myFileReader.fileTypes, fileTypes);\r\n        myFileReader.input = document.createElement('input');\r\n        const input: HTMLInputElement = myFileReader.input;\r\n        myFileReader.onchange = function (e: Event): void {\r\n            if (!readcontent) { onchange(e, input.files, undefined); return; }\r\n            let contentObj: Dictionary<number, string> = {};\r\n            let fileLetti: number = 0;\r\n            for (let i: number = 0; input.files && i <input.files.length; i++) {\r\n                const f: File = input.files[i];\r\n                debug&&console.log('filereadContent['+i+']( file:', f, ')');\r\n                U.fileReadContent(f, (content: string) => {\r\n                    debug&&console.log('file['+i+'] read complete. done: ' + ( 1 + fileLetti) + ' / ' + input.files?.length, 'contentObj:', contentObj);\r\n                    contentObj[i] = content; // cannot use array, i'm not sure the callbacks will be called in order. using push is safer but could alter order.\r\n                    // this is last file to read.\r\n                    if (input.files && ++fileLetti === input.files.length) {\r\n                        const contentArr: string[] = [];\r\n                        for (let j: number = 0; j < input.files.length; j++) { contentArr.push(contentObj[j]); }\r\n                        onchange(e, input.files, contentArr);\r\n                    }\r\n                });\r\n            }\r\n        } || myFileReader.onchange;\r\n    }\r\n    private static reset(): void {\r\n        myFileReader.fileTypes = undefined as any;\r\n        myFileReader.onchange = undefined as any;\r\n        myFileReader.input = undefined as any;\r\n    }\r\n    public static show(onChange: (e: Event, files: FileList | null, contents?: string[]) => void, extensions: undefined | string[] | FileReadTypeEnum[] = undefined, readContent: boolean): void {\r\n        console.log(\"importEcore: pre file reader\", myFileReader.input);\r\n        myFileReader.setinfos(extensions, onChange, readContent);\r\n        //if (!myFileReader.input) return;\r\n        myFileReader.input.setAttribute('type', 'file');\r\n        if (myFileReader.fileTypes) {\r\n            myFileReader.input.setAttribute('accept', myFileReader.fileTypes.join(','));\r\n        }\r\n        //console.log('fileTypes:', myFileReader.fileTypes, 'input:', myFileReader.input);\r\n        $(myFileReader.input).on('change.custom' as any, myFileReader.onchange).trigger('click');\r\n        myFileReader.reset();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('Uarr')\r\nexport class Uarr{\r\n    public static arrayIntersection<T>(arr1: T[], arr2: T[]): T[]{\r\n        if (!arr1 || ! arr2) return null as any;\r\n        return arr1.filter( e => arr2.indexOf(e) >= 0);\r\n    }\r\n\r\n    static arraySubtract(arr1: any[], arr2: any[], inPlace: boolean): any[]{\r\n        let i: number;\r\n        const ret: any[] = inPlace ? arr1 : [...arr1];\r\n        for (i = 0; i < arr2.length; i++) { U.arrayRemoveAll(ret, arr2[i]); }\r\n        return ret; }\r\n\r\n    static equals<T extends any>(a1: T[], a2: T[], deep: boolean): boolean {\r\n        Log.ex(deep, \"deep array comparison is not supported yet\");\r\n        if (!a1 || !a2) return false;\r\n        if (a1.length !== a2.length) return false;\r\n        for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;\r\n        return true;\r\n    }\r\n}\r\n\r\nexport class FocusHistoryEntry {\r\n    static cname: string = \"FocusHistoryEntry\";\r\n    time: Date;\r\n    evt: JQuery.FocusInEvent;\r\n    element: Element;\r\n    constructor(e: JQuery.FocusInEvent, element?: Element, time?: Date) {\r\n        this.evt = e;\r\n        this.element = element || e.target;\r\n        this.time = time || new Date();\r\n    }\r\n}\r\nexport enum ShortDefaultEClasses{\r\n    EObject = \"EObject\",\r\n    EAnnotation = \"EAnnotation\",\r\n    EClass = \"EClass\",\r\n    EPackage = \"EPackage\",\r\n    ENamedElement = \"ENamedElement\",\r\n}\r\nexport enum ShortAttribETypes {\r\n    EVoid = 'EVoid',\r\n    EChar  = 'EChar',\r\n    EString  = 'EString',\r\n    EDate  = 'EDate',\r\n    EBoolean = 'EBoolean',\r\n    EByte  = 'EByte',\r\n    EShort  = 'EShort',\r\n    EInt  = 'EInt',\r\n    ELong  = 'ELong',\r\n    EFloat  = 'EFloat',\r\n    EDouble  = 'EDouble',\r\n    // EDiagnosticChain = \"EDiagnosticChain\", // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    /*\r\n  ECharObj  = 'ECharObj',\r\n  EStringObj  = 'EStringObj',\r\n  EDateObj  = 'EDateObj',\r\n  EFloatObj  = 'EFloatObj',\r\n  EDoubleObj  = 'EDoubleObj',\r\n  EBooleanObj = 'EBooleanObj',\r\n  EByteObj  = 'EByteObj',\r\n  EShortObj  = 'EShortObj',\r\n  EIntObj  = 'EIntObj',\r\n  ELongObj  = 'ELongObj',\r\n  EELIST  = 'EELIST',*/\r\n\r\n}\r\nwindoww.ShortAttribETypes = ShortAttribETypes;\r\n\r\nexport const ShortAttribSuperTypes: Dictionary<ShortAttribETypes, ShortAttribETypes[]> = {\r\n    \"EVoid\"    : [],\r\n    \"EChar\"    : [ShortAttribETypes.EString],\r\n    \"EString\"  : [],\r\n    \"EDate\"    : [],\r\n    \"EBoolean\" : [ShortAttribETypes.EByte, ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EByte\"    : [ShortAttribETypes.EShort, ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EShort\"   : [ShortAttribETypes.EInt, ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EInt\"     : [ShortAttribETypes.ELong, ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"ELong\"    : [ShortAttribETypes.EFloat, ShortAttribETypes.EDouble],\r\n    \"EFloat\"   : [ShortAttribETypes.EDouble],\r\n    \"EDouble\"  : []\r\n};\r\nlet ecoreprefix = \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//\";\r\nlet ecoreclasprefix = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//\";\r\nexport function toShortEType(a: AttribETypes): ShortAttribETypes{ return a.substring(ecoreprefix.length) as any; }\r\nexport function toLongEType(a: ShortAttribETypes): AttribETypes {\r\n    return AttribETypes[a];\r\n    // return ecoreprefix + a as any;\r\n}\r\n\r\nexport function toShortEClass(a: DefaultEClasses): ShortDefaultEClasses{ return a.substring(ecoreclasprefix.length) as any; }\r\nexport function toLongEClass(a: ShortDefaultEClasses): DefaultEClasses { return DefaultEClasses[a]; }\r\n\r\nexport class SelectorOutput {\r\n    jqselector!: string;\r\n    attrselector!: string;\r\n    attrRegex!: RegExp;\r\n    exception!: any;\r\n    resultSetAttr!: Attr[];\r\n    resultSetElem!: JQuery<Element>;\r\n}\r\n// compare it with event.key\r\nexport enum Keystrokes {\r\n    clickLeft = 0,\r\n    clickWheel = 1,\r\n    clickRight = 2,\r\n    clickBackMouseButton = 3,\r\n    clickForwardMouseButton = 4,\r\n\r\n    // keyboard\r\n    escape = 'Escape',\r\n    capsLock = 'CapsLock',\r\n    shift = 'Shift',\r\n    tab = 'Tab',\r\n    alt = 'Alt',\r\n    control = 'Control',\r\n    end = 'End',\r\n    home = 'Home',\r\n    pageUp = 'PageUp',\r\n    pageDown = 'PageDown',\r\n    enter = 'Enter', // event.code = 'NumpadEnter' se fatto da numpad, oppure \"numpad3\", \"NumpadMultiply\", ShiftLeft, etc...\r\n    numpadEnter = 'NumpadEnter',\r\n    audioVolumeMute = 'AudioVolumeMute',\r\n    audioVolumeUp = 'AudioVolumeUp',\r\n    audioVolumeDown = 'AudioVolumeDown',\r\n    mediaTrackPrevious = 'MediaTrackPrevious',\r\n    delete = 'Delete', // canc\r\n    backspace = 'Backspace',\r\n    space = ' ',\r\n    altGraph = 'AltGraph',\r\n    arrowLeft = 'ArrowLeft',\r\n    arrowRight = 'ArrowRight',\r\n    arrowUp = 'ArrowUp',\r\n    arrowDown = 'ArrowDown',\r\n    insert = 'Insert',\r\n    f1 = 'F1',\r\n    // weird ones:\r\n    meta = 'Meta', // f1, or other f's with custom binding and windows key\r\n    unidentified = 'Unidentified', // brightness\r\n    __NotReacting__ = 'fn, print, maybe others', // not even triggering event?\r\n}\r\n\r\nexport enum DefaultEClasses{\r\n    EObject = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\",\r\n    EAnnotation = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EAnnotation\",\r\n    EClass = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EClass\",\r\n    EPackage = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EPackage\",\r\n    ENamedElement = \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//ENamedElement\",\r\n}\r\nexport enum AttribETypes {\r\n    EVoid = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EVoid', // ??? i invented this.\r\n    EChar = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EChar',\r\n    EString = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString',\r\n    EDate = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDate',\r\n    EFloat = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloat',\r\n    EDouble = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble',\r\n    EBoolean = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean',\r\n    EByte = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByte',\r\n    EShort = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShort',\r\n    EInt = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt',\r\n    ELong = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong',\r\n    // present in uml.ecore, without definition. i guess it's a custom installed package which is commonly used\r\n    // EDiagnosticChain = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDiagnosticChain',\r\n    /*\r\n  ECharObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ECharObject',\r\n  EStringObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EStringObject',\r\n  EDateObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDateObject',\r\n  EFloatObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EFloatObject',\r\n  EDoubleObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubleObject',\r\n  EBooleanObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBooleanObj',\r\n  EByteObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EByteObject',\r\n  EShortObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EShortObject',\r\n  EIntObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EIntegerObject',\r\n  ELongObj = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELongObject', */\r\n    // EELIST = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EEList', // List<E> = List<?>\r\n}\r\n\r\n// export type Json = object;\r\n\r\nexport class ParseNumberOrBooleanOptions{\r\n    defaultValue?: any;\r\n    allowNull?: boolean; nullValue?: any;\r\n    allowUndefined?: boolean; undefinedValue?: any;\r\n    allowedNan?: boolean; nanValue?: any;\r\n    allowBooleans?: boolean; trueValue?: any; falseValue?: any;\r\n    constructor(\r\n        defaultValue: any = null, allowNull: boolean = false, nullValue: any = null,\r\n        allowUndefined: boolean = false, undefinedValue: any = undefined,\r\n        allowedNan: boolean = false, nanValue: any = NaN,\r\n        allowBooleans: boolean = true, trueValue : any = 1, falseValue: any = 0) {\r\n        this.defaultValue = defaultValue; this.allowNull = allowNull; this.nullValue = nullValue;\r\n        this.allowUndefined = allowUndefined; this.undefinedValue = undefinedValue;\r\n        this.allowedNan = allowedNan; this.nanValue = nanValue;\r\n        this.allowBooleans = allowBooleans; this.trueValue = trueValue; this.falseValue = falseValue;\r\n    }\r\n}\r\n/*\r\ninterface LoggerInterface{\r\n    log: (category: string, key: string, data: any[], fullconcat?: string, stringified?: string) => any;\r\n}*/\r\n\r\n\r\n\r\nexport class FileReadTypeEnum {\r\n    public static image: FileReadTypeEnum = \"image/*\" as any;\r\n    public static audio: FileReadTypeEnum = \"audio/*\" as any;\r\n    public static video: FileReadTypeEnum = \"video/*\" as any;\r\n    /// a too much huge list https://www.iana.org/assignments/media-types/media-types.xhtml\r\n    public static AndManyOthersButThereAreTooMuch: string = \"And many others... https://www.iana.org/assignments/media-types/media-types.xhtml\";\r\n    public static OrJustPutFileExtension: string = \"OrJustPutFileExtension\";\r\n}\r\n\r\n// console.info('loaded ts U');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}