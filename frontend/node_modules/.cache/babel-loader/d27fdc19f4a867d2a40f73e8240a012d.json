{"ast":null,"code":"var _class, _class2, _class3, _class4, _class5, _class6, _class7, _class8, _class9, _class10, _class11, _class12, _class13, _class14, _class15, _class16, _class17, _class18, _class19, _class20, _class21;\nimport { Log, RuntimeAccessible, RuntimeAccessibleClass, store, windoww } from \"../../joiner\";\n\n// transactional-like start of storage modification\n// todo: nested transaction che conti quanti begin hai effettuato e crei una matrice di pendingActions una per ogni livello nested?\n\n/*\r\n// let nestedlevel: number = 0;\r\nclass NestedLevel{\r\n    level: number;\r\n    actions: Action[] = [];\r\n    up:NestedLevel[] = [];\r\n    down?:NestedLevel;\r\n\r\n    constructor(prevLevel?: NestedLevel, actions: Action[] = []) {\r\n        // this.prev = prev;\r\n        this.down = prevLevel;\r\n        this.actions = actions;\r\n        this.level = prevLevel ? prevLevel.level + 1 : 0;\r\n    }\r\n\r\n    add1(a:Action){ this.actions.push(a); }\r\n    add(a:Action[]){ this.actions.push(...a); }\r\n    push(actions:Action[]=[]){\r\n        this.up.push(new NestedLevel(this, actions));\r\n    }\r\n}\r\n// @Singleton\r\nclass NestedTransactionManager{\r\n    // private levels: NestedLevel[] = [];\r\n    public currentLevel?: NestedLevel;\r\n    // simple array is not good i can have spikes as russian mountains going up and down in deepness it's kinda a matrix or a pile of dishes like below'\r\n\r\n\r\n    /*\r\n    todo: to debug missing END paired with a begin, seve stack trace of begins and ends\r\n    * every level must have his own array?\r\n    * Begin0, Begin1, Begin2, End2, End1, Begin1.1 Begin 1.2....\r\n    it's a tree!\r\n    *\r\n    *\r\n    * ______begin lv2                              _______Begin1.2\r\n    * _________________________begin lv1           ___________________Begin1.1\r\n    * ____________________________________________________________________________________________________ a begin lv0\r\n    * * /\r\n    constructor() {}\r\n    begin(actions: Action[]=[]): void { this.pushLevel(actions); }\r\n    pushLevel(actions: Action[]=[]): void {\r\n        if (!this.currentLevel) { this.currentLevel = new NestedLevel(undefined, actions); return; }\r\n        this.currentLevel.push(actions); }\r\n    end(){\r\n        if (!this.currentLevel) return this.finalEnd();\r\n        this.currentLevel = this.currentLevel?.down; }\r\n    finalEnd(){\r\n\r\n    }\r\n    // current(): NestedLevel { return this.currentLevel; }\r\n    addActions(a:Action[]): void { this.currentLevel!.add(a); }\r\n    addAction(a:Action): void { this.currentLevel!.add1(a); }\r\n}\r\nlet transactionmanager = new NestedTransactionManager();\r\nfunction BEGIN2(){\r\n    transactionmanager.pushLevel();\r\n}\r\nfunction ABORT2(){\r\n    transactionmanager.end();\r\n}\r\nfunction END2(){\r\n\r\n}*/\n\nexport function BEGIN_OLD() {\n  pendingActions = [];\n  hasBegun = true;\n}\n_c = BEGIN_OLD;\nexport function ABORT_OLD() {\n  hasBegun = false;\n  pendingActions = [];\n}\n_c2 = ABORT_OLD;\nexport function END_OLD() {\n  let actionstoPrepend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  hasBegun = false;\n  // for (let action of pendingActions) { }\n  const ca = new CompositeAction((actionstoPrepend === null || actionstoPrepend === void 0 ? void 0 : actionstoPrepend.length) ? [...actionstoPrepend, ...pendingActions] : pendingActions, false);\n  pendingActions = [];\n  return ca.fire();\n}\n_c3 = END_OLD;\nlet pendingActions = [];\nlet hasBegun = false;\nlet deepnessLevel = 0;\nexport function BEGIN() {\n  hasBegun = true; // redundant but actions are reading this, minimize changes\n  deepnessLevel++;\n}\n_c4 = BEGIN;\nexport function ABORT() {\n  deepnessLevel--;\n  pendingActions = [];\n}\n_c5 = ABORT;\nexport function END() {\n  let actionstoPrepend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  deepnessLevel--;\n  if (actionstoPrepend.length) pendingActions = [...actionstoPrepend, ...pendingActions];\n  if (deepnessLevel < 0) {\n    console.error(\"mismatching END()\");\n    deepnessLevel = 0;\n  }\n  if (deepnessLevel === 0) return FINAL_END();\n  return false;\n}\n_c6 = END;\nexport function FINAL_END() {\n  hasBegun = false;\n  const ca = new CompositeAction(pendingActions, false);\n  pendingActions = [];\n  return ca.fire();\n}\n\n// make class isinstorage e mettici il path studia annotazioni per annotare gli oggett in modo che vengano rwappati prima di farli ritornare se sono annotati\n// minor todo: type as (...args: infer P) => any) ?\n_c7 = FINAL_END;\nexport function TRANSACTION(func) {\n  BEGIN();\n  // minor todo: potrei fare l'override di Error() per fare in modo che gli errori vengano presi anche se non uso TRANSACTION o try-catch ?\n  try {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    func(...params);\n  } catch (e) {\n    Log.ee('Transaction failed:', e);\n    ABORT();\n    return false;\n  }\n  return END();\n}\n_c8 = TRANSACTION;\nexport let Action = RuntimeAccessible(_class = (_class2 = class Action extends RuntimeAccessibleClass {\n  // targetID: string | undefined;\n  // target: IClass = null as any;\n\n  // field: string = ''; // es: ID_58\n  // value: any; // es: lowerbound, name, namespace, values (for attrib-ref)...\n\n  //?\n  constructor(field, value, subType) {\n    var _Error$stack;\n    super();\n    this.hasFired = 0;\n    this.consoleTargetSelector = '';\n    this.type = void 0;\n    this.field = void 0;\n    this.value = void 0;\n    this.src = void 0;\n    this.subType = void 0;\n    this.field = field;\n    this.value = value;\n    this.type = this.constructor.type;\n    this.src = (_Error$stack = new Error().stack) === null || _Error$stack === void 0 ? void 0 : _Error$stack.split('\\n').splice(2);\n    this.subType = subType;\n    this.className = this.constructor.name;\n  }\n  fire() {\n    let forceRelaunch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.hasFired && !forceRelaunch) return false;\n    if (hasBegun) {\n      pendingActions.push(this);\n    } else {\n      this.hasFired++;\n      let storee = store || windoww.store;\n      console.trace('firing action:', this, 'store:', storee);\n      storee.dispatch({\n        ...this\n      });\n    }\n    return true;\n  }\n  static parse1(action) {\n    const ret = action;\n    ret.path = action.field; // normalize the path\n    ret.pathArray = ret.path.split('.');\n    ret.executionCount = 0;\n    if (!action.subType) return ret;\n    if (!Action.possibleInconsistencies[action.subType]) Action.possibleInconsistencies[action.subType] = [action.value];else Action.possibleInconsistencies[action.subType].push(action.value);\n    return ret;\n  }\n  static parse(actions) {\n    if (actions.className === CompositeAction.name) throw new Error(\"Composite action cannot be parsed directly, parse composite.actions instead\");\n    if (!Array.isArray(actions)) return Action.parse1(actions);\n    return actions.map(Action.parse1);\n  }\n}, _class2.type = 'ACTION', _class2.SubType = void 0, _class2.possibleInconsistencies = {}, _class2)) || _class;\nexport let LoadAction = RuntimeAccessible(_class3 = (_class4 = class LoadAction extends Action {\n  static new(state) {\n    return state && new LoadAction(state).fire();\n  }\n  constructor(state) {\n    let fire = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super('', state, '');\n    this.className = this.constructor.name;\n    if (fire) this.fire();\n  }\n}, _class4.type = 'LOAD', _class4)) || _class3;\nexport let SetRootFieldAction = RuntimeAccessible(_class5 = (_class6 = class SetRootFieldAction extends Action {\n  static new(fullpath, val) {\n    let accessModifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let isPointer = arguments.length > 3 ? arguments[3] : undefined;\n    if (accessModifier) fullpath += accessModifier;\n    return new SetRootFieldAction(fullpath, val, false, isPointer).fire();\n  }\n  constructor(fullpath) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let fire = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let isPointer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(fullpath, value, undefined);\n    this.isPointer = void 0;\n    this.className = this.constructor.name;\n    this.isPointer = isPointer;\n    if (fire) this.fire();\n  }\n  static create(fullpath, val) {\n    let accessModifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let isPointer = arguments.length > 3 ? arguments[3] : undefined;\n    return new SetRootFieldAction(fullpath + (accessModifier || ''), val, false, isPointer);\n  }\n}, _class6.type = 'SET_ROOT_FIELD', _class6)) || _class5;\n\n// todo: ma non so come, fare in modo che [], +=, -=, siano disponibili solo se la chiave è il nome di un attributo di tipo array\n\nexport let SetFieldAction = RuntimeAccessible(_class7 = (_class8 = class SetFieldAction extends SetRootFieldAction {\n  /*\r\n      static new<\r\n          D extends DPointerTargetable,\r\n          T extends (keyof D),\r\n          AM extends AccessModifier | undefined = ''\r\n          >(me: D | Pointer<D>,\r\n            field: T,\r\n            val: string | string[],\r\n            accessModifier: AM | undefined,\r\n            isPointer: boolean): boolean;*/\n\n  static new(me, field, val) {\n    let accessModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    let isPointer = arguments.length > 4 ? arguments[4] : undefined;\n    if (accessModifier) field += accessModifier;\n    return new SetFieldAction(me, field, val, false, isPointer).fire();\n  }\n\n  // field can end with \"+=\", \"[]\", or \"-1\" if it's array\n  constructor(me, field, val) {\n    let fire = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let isPointer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    Log.exDev(!me, 'BaseObject missing in SetFieldAction', {\n      me,\n      field,\n      val\n    });\n    super('idlookup.' + (me.id || me) + (field ? '.' + field : ''), val, false, isPointer);\n    this.className = this.constructor.name;\n    if (fire) this.fire();\n  }\n}, _class8.type = 'SET_ME_FIELD', _class8)) || _class7;\n\n/*\r\ntodo: showcase this\r\nlet dclass: DClass = null as any;\r\nSetFieldAction.new(dclass, 'namek', '') // non è un attributo di \"DCLass\"\r\nSetFieldAction.new(dclass, 'parent', '') // val (stringa) non è assegnabile a parent (array di puntatori)\r\nSetFieldAction.new(dclass, 'name.5k', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4k]', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4]', '') // ok, anche se non dovrebbe accettare la dicitura array per name che è un primitivo (check non implementato, troppo difficile)\r\nSetFieldAction.new(dclass, 'name.5', '') // ok, equivale a dicitura array\r\n*/\n\nexport let RedoAction = RuntimeAccessible(_class9 = (_class10 = class RedoAction extends Action {\n  static new() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let notfire = arguments.length > 1 ? arguments[1] : undefined;\n    let act = new RedoAction(amount);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    super('', amount);\n    this.className = this.constructor.name;\n  }\n}, _class10.type = 'RedoAction', _class10)) || _class9;\nexport let UndoAction = RuntimeAccessible(_class11 = (_class12 = class UndoAction extends Action {\n  static new() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let notfire = arguments.length > 1 ? arguments[1] : undefined;\n    let act = new UndoAction(amount);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    let amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    super('', amount);\n    this.className = this.constructor.name;\n  }\n}, _class12.type = 'UndoAction', _class12)) || _class11;\nexport let CombineHistoryAction = RuntimeAccessible(_class13 = (_class14 = class CombineHistoryAction extends Action {\n  static new(notfire) {\n    let act = new CombineHistoryAction();\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor() {\n    super('', '');\n    this.className = this.constructor.name;\n  }\n}, _class14.type = 'CombineHistoryAction', _class14)) || _class13;\nexport let CreateElementAction = RuntimeAccessible(_class15 = (_class16 = class CreateElementAction extends Action {\n  static newBatch(me, notfire) {\n    return me.map(e => CreateElementAction.new(e, notfire));\n  }\n  static new(me, notfire) {\n    if (me.__raw) me = me.__raw;\n    let act = new CreateElementAction(me, !notfire);\n    if (!notfire) return act.fire();\n    return act;\n  }\n  constructor(me) {\n    let fire = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super('idlookup.' + me.id, me);\n    this.value = void 0;\n    this.className = this.constructor.name;\n    this.value = me;\n    if (fire) this.fire();\n  }\n}, _class16.type = 'CREATE_ELEMENT', _class16)) || _class15;\nexport let DeleteElementAction = RuntimeAccessible(_class17 = (_class18 = class DeleteElementAction extends SetFieldAction {\n  static new(me) {\n    return new DeleteElementAction(me).fire();\n  }\n  constructor(me) {\n    super(me.id || me, '', undefined);\n    this.className = this.constructor.name;\n    this.fire();\n  }\n}, _class18.type = 'DELETE_ELEMENT', _class18)) || _class17;\n/*\r\n\r\n@RuntimeAccessible\r\nexport class IDLinkAction extends Action{\r\n    constructor() {\r\n        super(IDLinkAction.name,\r\n    }\r\n    nope, uso un proxy\r\n}*/\n\nexport let CompositeAction = RuntimeAccessible(_class19 = (_class20 = class CompositeAction extends Action {\n  static new(actions) {\n    let launch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return new CompositeAction(actions, launch);\n  }\n  constructor(actions) {\n    let launch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super('', '');\n    this.actions = [];\n    this.actions = actions;\n    this.className = this.constructor.name;\n    if (launch) this.fire();\n  }\n}, _class20.type = 'COMPOSITE_ACTION', _class20)) || _class19;\nexport let ParsedAction = RuntimeAccessible(_class21 = class ParsedAction extends SetRootFieldAction {\n  constructor() {\n    super(...arguments);\n    this.path = void 0;\n    this.pathArray = void 0;\n    this.executionCount = void 0;\n  } // path to a property in the store \"something.like.this\"\n  // path splitted \"like.1.this\"\n}) || _class21;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"BEGIN_OLD\");\n$RefreshReg$(_c2, \"ABORT_OLD\");\n$RefreshReg$(_c3, \"END_OLD\");\n$RefreshReg$(_c4, \"BEGIN\");\n$RefreshReg$(_c5, \"ABORT\");\n$RefreshReg$(_c6, \"END\");\n$RefreshReg$(_c7, \"FINAL_END\");\n$RefreshReg$(_c8, \"TRANSACTION\");","map":{"version":3,"names":["Log","RuntimeAccessible","RuntimeAccessibleClass","store","windoww","BEGIN_OLD","pendingActions","hasBegun","_c","ABORT_OLD","_c2","END_OLD","actionstoPrepend","arguments","length","undefined","ca","CompositeAction","fire","_c3","deepnessLevel","BEGIN","_c4","ABORT","_c5","END","console","error","FINAL_END","_c6","_c7","TRANSACTION","func","_len","params","Array","_key","e","ee","_c8","Action","_class","_class2","constructor","field","value","subType","_Error$stack","hasFired","consoleTargetSelector","type","src","Error","stack","split","splice","className","name","forceRelaunch","push","storee","trace","dispatch","parse1","action","ret","path","pathArray","executionCount","possibleInconsistencies","parse","actions","isArray","map","SubType","LoadAction","_class3","_class4","new","state","SetRootFieldAction","_class5","_class6","fullpath","val","accessModifier","isPointer","create","SetFieldAction","_class7","_class8","me","exDev","id","RedoAction","_class9","_class10","amount","notfire","act","UndoAction","_class11","_class12","CombineHistoryAction","_class13","_class14","CreateElementAction","_class15","_class16","newBatch","__raw","DeleteElementAction","_class17","_class18","_class19","_class20","launch","ParsedAction","_class21","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/redux/action/action.ts"],"sourcesContent":["import {\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    IStore,\r\n    Log,\r\n    LPointerTargetable,\r\n    orArr,\r\n    Pack1,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    store,\r\n    unArr,\r\n    windoww\r\n} from \"../../joiner\";\r\n\r\n// transactional-like start of storage modification\r\n// todo: nested transaction che conti quanti begin hai effettuato e crei una matrice di pendingActions una per ogni livello nested?\r\n\r\n/*\r\n// let nestedlevel: number = 0;\r\nclass NestedLevel{\r\n    level: number;\r\n    actions: Action[] = [];\r\n    up:NestedLevel[] = [];\r\n    down?:NestedLevel;\r\n\r\n    constructor(prevLevel?: NestedLevel, actions: Action[] = []) {\r\n        // this.prev = prev;\r\n        this.down = prevLevel;\r\n        this.actions = actions;\r\n        this.level = prevLevel ? prevLevel.level + 1 : 0;\r\n    }\r\n\r\n    add1(a:Action){ this.actions.push(a); }\r\n    add(a:Action[]){ this.actions.push(...a); }\r\n    push(actions:Action[]=[]){\r\n        this.up.push(new NestedLevel(this, actions));\r\n    }\r\n}\r\n// @Singleton\r\nclass NestedTransactionManager{\r\n    // private levels: NestedLevel[] = [];\r\n    public currentLevel?: NestedLevel;\r\n    // simple array is not good i can have spikes as russian mountains going up and down in deepness it's kinda a matrix or a pile of dishes like below'\r\n\r\n\r\n    /*\r\n    todo: to debug missing END paired with a begin, seve stack trace of begins and ends\r\n    * every level must have his own array?\r\n    * Begin0, Begin1, Begin2, End2, End1, Begin1.1 Begin 1.2....\r\n    it's a tree!\r\n    *\r\n    *\r\n    * ______begin lv2                              _______Begin1.2\r\n    * _________________________begin lv1           ___________________Begin1.1\r\n    * ____________________________________________________________________________________________________ a begin lv0\r\n    * * /\r\n    constructor() {}\r\n    begin(actions: Action[]=[]): void { this.pushLevel(actions); }\r\n    pushLevel(actions: Action[]=[]): void {\r\n        if (!this.currentLevel) { this.currentLevel = new NestedLevel(undefined, actions); return; }\r\n        this.currentLevel.push(actions); }\r\n    end(){\r\n        if (!this.currentLevel) return this.finalEnd();\r\n        this.currentLevel = this.currentLevel?.down; }\r\n    finalEnd(){\r\n\r\n    }\r\n    // current(): NestedLevel { return this.currentLevel; }\r\n    addActions(a:Action[]): void { this.currentLevel!.add(a); }\r\n    addAction(a:Action): void { this.currentLevel!.add1(a); }\r\n}\r\nlet transactionmanager = new NestedTransactionManager();\r\nfunction BEGIN2(){\r\n    transactionmanager.pushLevel();\r\n}\r\nfunction ABORT2(){\r\n    transactionmanager.end();\r\n}\r\nfunction END2(){\r\n\r\n}*/\r\n\r\nexport function BEGIN_OLD() {\r\n    pendingActions = [];\r\n    hasBegun = true;\r\n}\r\nexport function ABORT_OLD() {\r\n    hasBegun = false;\r\n    pendingActions = [];\r\n}\r\nexport function END_OLD(actionstoPrepend: Action[] = []): boolean | IStore {\r\n    hasBegun = false;\r\n    // for (let action of pendingActions) { }\r\n    const ca: CompositeAction = new CompositeAction( actionstoPrepend?.length ? [...actionstoPrepend, ...pendingActions] : pendingActions, false);\r\n    pendingActions = [];\r\n    return ca.fire();\r\n}\r\n\r\nlet pendingActions: Action[] = [];\r\nlet hasBegun = false;\r\nlet deepnessLevel = 0;\r\n\r\nexport function BEGIN() {\r\n    hasBegun = true; // redundant but actions are reading this, minimize changes\r\n    deepnessLevel++;\r\n}\r\nexport function ABORT() {\r\n    deepnessLevel--;\r\n    pendingActions = [];\r\n}\r\nexport function END(actionstoPrepend: Action[] = []): boolean {\r\n    deepnessLevel--;\r\n    if (actionstoPrepend.length) pendingActions = [...actionstoPrepend, ...pendingActions];\r\n\r\n    if (deepnessLevel < 0) { console.error(\"mismatching END()\"); deepnessLevel = 0; }\r\n    if (deepnessLevel === 0) return FINAL_END();\r\n    return false;\r\n}\r\nexport function FINAL_END(): boolean{\r\n    hasBegun = false;\r\n    const ca: CompositeAction = new CompositeAction(pendingActions, false);\r\n    pendingActions = [];\r\n    return ca.fire();\r\n}\r\n\r\n// make class isinstorage e mettici il path studia annotazioni per annotare gli oggett in modo che vengano rwappati prima di farli ritornare se sono annotati\r\n// minor todo: type as (...args: infer P) => any) ?\r\nexport function TRANSACTION<F extends ((...args: any) => any)>(func: F, ...params: Parameters<F>): boolean | IStore {\r\n    BEGIN();\r\n    // minor todo: potrei fare l'override di Error() per fare in modo che gli errori vengano presi anche se non uso TRANSACTION o try-catch ?\r\n    try { func(...params); } catch(e) { Log.ee('Transaction failed:', e); ABORT(); return false; }\r\n    return END();\r\n}\r\n\r\n@RuntimeAccessible\r\nexport abstract class Action extends RuntimeAccessibleClass{\r\n    static type = 'ACTION';\r\n    static SubType: {\r\n        vertexSubElements: 'vertexSubElements',\r\n        vertexSize: 'vertexSize'\r\n    };\r\n    hasFired: number = 0;\r\n    // targetID: string | undefined;\r\n    // target: IClass = null as any;\r\n    consoleTargetSelector: string = '';\r\n    // field: string = ''; // es: ID_58\r\n    // value: any; // es: lowerbound, name, namespace, values (for attrib-ref)...\r\n    type: string;\r\n    public field: string;\r\n    public value: any;\r\n    private src?: string[];\r\n    subType?: string; //?\r\n    protected constructor(field: string, value: any, subType?: string){\r\n        super();\r\n        this.field = field;\r\n        this.value = value;\r\n        this.type = (this.constructor as any).type;\r\n        this.src = new Error().stack?.split('\\n').splice( 2);\r\n        this.subType = subType;\r\n        this.className = this.constructor.name;\r\n    }\r\n\r\n    fire(forceRelaunch: boolean = false): boolean {\r\n        if (this.hasFired && !forceRelaunch) return false;\r\n        if (hasBegun) {\r\n            pendingActions.push(this);\r\n        } else {\r\n            this.hasFired++;\r\n            let storee = store || windoww.store;\r\n            console.trace('firing action:', this, 'store:', storee);\r\n            storee.dispatch({...this});\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static possibleInconsistencies: Dictionary<DocString<'subtype'>, Pointer[]> = {};\r\n    private static parse1(action: Action): ParsedAction {\r\n        const ret: ParsedAction = action as any;\r\n        ret.path = action.field; // normalize the path\r\n        ret.pathArray = ret.path.split('.');\r\n        ret.executionCount = 0;\r\n        if (!action.subType) return ret;\r\n        if (!Action.possibleInconsistencies[action.subType]) Action.possibleInconsistencies[action.subType] = [ action.value ];\r\n        else Action.possibleInconsistencies[action.subType].push(action.value);\r\n        return ret;\r\n    }\r\n\r\n    static parse<T extends Action | Action[], RET extends T extends any[] ? ParsedAction[] : ParsedAction>(actions: T): RET {\r\n        if ((actions as Action).className === CompositeAction.name) throw new Error(\"Composite action cannot be parsed directly, parse composite.actions instead\");\r\n        if (!Array.isArray(actions)) return Action.parse1(actions) as RET;\r\n        return actions.map( Action.parse1 ) as RET;\r\n    }\r\n}\r\n@RuntimeAccessible\r\nexport class LoadAction extends Action {\r\n    static type = 'LOAD';\r\n    static new(state: IStore): boolean {  return state && new LoadAction(state).fire(); }\r\n    constructor(state: IStore, fire: boolean = true) {\r\n        super('', state, '');\r\n        this.className = this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class SetRootFieldAction extends Action {\r\n    static type = 'SET_ROOT_FIELD';\r\n    isPointer: boolean;\r\n\r\n\r\n\r\n    static new(fullpath: string, val: string | string[], accessModifier: AccessModifier | undefined, isPointer: boolean): boolean;\r\n    static new<\r\n        VAL extends any,\r\n        PATH extends VAL extends string | string[] ? 'must specify \"isPointer\" parameter' : string,\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: PATH, val: VAL, accessModifier?: AM | undefined, isPointer?: ISPOINTER): boolean;\r\n    static new<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): boolean {\r\n        if (accessModifier) (fullpath as any) += accessModifier;\r\n        return new SetRootFieldAction(fullpath, val, false, isPointer).fire();\r\n    }\r\n\r\n    protected constructor(fullpath: string, value: any = undefined, fire: boolean = true, isPointer: boolean = false) {\r\n        super(fullpath, value, undefined);\r\n        this.className = this.constructor.name;\r\n        this.isPointer = isPointer;\r\n        if (fire) this.fire();\r\n    }\r\n\r\n    static create<\r\n        T extends string,\r\n        VAL extends any,\r\n        ISPOINTER extends boolean,\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(fullpath: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): SetRootFieldAction {\r\n        return new SetRootFieldAction(fullpath + (accessModifier || ''), val, false, isPointer);\r\n    }\r\n}\r\n\r\n// todo: ma non so come, fare in modo che [], +=, -=, siano disponibili solo se la chiave è il nome di un attributo di tipo array\r\ntype arrayFieldNameTypes<D> = keyof D | `${string & keyof D}[]` | `${string & keyof D}+=` | `${string & keyof D}-=` | `${string & keyof D}.${number}` | `${string & keyof D}[${number}]`;\r\ntype AccessModifier = '' | '[]' | '+=' | '-=' | `.${number}` | `[${number}]` | undefined;\r\n\r\n\r\ntype StrictExclude<T, U> = T extends U ? U extends T ? never : T : T;\r\n\r\n@RuntimeAccessible\r\nexport class SetFieldAction extends SetRootFieldAction {\r\n    static type = 'SET_ME_FIELD';\r\n/*\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        AM extends AccessModifier | undefined = ''\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: string | string[],\r\n          accessModifier: AM | undefined,\r\n          isPointer: boolean): boolean;*/\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends\r\n            D[T] extends string | string[] ? 'must specify \"isPointer\" parameter' :\r\n            (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        // VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        /*VAL extends (AM extends undefined | '' ? (D[T] extends any[] ? StrictExclude<D[T], string[]> : StrictExclude<D[T], string>) :\r\n            (AM extends '-=' ?\r\n                number[] :\r\n                (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<StrictExclude<D[T], string>> | StrictExclude<D[T], string> | (StrictExclude<D[T], string>)[] : '_error_'))),\r\n        */\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n        // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>,\r\n          field: T,\r\n          val: VAL,\r\n          accessModifier?: AM | undefined,\r\n          isPointer?: ISPOINTER): boolean;\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends (keyof D),\r\n        VAL extends AM extends '' | undefined ? orArr<string | null | undefined> :\r\n            (AM extends '-=' ? orArr<number> :\r\n                (AM extends '+=' ? orArr<string | null | undefined> : '_am_typeerror_')),\r\n        AM extends AccessModifier | undefined = undefined,\r\n        >(me: D | Pointer<D>, field: T,\r\n          val: VAL,\r\n          accessModifier: AM,\r\n          isPointer: boolean): boolean;\r\n\r\n    static new<\r\n        D extends DPointerTargetable,\r\n        T extends string & (keyof D),\r\n        VAL extends (AM extends undefined | '' ? D[T] : (AM extends '-=' ? number[] : (AM extends '+=' | '[]' | `[${number}]` | `.${number}` ? unArr<D[T]> | D[T] | D[T][] : '_error_'))),\r\n        ISPOINTER extends boolean | \"todo: ISPOINTER type = boolean but required only if val is UnArr< string > = string | string[], maybe do with override\",\r\n        AM extends AccessModifier | undefined = undefined,\r\n    // T extends arrayFieldNameTypes<D> = any\r\n        >(me: D | Pointer<D>, field: T, val: VAL, accessModifier: AM | undefined = undefined, isPointer?: ISPOINTER): boolean {\r\n        if (accessModifier) (field as any) += accessModifier;\r\n        return new SetFieldAction(me, field, val, false, isPointer as boolean).fire();\r\n    }\r\n\r\n\r\n    // field can end with \"+=\", \"[]\", or \"-1\" if it's array\r\n    protected constructor(me: DPointerTargetable | Pointer, field: string, val: any, fire: boolean = true, isPointer: boolean = false) {\r\n        Log.exDev(!me, 'BaseObject missing in SetFieldAction', {me, field, val});\r\n        super('idlookup.' + ((me as DPointerTargetable).id || me) + ( field ? '.' + field : ''), val, false, isPointer);\r\n        this.className = this.constructor.name;\r\n        if (fire) this.fire();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\ntodo: showcase this\r\nlet dclass: DClass = null as any;\r\nSetFieldAction.new(dclass, 'namek', '') // non è un attributo di \"DCLass\"\r\nSetFieldAction.new(dclass, 'parent', '') // val (stringa) non è assegnabile a parent (array di puntatori)\r\nSetFieldAction.new(dclass, 'name.5k', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4k]', '') // non è un indice array valido\r\nSetFieldAction.new(dclass, 'name[4]', '') // ok, anche se non dovrebbe accettare la dicitura array per name che è un primitivo (check non implementato, troppo difficile)\r\nSetFieldAction.new(dclass, 'name.5', '') // ok, equivale a dicitura array\r\n*/\r\n\r\n@RuntimeAccessible\r\nexport class RedoAction extends Action {\r\n    static type = 'RedoAction';\r\n    public static new<F extends boolean = true>(amount: number = 1, notfire?: F): (F extends false ? boolean : RedoAction) {\r\n        let act = new RedoAction(amount);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(amount: number = 1) {\r\n        super('', amount);\r\n        this.className = this.constructor.name;\r\n    }\r\n}\r\n@RuntimeAccessible\r\nexport class UndoAction extends Action {\r\n    static type = 'UndoAction';\r\n    public static new<F extends boolean = true>(amount: number = 1, notfire?: F): (F extends false ? boolean : UndoAction) {\r\n        let act = new UndoAction(amount);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(amount: number = 1) {\r\n        super('', amount);\r\n        this.className = this.constructor.name;\r\n    }\r\n}\r\n@RuntimeAccessible\r\nexport class CombineHistoryAction extends Action {\r\n    static type = 'CombineHistoryAction';\r\n    public static new<F extends boolean = true>(notfire?: F): (F extends false ? boolean : CombineHistoryAction) {\r\n        let act = new CombineHistoryAction();\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor() {\r\n        super('', '');\r\n        this.className = this.constructor.name;\r\n    }\r\n}\r\n@RuntimeAccessible\r\nexport class CreateElementAction extends Action {\r\n    static type = 'CREATE_ELEMENT';\r\n    value!: DPointerTargetable;\r\n    public static newBatch<F extends boolean = true>(me: DPointerTargetable[], notfire?: F): (F extends false ? boolean : CreateElementAction)[]{\r\n        return me.map( (e) => CreateElementAction.new(e, notfire));\r\n    }\r\n\r\n    public static new<F extends boolean = true>(me: DPointerTargetable , notfire?: F): (F extends false ? boolean : CreateElementAction) {\r\n        if ((me as LPointerTargetable).__raw) me = (me as LPointerTargetable).__raw;\r\n        let act = new CreateElementAction(me, !notfire);\r\n        if (!notfire) return act.fire() as any;\r\n        return act as any;\r\n    }\r\n    private constructor(me: DPointerTargetable, fire: boolean = true) {\r\n        super('idlookup.' + me.id, me);\r\n        this.className = this.constructor.name;\r\n        this.value = me;\r\n        if (fire) this.fire();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class DeleteElementAction extends SetFieldAction {\r\n    static type = 'DELETE_ELEMENT';\r\n    public static new(me: Pack1<LPointerTargetable>): boolean {\r\n        return new DeleteElementAction(me as any).fire(); }\r\n    constructor(me: DPointerTargetable | Pointer) {\r\n        super((me as DPointerTargetable).id || me, '', undefined);\r\n        this.className = this.constructor.name;\r\n        this.fire();\r\n    }\r\n}\r\n/*\r\n\r\n@RuntimeAccessible\r\nexport class IDLinkAction extends Action{\r\n    constructor() {\r\n        super(IDLinkAction.name,\r\n    }\r\n    nope, uso un proxy\r\n}*/\r\n\r\n@RuntimeAccessible\r\nexport class CompositeAction extends Action {\r\n    static type: string = 'COMPOSITE_ACTION';\r\n    actions: Action[] = [];\r\n\r\n    public static new(actions: Action[], launch: boolean = true): CompositeAction { return new CompositeAction(actions, launch); }\r\n    constructor(actions: Action[], launch: boolean = false) {\r\n        super('', '');\r\n        this.actions = actions;\r\n        this.className = this.constructor.name;\r\n        if (launch) this.fire();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class ParsedAction extends SetRootFieldAction {\r\n    path!: string; // path to a property in the store \"something.like.this\"\r\n    pathArray!: string[]; // path splitted \"like.1.this\"\r\n    executionCount!: number;\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}