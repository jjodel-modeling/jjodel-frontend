{"ast":null,"code":"var _dec, _class, _class2;\nimport { EcoreParser, LoadAction, Log, U, LPointerTargetable, prjson2xml, prxml2json, store, RuntimeAccessible, Selectors, Debug } from '../../joiner';\nexport let SaveManager = (_dec = RuntimeAccessible('SaveManager'), _dec(_class = (_class2 = class SaveManager {\n  static save() {\n    SaveManager.tmpsave = store.getState();\n    localStorage.setItem(\"tmpsave\", JSON.stringify(SaveManager.tmpsave));\n    console.clear();\n    console.log(JSON.stringify(SaveManager.tmpsave));\n  }\n  static load(state) {\n    if (!state && SaveManager.tmpsave) {\n      LoadAction.new(SaveManager.tmpsave);\n      return;\n    }\n    state = state || localStorage.getItem('tmpsave') || 'null'; // priorities: 1) argument from file 2) state variable cached 3) localstorage 4) null prevent crash\n    SaveManager.tmpsave = JSON.parse(state);\n    LoadAction.new(SaveManager.tmpsave);\n  }\n  static exportEcore_click() {\n    var _lmodel$instanceof;\n    let toXML = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let toFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // e: React.MouseEvent,\n    let lmodel = Selectors.getActiveModel();\n    if (!lmodel) return;\n    let json = SaveManager.exportEcore(lmodel);\n    let str = JSON.stringify(json, null, \"\\t\");\n    if (toXML) {\n      str = prjson2xml.json2xml(json, '\\t');\n      str = U.formatXml(str);\n    }\n    if (!toFile) {\n      // (document.querySelector(\"#export-tmp\") as any).innerText = str;\n      localStorage.setItem(\"import\", str);\n      return;\n    }\n    let ism2 = lmodel.isMetamodel;\n    let name = (lmodel.name || (ism2 ? 'M2' : 'M1') + '_unnamed') + (toXML ? \".xml\" : '.json') + \".\" + (ism2 ? \"ecore\" : ((_lmodel$instanceof = lmodel.instanceof) === null || _lmodel$instanceof === void 0 ? void 0 : _lmodel$instanceof.name) || \"shapeless\");\n    console.log(\"download file:\", {\n      name,\n      ism2,\n      toXML,\n      lmodel,\n      instanceof: lmodel.instanceof\n    });\n    U.download(name, str);\n  }\n  static importEcore_click() {\n    let fromXML = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let fromfile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    try {\n      this.importEcore_click0(fromXML, fromfile);\n    } catch (e) {\n      var _e$message, _e$message$substring;\n      let str = (e === null || e === void 0 ? void 0 : (_e$message = e.message) === null || _e$message === void 0 ? void 0 : (_e$message$substring = _e$message.substring) === null || _e$message$substring === void 0 ? void 0 : _e$message$substring.call(_e$message, 0, 1000)) || 'some error';\n      console.trace(str, e);\n      // throw new Error(str);\n    }\n  }\n  static importEcore_click0() {\n    let fromXML = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let fromfile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const extensions = [fromXML ? \"*.xml.*\" : \"*.json.*\"]; // [\".ecore\"]; // Selectors.getActiveModel().isM1() ? '.' + Selectors.getActiveModel().metamodel.fullname() : '.ecore';\n    let filestring,\n      jsonstring,\n      jsonobj = undefined;\n    console.log(\"importEcore: prefromfile\");\n    if (!fromfile) {\n      filestring = localStorage.getItem(\"import\") || 'null';\n      if (fromXML) {\n        const xmlDoc = new DOMParser().parseFromString(filestring, \"text/xml\");\n        jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');\n      }\n      //if (filestring.includes(\"\\n\")) throw new Error(filestring.substring(0, 1000));\n      SaveManager.importEcore(jsonobj || filestring, true, undefined, true); // todo: trova il modo di determinare se è m1 o m2 senza filename\n      return;\n    }\n    console.log(\"importEcore: pre file read\", {\n      fromXML,\n      fromfile\n    });\n    let filename;\n    U.fileRead((e, files, fileContents) => {\n      var _e$target$files;\n      Log.ex(!fileContents || !files || fileContents.length !== files.length, 'Failed to get file contents:', files, fileContents);\n      Log.ex(fileContents && fileContents.length > 1, 'Should not be possible to input multiple files yet.');\n      if (!fileContents) return;\n      if (fileContents.length == 0) return;\n      // @ts-ignore\n      filename = (_e$target$files = e.target.files) === null || _e$target$files === void 0 ? void 0 : _e$target$files[0].name;\n      console.log(\"file read\", {\n        e,\n        fileContents,\n        files,\n        filename\n      });\n      filestring = fileContents[0];\n\n      // if file is over 500kb, lightmode on\n      if (filestring.length >= 500 * 1024 && !Debug.lightMode) {\n        Debug.setLightMode(true);\n        // $(document).one(\"click\", (e) => { Debug.setLightMode(false); });\n      }\n      console.log('importEcore filestring input: ', filestring);\n      if (fromXML) {\n        let windoww = window;\n        windoww.file = filestring;\n        windoww.todoc = str => new DOMParser().parseFromString(str, \"text/xml\");\n        windoww.doctojson = doc => prxml2json.xml2jsonobj(doc, ' ');\n        // problemi doctojson or xmi parser: \\n replacemet causa crash per stringa in posizione invalida. \\\" anche per attributi inline che iniiano con \\\\\"\n        // filestring = U.multiReplaceAll(filestring, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\n\n        const xmlDoc = new DOMParser().parseFromString(filestring, \"text/xml\");\n        console.log('importEcore xml:', xmlDoc);\n        let jsonstring0 = '';\n        jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' '); //doto: non devo wrappare con \\\" i nomi di chiavi o valori ma solo i contenuti\n        /*jsonstring = jsonstring0;\r\n        //jsonstring = U.multiReplaceAll(jsonstring0, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n        */ //jsonstring = jsonstring.replaceAll(/(\\{|\\,)\\\\n\\s*/gm, \"\")\n        /*if (jsonstring.includes(\"\\n\")) throw new Error(jsonstring0.substring(0, 1000)+\"\\n\\n\\n\\n\" + jsonstring.substring(0, 1000));\r\n        */\n        // jsonstring = JSON.stringify(jsonobj);\n        if (jsonobj.parsererror) {\n          Log.e(\"failed to parse XML->JSON\", {\n            parseError: jsonobj.parseerror,\n            jsonobj\n          });\n          return;\n        }\n        console.log('importEcore jsonstr input: ', jsonobj);\n      } else jsonstring = filestring;\n      let isMetamodel = filename.indexOf(\".ecore\") === filename.length - \".ecore\".length;\n      console.log(\"ismetamodel\", {\n        filename,\n        isMetamodel\n      });\n      let end = SaveManager.importEcore(jsonobj || jsonstring || 'null', isMetamodel, filename, true);\n    }, extensions, true);\n  }\n  static exportEcore(model) {\n    let loopobj = {};\n    try {\n      return model.generateEcoreJson(loopobj);\n    } catch (e) {\n      Log.exx(\"possible loop in model:\\t\\n\" + e.message, {\n        loopobj,\n        e\n      });\n    }\n    return {\n      \"error\": true,\n      loopobj\n    };\n  }\n  static importEcore(jsonstr, isMetamodel, filename) {\n    let persist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return EcoreParser.parse(jsonstr, isMetamodel, filename, persist);\n  }\n  static exportLayout_click(toFile) {\n    let lmodel = LPointerTargetable.wrap(store.getState().models[0]);\n    // lmodel.node?.allSubNodes\n  }\n  static importLayout_click(fromFile) {}\n}, _class2.tmpsave = void 0, _class2)) || _class);","map":{"version":3,"names":["EcoreParser","LoadAction","Log","U","LPointerTargetable","prjson2xml","prxml2json","store","RuntimeAccessible","Selectors","Debug","SaveManager","_dec","_class","_class2","save","tmpsave","getState","localStorage","setItem","JSON","stringify","console","clear","log","load","state","new","getItem","parse","exportEcore_click","_lmodel$instanceof","toXML","arguments","length","undefined","toFile","lmodel","getActiveModel","json","exportEcore","str","json2xml","formatXml","ism2","isMetamodel","name","instanceof","download","importEcore_click","fromXML","fromfile","importEcore_click0","e","_e$message","_e$message$substring","message","substring","call","trace","extensions","filestring","jsonstring","jsonobj","xmlDoc","DOMParser","parseFromString","xml2jsonobj","importEcore","filename","fileRead","files","fileContents","_e$target$files","ex","target","lightMode","setLightMode","windoww","window","file","todoc","doctojson","doc","jsonstring0","parsererror","parseError","parseerror","indexOf","end","model","loopobj","generateEcoreJson","exx","jsonstr","persist","exportLayout_click","wrap","models","importLayout_click","fromFile"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/components/topbar/SaveManager.ts"],"sourcesContent":["import {\r\n    Dictionary, DUser,\r\n    EcoreParser, GObject, DState,\r\n    Json,\r\n    LModel,\r\n    LoadAction,\r\n    Log, U,\r\n    LPointerTargetable, prjson2xml, prxml2json,\r\n    store, RuntimeAccessible, DModelElement, SetRootFieldAction, Selectors, Debug\r\n} from '../../joiner';\r\n\r\n@RuntimeAccessible('SaveManager')\r\nexport class SaveManager {\r\n    private static tmpsave: DState;\r\n\r\n    static save(): void {\r\n        SaveManager.tmpsave = store.getState();\r\n        localStorage.setItem(\"tmpsave\", JSON.stringify(SaveManager.tmpsave));\r\n        console.clear();\r\n        console.log(JSON.stringify(SaveManager.tmpsave))\r\n    }\r\n\r\n    static load(state?: string): void {\r\n        if (!state && SaveManager.tmpsave) { LoadAction.new(SaveManager.tmpsave); return; }\r\n        state = state || localStorage.getItem('tmpsave') || 'null'; // priorities: 1) argument from file 2) state variable cached 3) localstorage 4) null prevent crash\r\n        SaveManager.tmpsave = JSON.parse(state);\r\n        LoadAction.new(SaveManager.tmpsave);\r\n    }\r\n\r\n    public static exportEcore_click(toXML: boolean = false, toFile: boolean = true): void { // e: React.MouseEvent,\r\n        let lmodel: null|LModel = Selectors.getActiveModel();\r\n        if (!lmodel) return;\r\n        let json = SaveManager.exportEcore(lmodel);\r\n        let str = JSON.stringify(json, null, \"\\t\");\r\n        if (toXML) {\r\n            str = prjson2xml.json2xml(json, '\\t');\r\n            str = U.formatXml(str);\r\n        }\r\n\r\n        if (!toFile) {\r\n            // (document.querySelector(\"#export-tmp\") as any).innerText = str;\r\n            localStorage.setItem(\"import\", str);\r\n            return;\r\n        }\r\n        let ism2 = (lmodel as LModel).isMetamodel;\r\n        let name = (lmodel.name || (ism2 ? 'M2' : 'M1') + '_unnamed')  + (toXML ? \".xml\" : '.json') + \".\"+ (ism2 ? \"ecore\" : lmodel.instanceof?.name || \"shapeless\");\r\n        console.log(\"download file:\", {name, ism2, toXML, lmodel, instanceof:lmodel.instanceof});\r\n        U.download(name, str);\r\n    }\r\n\r\n    public static importEcore_click(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        try { this.importEcore_click0(fromXML, fromfile); } catch (e: any) {\r\n            let str = e?.message?.substring?.(0, 1000) || 'some error';\r\n            console.trace(str, e);\r\n            // throw new Error(str);\r\n        }\r\n    }\r\n    public static importEcore_click0(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        const extensions: string[] = [(fromXML ? \"*.xml.*\" : \"*.json.*\")]; // [\".ecore\"]; // Selectors.getActiveModel().isM1() ? '.' + Selectors.getActiveModel().metamodel.fullname() : '.ecore';\r\n        let filestring: string, jsonstring: string, jsonobj: GObject = undefined as any;\r\n        console.log(\"importEcore: prefromfile\");\r\n        if (!fromfile) {\r\n            filestring = localStorage.getItem(\"import\") || 'null';\r\n            if (fromXML) {\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');\r\n            }\r\n            //if (filestring.includes(\"\\n\")) throw new Error(filestring.substring(0, 1000));\r\n            SaveManager.importEcore(jsonobj || filestring, true, undefined, true); // todo: trova il modo di determinare se è m1 o m2 senza filename\r\n            return; }\r\n\r\n        console.log(\"importEcore: pre file read\", {fromXML, fromfile});\r\n        let filename;\r\n        U.fileRead((e: Event, files?: FileList | null, fileContents?: string[]) => {\r\n            Log.ex(!fileContents || !files || fileContents.length !== files.length, 'Failed to get file contents:', files, fileContents);\r\n            Log.ex(fileContents && fileContents.length > 1, 'Should not be possible to input multiple files yet.');\r\n            if (!fileContents) return;\r\n            if (fileContents.length == 0) return;\r\n            // @ts-ignore\r\n            filename = e.target.files?.[0].name;\r\n            console.log(\"file read\", {e, fileContents, files, filename});\r\n            filestring = fileContents[0];\r\n\r\n            // if file is over 500kb, lightmode on\r\n            if (filestring.length >= 500*1024 && !Debug.lightMode) {\r\n                Debug.setLightMode(true);\r\n                // $(document).one(\"click\", (e) => { Debug.setLightMode(false); });\r\n            }\r\n\r\n            console.log('importEcore filestring input: ', filestring);\r\n            if (fromXML) {\r\n                let windoww = window as any;\r\n                windoww.file = filestring;\r\n                windoww.todoc = (str: any) => new DOMParser().parseFromString(str,\"text/xml\");\r\n                windoww.doctojson = (doc: any) => prxml2json.xml2jsonobj(doc, ' ');\r\n                // problemi doctojson or xmi parser: \\n replacemet causa crash per stringa in posizione invalida. \\\" anche per attributi inline che iniiano con \\\\\"\r\n                // filestring = U.multiReplaceAll(filestring, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                console.log('importEcore xml:', xmlDoc);\r\n                let jsonstring0 = '';\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');//doto: non devo wrappare con \\\" i nomi di chiavi o valori ma solo i contenuti\r\n                /*jsonstring = jsonstring0;\r\n                //jsonstring = U.multiReplaceAll(jsonstring0, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n                *///jsonstring = jsonstring.replaceAll(/(\\{|\\,)\\\\n\\s*/gm, \"\")\r\n                /*if (jsonstring.includes(\"\\n\")) throw new Error(jsonstring0.substring(0, 1000)+\"\\n\\n\\n\\n\" + jsonstring.substring(0, 1000));\r\n                */\r\n                // jsonstring = JSON.stringify(jsonobj);\r\n                if (jsonobj.parsererror) { Log.e(\"failed to parse XML->JSON\", {parseError:jsonobj.parseerror, jsonobj});  return; }\r\n                console.log('importEcore jsonstr input: ', jsonobj);\r\n            }\r\n            else jsonstring = filestring;\r\n            let isMetamodel = filename.indexOf(\".ecore\") === filename.length - \".ecore\".length;\r\n            console.log(\"ismetamodel\", {filename, isMetamodel});\r\n            let end = SaveManager.importEcore(jsonobj || jsonstring || 'null', isMetamodel, filename, true);\r\n        }, extensions, true);\r\n    }\r\n\r\n    public static exportEcore(model: LModel): Json {\r\n        let loopobj = {};\r\n        try { return model.generateEcoreJson(loopobj); }\r\n        catch(e) { Log.exx(\"possible loop in model:\\t\\n\" + (e as Error).message, {loopobj, e}); }\r\n        return {\"error\": true, loopobj};\r\n    }\r\n    public static importEcore(jsonstr: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[] {\r\n        return EcoreParser.parse(jsonstr, isMetamodel, filename, persist);\r\n    }\r\n\r\n    static exportLayout_click(toFile: boolean) {\r\n        let lmodel: LModel = (LPointerTargetable.wrap(store.getState().models[0]) as LModel);\r\n        // lmodel.node?.allSubNodes\r\n\r\n    }\r\n    static importLayout_click(fromFile: boolean) {\r\n\r\n    }\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}